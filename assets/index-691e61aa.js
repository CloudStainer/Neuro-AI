var Iv = Object.defineProperty;
var Nv = (r, e, t) =>
  e in r
    ? Iv(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t })
    : (r[e] = t);
var In = (r, e, t) => (Nv(r, typeof e != "symbol" ? e + "" : e, t), t),
  Ov = (r, e, t) => {
    if (!e.has(r)) throw TypeError("Cannot " + t);
  };
var Us = (r, e, t) => {
  if (e.has(r))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(r) : e.set(r, t);
};
var Fs = (r, e, t) => (Ov(r, e, "access private method"), t);
(function () {
  const e = document.createElement("link").relList;
  if (e && e.supports && e.supports("modulepreload")) return;
  for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i);
  new MutationObserver((i) => {
    for (const s of i)
      if (s.type === "childList")
        for (const a of s.addedNodes)
          a.tagName === "LINK" && a.rel === "modulepreload" && n(a);
  }).observe(document, { childList: !0, subtree: !0 });
  function t(i) {
    const s = {};
    return (
      i.integrity && (s.integrity = i.integrity),
      i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy),
      i.crossOrigin === "use-credentials"
        ? (s.credentials = "include")
        : i.crossOrigin === "anonymous"
        ? (s.credentials = "omit")
        : (s.credentials = "same-origin"),
      s
    );
  }
  function n(i) {
    if (i.ep) return;
    i.ep = !0;
    const s = t(i);
    fetch(i.href, s);
  }
})();
/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */ const Af = "152",
  Bs = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 },
  ks = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 },
  Uv = 0,
  Id = 1,
  Fv = 2,
  I_ = 1,
  Bv = 2,
  ji = 3,
  or = 0,
  bn = 1,
  wi = 2,
  Cr = 0,
  Sa = 1,
  Nd = 2,
  Od = 3,
  Ud = 4,
  kv = 5,
  la = 100,
  zv = 101,
  Hv = 102,
  Fd = 103,
  Bd = 104,
  Vv = 200,
  Gv = 201,
  Wv = 202,
  Xv = 203,
  N_ = 204,
  O_ = 205,
  Yv = 206,
  qv = 207,
  jv = 208,
  Kv = 209,
  $v = 210,
  Zv = 0,
  Jv = 1,
  Qv = 2,
  Rh = 3,
  ex = 4,
  tx = 5,
  nx = 6,
  ix = 7,
  U_ = 0,
  rx = 1,
  sx = 2,
  rr = 0,
  ax = 1,
  ox = 2,
  lx = 3,
  cx = 4,
  ux = 5,
  F_ = 300,
  Ia = 301,
  Na = 302,
  Ch = 303,
  Ph = 304,
  su = 306,
  Oa = 1e3,
  Jn = 1001,
  Lc = 1002,
  qt = 1003,
  Lh = 1004,
  pc = 1005,
  Sn = 1006,
  B_ = 1007,
  Ss = 1008,
  Ms = 1009,
  hx = 1010,
  fx = 1011,
  k_ = 1012,
  dx = 1013,
  os = 1014,
  Er = 1015,
  Vo = 1016,
  px = 1017,
  mx = 1018,
  Ma = 1020,
  _x = 1021,
  Qn = 1023,
  gx = 1024,
  vx = 1025,
  hs = 1026,
  Ua = 1027,
  xx = 1028,
  yx = 1029,
  Ex = 1030,
  Sx = 1031,
  Mx = 1033,
  Ru = 33776,
  Cu = 33777,
  Pu = 33778,
  Lu = 33779,
  kd = 35840,
  zd = 35841,
  Hd = 35842,
  Vd = 35843,
  bx = 36196,
  Gd = 37492,
  Wd = 37496,
  Xd = 37808,
  Yd = 37809,
  qd = 37810,
  jd = 37811,
  Kd = 37812,
  $d = 37813,
  Zd = 37814,
  Jd = 37815,
  Qd = 37816,
  ep = 37817,
  tp = 37818,
  np = 37819,
  ip = 37820,
  rp = 37821,
  Du = 36492,
  Tx = 36283,
  sp = 36284,
  ap = 36285,
  op = 36286,
  Go = 2300,
  Fa = 2301,
  Iu = 2302,
  lp = 2400,
  cp = 2401,
  up = 2402,
  Ax = 2500,
  wx = 0,
  z_ = 1,
  Dh = 2,
  H_ = 3e3,
  fs = 3001,
  Rx = 3200,
  Cx = 3201,
  V_ = 0,
  Px = 1,
  ds = "",
  Ve = "srgb",
  Ii = "srgb-linear",
  G_ = "display-p3",
  Nu = 7680,
  Lx = 519,
  Ih = 35044,
  hp = "300 es",
  Nh = 1035;
class Ds {
  addEventListener(e, t) {
    this._listeners === void 0 && (this._listeners = {});
    const n = this._listeners;
    n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t);
  }
  hasEventListener(e, t) {
    if (this._listeners === void 0) return !1;
    const n = this._listeners;
    return n[e] !== void 0 && n[e].indexOf(t) !== -1;
  }
  removeEventListener(e, t) {
    if (this._listeners === void 0) return;
    const i = this._listeners[e];
    if (i !== void 0) {
      const s = i.indexOf(t);
      s !== -1 && i.splice(s, 1);
    }
  }
  dispatchEvent(e) {
    if (this._listeners === void 0) return;
    const n = this._listeners[e.type];
    if (n !== void 0) {
      e.target = this;
      const i = n.slice(0);
      for (let s = 0, a = i.length; s < a; s++) i[s].call(this, e);
      e.target = null;
    }
  }
}
const en = [
  "00",
  "01",
  "02",
  "03",
  "04",
  "05",
  "06",
  "07",
  "08",
  "09",
  "0a",
  "0b",
  "0c",
  "0d",
  "0e",
  "0f",
  "10",
  "11",
  "12",
  "13",
  "14",
  "15",
  "16",
  "17",
  "18",
  "19",
  "1a",
  "1b",
  "1c",
  "1d",
  "1e",
  "1f",
  "20",
  "21",
  "22",
  "23",
  "24",
  "25",
  "26",
  "27",
  "28",
  "29",
  "2a",
  "2b",
  "2c",
  "2d",
  "2e",
  "2f",
  "30",
  "31",
  "32",
  "33",
  "34",
  "35",
  "36",
  "37",
  "38",
  "39",
  "3a",
  "3b",
  "3c",
  "3d",
  "3e",
  "3f",
  "40",
  "41",
  "42",
  "43",
  "44",
  "45",
  "46",
  "47",
  "48",
  "49",
  "4a",
  "4b",
  "4c",
  "4d",
  "4e",
  "4f",
  "50",
  "51",
  "52",
  "53",
  "54",
  "55",
  "56",
  "57",
  "58",
  "59",
  "5a",
  "5b",
  "5c",
  "5d",
  "5e",
  "5f",
  "60",
  "61",
  "62",
  "63",
  "64",
  "65",
  "66",
  "67",
  "68",
  "69",
  "6a",
  "6b",
  "6c",
  "6d",
  "6e",
  "6f",
  "70",
  "71",
  "72",
  "73",
  "74",
  "75",
  "76",
  "77",
  "78",
  "79",
  "7a",
  "7b",
  "7c",
  "7d",
  "7e",
  "7f",
  "80",
  "81",
  "82",
  "83",
  "84",
  "85",
  "86",
  "87",
  "88",
  "89",
  "8a",
  "8b",
  "8c",
  "8d",
  "8e",
  "8f",
  "90",
  "91",
  "92",
  "93",
  "94",
  "95",
  "96",
  "97",
  "98",
  "99",
  "9a",
  "9b",
  "9c",
  "9d",
  "9e",
  "9f",
  "a0",
  "a1",
  "a2",
  "a3",
  "a4",
  "a5",
  "a6",
  "a7",
  "a8",
  "a9",
  "aa",
  "ab",
  "ac",
  "ad",
  "ae",
  "af",
  "b0",
  "b1",
  "b2",
  "b3",
  "b4",
  "b5",
  "b6",
  "b7",
  "b8",
  "b9",
  "ba",
  "bb",
  "bc",
  "bd",
  "be",
  "bf",
  "c0",
  "c1",
  "c2",
  "c3",
  "c4",
  "c5",
  "c6",
  "c7",
  "c8",
  "c9",
  "ca",
  "cb",
  "cc",
  "cd",
  "ce",
  "cf",
  "d0",
  "d1",
  "d2",
  "d3",
  "d4",
  "d5",
  "d6",
  "d7",
  "d8",
  "d9",
  "da",
  "db",
  "dc",
  "dd",
  "de",
  "df",
  "e0",
  "e1",
  "e2",
  "e3",
  "e4",
  "e5",
  "e6",
  "e7",
  "e8",
  "e9",
  "ea",
  "eb",
  "ec",
  "ed",
  "ee",
  "ef",
  "f0",
  "f1",
  "f2",
  "f3",
  "f4",
  "f5",
  "f6",
  "f7",
  "f8",
  "f9",
  "fa",
  "fb",
  "fc",
  "fd",
  "fe",
  "ff",
];
let fp = 1234567;
const bo = Math.PI / 180,
  Ba = 180 / Math.PI;
function gi() {
  const r = (Math.random() * 4294967295) | 0,
    e = (Math.random() * 4294967295) | 0,
    t = (Math.random() * 4294967295) | 0,
    n = (Math.random() * 4294967295) | 0;
  return (
    en[r & 255] +
    en[(r >> 8) & 255] +
    en[(r >> 16) & 255] +
    en[(r >> 24) & 255] +
    "-" +
    en[e & 255] +
    en[(e >> 8) & 255] +
    "-" +
    en[((e >> 16) & 15) | 64] +
    en[(e >> 24) & 255] +
    "-" +
    en[(t & 63) | 128] +
    en[(t >> 8) & 255] +
    "-" +
    en[(t >> 16) & 255] +
    en[(t >> 24) & 255] +
    en[n & 255] +
    en[(n >> 8) & 255] +
    en[(n >> 16) & 255] +
    en[(n >> 24) & 255]
  ).toLowerCase();
}
function $t(r, e, t) {
  return Math.max(e, Math.min(t, r));
}
function wf(r, e) {
  return ((r % e) + e) % e;
}
function Dx(r, e, t, n, i) {
  return n + ((r - e) * (i - n)) / (t - e);
}
function Ix(r, e, t) {
  return r !== e ? (t - r) / (e - r) : 0;
}
function To(r, e, t) {
  return (1 - t) * r + t * e;
}
function Nx(r, e, t, n) {
  return To(r, e, 1 - Math.exp(-t * n));
}
function Ox(r, e = 1) {
  return e - Math.abs(wf(r, e * 2) - e);
}
function Ux(r, e, t) {
  return r <= e
    ? 0
    : r >= t
    ? 1
    : ((r = (r - e) / (t - e)), r * r * (3 - 2 * r));
}
function Fx(r, e, t) {
  return r <= e
    ? 0
    : r >= t
    ? 1
    : ((r = (r - e) / (t - e)), r * r * r * (r * (r * 6 - 15) + 10));
}
function Bx(r, e) {
  return r + Math.floor(Math.random() * (e - r + 1));
}
function kx(r, e) {
  return r + Math.random() * (e - r);
}
function zx(r) {
  return r * (0.5 - Math.random());
}
function Hx(r) {
  r !== void 0 && (fp = r);
  let e = (fp += 1831565813);
  return (
    (e = Math.imul(e ^ (e >>> 15), e | 1)),
    (e ^= e + Math.imul(e ^ (e >>> 7), e | 61)),
    ((e ^ (e >>> 14)) >>> 0) / 4294967296
  );
}
function Vx(r) {
  return r * bo;
}
function Gx(r) {
  return r * Ba;
}
function Oh(r) {
  return (r & (r - 1)) === 0 && r !== 0;
}
function W_(r) {
  return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2));
}
function X_(r) {
  return Math.pow(2, Math.floor(Math.log(r) / Math.LN2));
}
function Wx(r, e, t, n, i) {
  const s = Math.cos,
    a = Math.sin,
    o = s(t / 2),
    l = a(t / 2),
    c = s((e + n) / 2),
    u = a((e + n) / 2),
    h = s((e - n) / 2),
    f = a((e - n) / 2),
    p = s((n - e) / 2),
    g = a((n - e) / 2);
  switch (i) {
    case "XYX":
      r.set(o * u, l * h, l * f, o * c);
      break;
    case "YZY":
      r.set(l * f, o * u, l * h, o * c);
      break;
    case "ZXZ":
      r.set(l * h, l * f, o * u, o * c);
      break;
    case "XZX":
      r.set(o * u, l * g, l * p, o * c);
      break;
    case "YXY":
      r.set(l * p, o * u, l * g, o * c);
      break;
    case "ZYZ":
      r.set(l * g, l * p, o * u, o * c);
      break;
    default:
      console.warn(
        "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
          i
      );
  }
}
function Qi(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint16Array:
      return r / 65535;
    case Uint8Array:
      return r / 255;
    case Int16Array:
      return Math.max(r / 32767, -1);
    case Int8Array:
      return Math.max(r / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function dt(r, e) {
  switch (e.constructor) {
    case Float32Array:
      return r;
    case Uint16Array:
      return Math.round(r * 65535);
    case Uint8Array:
      return Math.round(r * 255);
    case Int16Array:
      return Math.round(r * 32767);
    case Int8Array:
      return Math.round(r * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
const Dc = {
  DEG2RAD: bo,
  RAD2DEG: Ba,
  generateUUID: gi,
  clamp: $t,
  euclideanModulo: wf,
  mapLinear: Dx,
  inverseLerp: Ix,
  lerp: To,
  damp: Nx,
  pingpong: Ox,
  smoothstep: Ux,
  smootherstep: Fx,
  randInt: Bx,
  randFloat: kx,
  randFloatSpread: zx,
  seededRandom: Hx,
  degToRad: Vx,
  radToDeg: Gx,
  isPowerOfTwo: Oh,
  ceilPowerOfTwo: W_,
  floorPowerOfTwo: X_,
  setQuaternionFromProperEuler: Wx,
  normalize: dt,
  denormalize: Qi,
};
class We {
  constructor(e = 0, t = 0) {
    (We.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      i = e.elements;
    return (
      (this.x = i[0] * t + i[3] * n + i[6]),
      (this.y = i[1] * t + i[4] * n + i[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(t, n))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos($t(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y;
    return t * t + n * n;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n), (this.y = e.y + (t.y - e.y) * n), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const n = Math.cos(t),
      i = Math.sin(t),
      s = this.x - e.x,
      a = this.y - e.y;
    return (this.x = s * n - a * i + e.x), (this.y = s * i + a * n + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class it {
  constructor() {
    (it.prototype.isMatrix3 = !0),
      (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]);
  }
  set(e, t, n, i, s, a, o, l, c) {
    const u = this.elements;
    return (
      (u[0] = e),
      (u[1] = i),
      (u[2] = o),
      (u[3] = t),
      (u[4] = s),
      (u[5] = l),
      (u[6] = n),
      (u[7] = a),
      (u[8] = c),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrix3Column(this, 0),
      t.setFromMatrix3Column(this, 1),
      n.setFromMatrix3Column(this, 2),
      this
    );
  }
  setFromMatrix4(e) {
    const t = e.elements;
    return (
      this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      i = t.elements,
      s = this.elements,
      a = n[0],
      o = n[3],
      l = n[6],
      c = n[1],
      u = n[4],
      h = n[7],
      f = n[2],
      p = n[5],
      g = n[8],
      m = i[0],
      _ = i[3],
      d = i[6],
      y = i[1],
      v = i[4],
      S = i[7],
      E = i[2],
      b = i[5],
      M = i[8];
    return (
      (s[0] = a * m + o * y + l * E),
      (s[3] = a * _ + o * v + l * b),
      (s[6] = a * d + o * S + l * M),
      (s[1] = c * m + u * y + h * E),
      (s[4] = c * _ + u * v + h * b),
      (s[7] = c * d + u * S + h * M),
      (s[2] = f * m + p * y + g * E),
      (s[5] = f * _ + p * v + g * b),
      (s[8] = f * d + p * S + g * M),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[3] *= e),
      (t[6] *= e),
      (t[1] *= e),
      (t[4] *= e),
      (t[7] *= e),
      (t[2] *= e),
      (t[5] *= e),
      (t[8] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      s = e[3],
      a = e[4],
      o = e[5],
      l = e[6],
      c = e[7],
      u = e[8];
    return (
      t * a * u - t * o * c - n * s * u + n * o * l + i * s * c - i * a * l
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      s = e[3],
      a = e[4],
      o = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      h = u * a - o * c,
      f = o * l - u * s,
      p = c * s - a * l,
      g = t * h + n * f + i * p;
    if (g === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const m = 1 / g;
    return (
      (e[0] = h * m),
      (e[1] = (i * c - u * n) * m),
      (e[2] = (o * n - i * a) * m),
      (e[3] = f * m),
      (e[4] = (u * t - i * l) * m),
      (e[5] = (i * s - o * t) * m),
      (e[6] = p * m),
      (e[7] = (n * l - c * t) * m),
      (e[8] = (a * t - n * s) * m),
      this
    );
  }
  transpose() {
    let e;
    const t = this.elements;
    return (
      (e = t[1]),
      (t[1] = t[3]),
      (t[3] = e),
      (e = t[2]),
      (t[2] = t[6]),
      (t[6] = e),
      (e = t[5]),
      (t[5] = t[7]),
      (t[7] = e),
      this
    );
  }
  getNormalMatrix(e) {
    return this.setFromMatrix4(e).invert().transpose();
  }
  transposeIntoArray(e) {
    const t = this.elements;
    return (
      (e[0] = t[0]),
      (e[1] = t[3]),
      (e[2] = t[6]),
      (e[3] = t[1]),
      (e[4] = t[4]),
      (e[5] = t[7]),
      (e[6] = t[2]),
      (e[7] = t[5]),
      (e[8] = t[8]),
      this
    );
  }
  setUvTransform(e, t, n, i, s, a, o) {
    const l = Math.cos(s),
      c = Math.sin(s);
    return (
      this.set(
        n * l,
        n * c,
        -n * (l * a + c * o) + a + e,
        -i * c,
        i * l,
        -i * (-c * a + l * o) + o + t,
        0,
        0,
        1
      ),
      this
    );
  }
  scale(e, t) {
    return this.premultiply(Ou.makeScale(e, t)), this;
  }
  rotate(e) {
    return this.premultiply(Ou.makeRotation(-e)), this;
  }
  translate(e, t) {
    return this.premultiply(Ou.makeTranslation(e, t)), this;
  }
  makeTranslation(e, t) {
    return this.set(1, 0, e, 0, 1, t, 0, 0, 1), this;
  }
  makeRotation(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
  }
  makeScale(e, t) {
    return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let i = 0; i < 9; i++) if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      e
    );
  }
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
}
const Ou = new it();
function Y_(r) {
  for (let e = r.length - 1; e >= 0; --e) if (r[e] >= 65535) return !0;
  return !1;
}
function Wo(r) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", r);
}
const dp = {};
function Ao(r) {
  r in dp || ((dp[r] = !0), console.warn(r));
}
function ba(r) {
  return r < 0.04045
    ? r * 0.0773993808
    : Math.pow(r * 0.9478672986 + 0.0521327014, 2.4);
}
function Uu(r) {
  return r < 0.0031308 ? r * 12.92 : 1.055 * Math.pow(r, 0.41666) - 0.055;
}
const Xx = new it().fromArray([
    0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058, 0.0723974, -1e-7,
    1e-7, 0.9105199,
  ]),
  Yx = new it().fromArray([
    1.2249401, -0.0420569, -0.0196376, -0.2249404, 1.0420571, -0.0786361, 1e-7,
    0, 1.0982735,
  ]);
function qx(r) {
  return r.convertSRGBToLinear().applyMatrix3(Yx);
}
function jx(r) {
  return r.applyMatrix3(Xx).convertLinearToSRGB();
}
const Kx = { [Ii]: (r) => r, [Ve]: (r) => r.convertSRGBToLinear(), [G_]: qx },
  $x = { [Ii]: (r) => r, [Ve]: (r) => r.convertLinearToSRGB(), [G_]: jx },
  li = {
    enabled: !0,
    get legacyMode() {
      return (
        console.warn(
          "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
        ),
        !this.enabled
      );
    },
    set legacyMode(r) {
      console.warn(
        "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
      ),
        (this.enabled = !r);
    },
    get workingColorSpace() {
      return Ii;
    },
    set workingColorSpace(r) {
      console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
    },
    convert: function (r, e, t) {
      if (this.enabled === !1 || e === t || !e || !t) return r;
      const n = Kx[e],
        i = $x[t];
      if (n === void 0 || i === void 0)
        throw new Error(
          `Unsupported color space conversion, "${e}" to "${t}".`
        );
      return i(n(r));
    },
    fromWorkingColorSpace: function (r, e) {
      return this.convert(r, this.workingColorSpace, e);
    },
    toWorkingColorSpace: function (r, e) {
      return this.convert(r, e, this.workingColorSpace);
    },
  };
let zs;
class q_ {
  static getDataURL(e) {
    if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      zs === void 0 && (zs = Wo("canvas")),
        (zs.width = e.width),
        (zs.height = e.height);
      const n = zs.getContext("2d");
      e instanceof ImageData
        ? n.putImageData(e, 0, 0)
        : n.drawImage(e, 0, 0, e.width, e.height),
        (t = zs);
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap < "u" && e instanceof ImageBitmap)
    ) {
      const t = Wo("canvas");
      (t.width = e.width), (t.height = e.height);
      const n = t.getContext("2d");
      n.drawImage(e, 0, 0, e.width, e.height);
      const i = n.getImageData(0, 0, e.width, e.height),
        s = i.data;
      for (let a = 0; a < s.length; a++) s[a] = ba(s[a] / 255) * 255;
      return n.putImageData(i, 0, 0), t;
    } else if (e.data) {
      const t = e.data.slice(0);
      for (let n = 0; n < t.length; n++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[n] = Math.floor(ba(t[n] / 255) * 255))
          : (t[n] = ba(t[n]));
      return { data: t, width: e.width, height: e.height };
    } else
      return (
        console.warn(
          "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
        ),
        e
      );
  }
}
class j_ {
  constructor(e = null) {
    (this.isSource = !0),
      (this.uuid = gi()),
      (this.data = e),
      (this.version = 0);
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
    const n = { uuid: this.uuid, url: "" },
      i = this.data;
    if (i !== null) {
      let s;
      if (Array.isArray(i)) {
        s = [];
        for (let a = 0, o = i.length; a < o; a++)
          i[a].isDataTexture ? s.push(Fu(i[a].image)) : s.push(Fu(i[a]));
      } else s = Fu(i);
      n.url = s;
    }
    return t || (e.images[this.uuid] = n), n;
  }
}
function Fu(r) {
  return (typeof HTMLImageElement < "u" && r instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap < "u" && r instanceof ImageBitmap)
    ? q_.getDataURL(r)
    : r.data
    ? {
        data: Array.from(r.data),
        width: r.width,
        height: r.height,
        type: r.data.constructor.name,
      }
    : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
}
let Zx = 0;
class Qt extends Ds {
  constructor(
    e = Qt.DEFAULT_IMAGE,
    t = Qt.DEFAULT_MAPPING,
    n = Jn,
    i = Jn,
    s = Sn,
    a = Ss,
    o = Qn,
    l = Ms,
    c = Qt.DEFAULT_ANISOTROPY,
    u = ds
  ) {
    super(),
      (this.isTexture = !0),
      Object.defineProperty(this, "id", { value: Zx++ }),
      (this.uuid = gi()),
      (this.name = ""),
      (this.source = new j_(e)),
      (this.mipmaps = []),
      (this.mapping = t),
      (this.channel = 0),
      (this.wrapS = n),
      (this.wrapT = i),
      (this.magFilter = s),
      (this.minFilter = a),
      (this.anisotropy = c),
      (this.format = o),
      (this.internalFormat = null),
      (this.type = l),
      (this.offset = new We(0, 0)),
      (this.repeat = new We(1, 1)),
      (this.center = new We(0, 0)),
      (this.rotation = 0),
      (this.matrixAutoUpdate = !0),
      (this.matrix = new it()),
      (this.generateMipmaps = !0),
      (this.premultiplyAlpha = !1),
      (this.flipY = !0),
      (this.unpackAlignment = 4),
      typeof u == "string"
        ? (this.colorSpace = u)
        : (Ao(
            "THREE.Texture: Property .encoding has been replaced by .colorSpace."
          ),
          (this.colorSpace = u === fs ? Ve : ds)),
      (this.userData = {}),
      (this.version = 0),
      (this.onUpdate = null),
      (this.isRenderTargetTexture = !1),
      (this.needsPMREMUpdate = !1);
  }
  get image() {
    return this.source.data;
  }
  set image(e = null) {
    this.source.data = e;
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.source = e.source),
      (this.mipmaps = e.mipmaps.slice(0)),
      (this.mapping = e.mapping),
      (this.channel = e.channel),
      (this.wrapS = e.wrapS),
      (this.wrapT = e.wrapT),
      (this.magFilter = e.magFilter),
      (this.minFilter = e.minFilter),
      (this.anisotropy = e.anisotropy),
      (this.format = e.format),
      (this.internalFormat = e.internalFormat),
      (this.type = e.type),
      this.offset.copy(e.offset),
      this.repeat.copy(e.repeat),
      this.center.copy(e.center),
      (this.rotation = e.rotation),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this.matrix.copy(e.matrix),
      (this.generateMipmaps = e.generateMipmaps),
      (this.premultiplyAlpha = e.premultiplyAlpha),
      (this.flipY = e.flipY),
      (this.unpackAlignment = e.unpackAlignment),
      (this.colorSpace = e.colorSpace),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      (this.needsUpdate = !0),
      this
    );
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
    const n = {
      metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(e).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    };
    return (
      Object.keys(this.userData).length > 0 && (n.userData = this.userData),
      t || (e.textures[this.uuid] = n),
      n
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  transformUv(e) {
    if (this.mapping !== F_) return e;
    if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
      switch (this.wrapS) {
        case Oa:
          e.x = e.x - Math.floor(e.x);
          break;
        case Jn:
          e.x = e.x < 0 ? 0 : 1;
          break;
        case Lc:
          Math.abs(Math.floor(e.x) % 2) === 1
            ? (e.x = Math.ceil(e.x) - e.x)
            : (e.x = e.x - Math.floor(e.x));
          break;
      }
    if (e.y < 0 || e.y > 1)
      switch (this.wrapT) {
        case Oa:
          e.y = e.y - Math.floor(e.y);
          break;
        case Jn:
          e.y = e.y < 0 ? 0 : 1;
          break;
        case Lc:
          Math.abs(Math.floor(e.y) % 2) === 1
            ? (e.y = Math.ceil(e.y) - e.y)
            : (e.y = e.y - Math.floor(e.y));
          break;
      }
    return this.flipY && (e.y = 1 - e.y), e;
  }
  set needsUpdate(e) {
    e === !0 && (this.version++, (this.source.needsUpdate = !0));
  }
  get encoding() {
    return (
      Ao("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
      this.colorSpace === Ve ? fs : H_
    );
  }
  set encoding(e) {
    Ao("THREE.Texture: Property .encoding has been replaced by .colorSpace."),
      (this.colorSpace = e === fs ? Ve : ds);
  }
}
Qt.DEFAULT_IMAGE = null;
Qt.DEFAULT_MAPPING = F_;
Qt.DEFAULT_ANISOTROPY = 1;
class mt {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    (mt.prototype.isVector4 = !0),
      (this.x = e),
      (this.y = t),
      (this.z = n),
      (this.w = i);
  }
  get width() {
    return this.z;
  }
  set width(e) {
    this.z = e;
  }
  get height() {
    return this.w;
  }
  set height(e) {
    this.w = e;
  }
  set(e, t, n, i) {
    return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setW(e) {
    return (this.w = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      case 3:
        this.w = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copy(e) {
    return (
      (this.x = e.x),
      (this.y = e.y),
      (this.z = e.z),
      (this.w = e.w !== void 0 ? e.w : 1),
      this
    );
  }
  add(e) {
    return (
      (this.x += e.x), (this.y += e.y), (this.z += e.z), (this.w += e.w), this
    );
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), (this.w += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x),
      (this.y = e.y + t.y),
      (this.z = e.z + t.z),
      (this.w = e.w + t.w),
      this
    );
  }
  addScaledVector(e, t) {
    return (
      (this.x += e.x * t),
      (this.y += e.y * t),
      (this.z += e.z * t),
      (this.w += e.w * t),
      this
    );
  }
  sub(e) {
    return (
      (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), (this.w -= e.w), this
    );
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x),
      (this.y = e.y - t.y),
      (this.z = e.z - t.z),
      (this.w = e.w - t.w),
      this
    );
  }
  multiply(e) {
    return (
      (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), (this.w *= e.w), this
    );
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this;
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      s = this.w,
      a = e.elements;
    return (
      (this.x = a[0] * t + a[4] * n + a[8] * i + a[12] * s),
      (this.y = a[1] * t + a[5] * n + a[9] * i + a[13] * s),
      (this.z = a[2] * t + a[6] * n + a[10] * i + a[14] * s),
      (this.w = a[3] * t + a[7] * n + a[11] * i + a[15] * s),
      this
    );
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  setAxisAngleFromQuaternion(e) {
    this.w = 2 * Math.acos(e.w);
    const t = Math.sqrt(1 - e.w * e.w);
    return (
      t < 1e-4
        ? ((this.x = 1), (this.y = 0), (this.z = 0))
        : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
      this
    );
  }
  setAxisAngleFromRotationMatrix(e) {
    let t, n, i, s;
    const l = e.elements,
      c = l[0],
      u = l[4],
      h = l[8],
      f = l[1],
      p = l[5],
      g = l[9],
      m = l[2],
      _ = l[6],
      d = l[10];
    if (
      Math.abs(u - f) < 0.01 &&
      Math.abs(h - m) < 0.01 &&
      Math.abs(g - _) < 0.01
    ) {
      if (
        Math.abs(u + f) < 0.1 &&
        Math.abs(h + m) < 0.1 &&
        Math.abs(g + _) < 0.1 &&
        Math.abs(c + p + d - 3) < 0.1
      )
        return this.set(1, 0, 0, 0), this;
      t = Math.PI;
      const v = (c + 1) / 2,
        S = (p + 1) / 2,
        E = (d + 1) / 2,
        b = (u + f) / 4,
        M = (h + m) / 4,
        C = (g + _) / 4;
      return (
        v > S && v > E
          ? v < 0.01
            ? ((n = 0), (i = 0.707106781), (s = 0.707106781))
            : ((n = Math.sqrt(v)), (i = b / n), (s = M / n))
          : S > E
          ? S < 0.01
            ? ((n = 0.707106781), (i = 0), (s = 0.707106781))
            : ((i = Math.sqrt(S)), (n = b / i), (s = C / i))
          : E < 0.01
          ? ((n = 0.707106781), (i = 0.707106781), (s = 0))
          : ((s = Math.sqrt(E)), (n = M / s), (i = C / s)),
        this.set(n, i, s, t),
        this
      );
    }
    let y = Math.sqrt(
      (_ - g) * (_ - g) + (h - m) * (h - m) + (f - u) * (f - u)
    );
    return (
      Math.abs(y) < 0.001 && (y = 1),
      (this.x = (_ - g) / y),
      (this.y = (h - m) / y),
      (this.z = (f - u) / y),
      (this.w = Math.acos((c + p + d - 1) / 2)),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      (this.w = Math.min(this.w, e.w)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      (this.w = Math.max(this.w, e.w)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      (this.w = Math.max(e.w, Math.min(t.w, this.w))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      (this.w = Math.max(e, Math.min(t, this.w))),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(t, n))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      (this.w = Math.floor(this.w)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      (this.w = Math.ceil(this.w)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      (this.w = Math.round(this.w)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      (this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)),
      this
    );
  }
  negate() {
    return (
      (this.x = -this.x),
      (this.y = -this.y),
      (this.z = -this.z),
      (this.w = -this.w),
      this
    );
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
  }
  lengthSq() {
    return (
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    );
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    );
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      (this.w += (e.w - this.w) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      (this.w = e.w + (t.w - e.w) * n),
      this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w;
  }
  fromArray(e, t = 0) {
    return (
      (this.x = e[t]),
      (this.y = e[t + 1]),
      (this.z = e[t + 2]),
      (this.w = e[t + 3]),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this.x),
      (e[t + 1] = this.y),
      (e[t + 2] = this.z),
      (e[t + 3] = this.w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)),
      (this.y = e.getY(t)),
      (this.z = e.getZ(t)),
      (this.w = e.getW(t)),
      this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      (this.w = Math.random()),
      this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z, yield this.w;
  }
}
class bs extends Ds {
  constructor(e = 1, t = 1, n = {}) {
    super(),
      (this.isWebGLRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new mt(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new mt(0, 0, e, t));
    const i = { width: e, height: t, depth: 1 };
    n.encoding !== void 0 &&
      (Ao(
        "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (n.colorSpace = n.encoding === fs ? Ve : ds)),
      (this.texture = new Qt(
        i,
        n.mapping,
        n.wrapS,
        n.wrapT,
        n.magFilter,
        n.minFilter,
        n.format,
        n.type,
        n.anisotropy,
        n.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.flipY = !1),
      (this.texture.generateMipmaps =
        n.generateMipmaps !== void 0 ? n.generateMipmaps : !1),
      (this.texture.internalFormat =
        n.internalFormat !== void 0 ? n.internalFormat : null),
      (this.texture.minFilter = n.minFilter !== void 0 ? n.minFilter : Sn),
      (this.depthBuffer = n.depthBuffer !== void 0 ? n.depthBuffer : !0),
      (this.stencilBuffer = n.stencilBuffer !== void 0 ? n.stencilBuffer : !1),
      (this.depthTexture = n.depthTexture !== void 0 ? n.depthTexture : null),
      (this.samples = n.samples !== void 0 ? n.samples : 0);
  }
  setSize(e, t, n = 1) {
    (this.width !== e || this.height !== t || this.depth !== n) &&
      ((this.width = e),
      (this.height = t),
      (this.depth = n),
      (this.texture.image.width = e),
      (this.texture.image.height = t),
      (this.texture.image.depth = n),
      this.dispose()),
      this.viewport.set(0, 0, e, t),
      this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.texture = e.texture.clone()),
      (this.texture.isRenderTargetTexture = !0);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new j_(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class K_ extends Qt {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: n, depth: i }),
      (this.magFilter = qt),
      (this.minFilter = qt),
      (this.wrapR = Jn),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class Jx extends Qt {
  constructor(e = null, t = 1, n = 1, i = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: n, depth: i }),
      (this.magFilter = qt),
      (this.minFilter = qt),
      (this.wrapR = Jn),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class Ni {
  constructor(e = 0, t = 0, n = 0, i = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._w = i);
  }
  static slerpFlat(e, t, n, i, s, a, o) {
    let l = n[i + 0],
      c = n[i + 1],
      u = n[i + 2],
      h = n[i + 3];
    const f = s[a + 0],
      p = s[a + 1],
      g = s[a + 2],
      m = s[a + 3];
    if (o === 0) {
      (e[t + 0] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = h);
      return;
    }
    if (o === 1) {
      (e[t + 0] = f), (e[t + 1] = p), (e[t + 2] = g), (e[t + 3] = m);
      return;
    }
    if (h !== m || l !== f || c !== p || u !== g) {
      let _ = 1 - o;
      const d = l * f + c * p + u * g + h * m,
        y = d >= 0 ? 1 : -1,
        v = 1 - d * d;
      if (v > Number.EPSILON) {
        const E = Math.sqrt(v),
          b = Math.atan2(E, d * y);
        (_ = Math.sin(_ * b) / E), (o = Math.sin(o * b) / E);
      }
      const S = o * y;
      if (
        ((l = l * _ + f * S),
        (c = c * _ + p * S),
        (u = u * _ + g * S),
        (h = h * _ + m * S),
        _ === 1 - o)
      ) {
        const E = 1 / Math.sqrt(l * l + c * c + u * u + h * h);
        (l *= E), (c *= E), (u *= E), (h *= E);
      }
    }
    (e[t] = l), (e[t + 1] = c), (e[t + 2] = u), (e[t + 3] = h);
  }
  static multiplyQuaternionsFlat(e, t, n, i, s, a) {
    const o = n[i],
      l = n[i + 1],
      c = n[i + 2],
      u = n[i + 3],
      h = s[a],
      f = s[a + 1],
      p = s[a + 2],
      g = s[a + 3];
    return (
      (e[t] = o * g + u * h + l * p - c * f),
      (e[t + 1] = l * g + u * f + c * h - o * p),
      (e[t + 2] = c * g + u * p + o * f - l * h),
      (e[t + 3] = u * g - o * h - l * f - c * p),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, n, i) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._w = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t) {
    const n = e._x,
      i = e._y,
      s = e._z,
      a = e._order,
      o = Math.cos,
      l = Math.sin,
      c = o(n / 2),
      u = o(i / 2),
      h = o(s / 2),
      f = l(n / 2),
      p = l(i / 2),
      g = l(s / 2);
    switch (a) {
      case "XYZ":
        (this._x = f * u * h + c * p * g),
          (this._y = c * p * h - f * u * g),
          (this._z = c * u * g + f * p * h),
          (this._w = c * u * h - f * p * g);
        break;
      case "YXZ":
        (this._x = f * u * h + c * p * g),
          (this._y = c * p * h - f * u * g),
          (this._z = c * u * g - f * p * h),
          (this._w = c * u * h + f * p * g);
        break;
      case "ZXY":
        (this._x = f * u * h - c * p * g),
          (this._y = c * p * h + f * u * g),
          (this._z = c * u * g + f * p * h),
          (this._w = c * u * h - f * p * g);
        break;
      case "ZYX":
        (this._x = f * u * h - c * p * g),
          (this._y = c * p * h + f * u * g),
          (this._z = c * u * g - f * p * h),
          (this._w = c * u * h + f * p * g);
        break;
      case "YZX":
        (this._x = f * u * h + c * p * g),
          (this._y = c * p * h + f * u * g),
          (this._z = c * u * g - f * p * h),
          (this._w = c * u * h - f * p * g);
        break;
      case "XZY":
        (this._x = f * u * h - c * p * g),
          (this._y = c * p * h - f * u * g),
          (this._z = c * u * g + f * p * h),
          (this._w = c * u * h + f * p * g);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a
        );
    }
    return t !== !1 && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const n = t / 2,
      i = Math.sin(n);
    return (
      (this._x = e.x * i),
      (this._y = e.y * i),
      (this._z = e.z * i),
      (this._w = Math.cos(n)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      n = t[0],
      i = t[4],
      s = t[8],
      a = t[1],
      o = t[5],
      l = t[9],
      c = t[2],
      u = t[6],
      h = t[10],
      f = n + o + h;
    if (f > 0) {
      const p = 0.5 / Math.sqrt(f + 1);
      (this._w = 0.25 / p),
        (this._x = (u - l) * p),
        (this._y = (s - c) * p),
        (this._z = (a - i) * p);
    } else if (n > o && n > h) {
      const p = 2 * Math.sqrt(1 + n - o - h);
      (this._w = (u - l) / p),
        (this._x = 0.25 * p),
        (this._y = (i + a) / p),
        (this._z = (s + c) / p);
    } else if (o > h) {
      const p = 2 * Math.sqrt(1 + o - n - h);
      (this._w = (s - c) / p),
        (this._x = (i + a) / p),
        (this._y = 0.25 * p),
        (this._z = (l + u) / p);
    } else {
      const p = 2 * Math.sqrt(1 + h - n - o);
      (this._w = (a - i) / p),
        (this._x = (s + c) / p),
        (this._y = (l + u) / p),
        (this._z = 0.25 * p);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let n = e.dot(t) + 1;
    return (
      n < Number.EPSILON
        ? ((n = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = n))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = n)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = n)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs($t(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const n = this.angleTo(e);
    if (n === 0) return this;
    const i = Math.min(1, t / n);
    return this.slerp(e, i), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      e === 0
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const n = e._x,
      i = e._y,
      s = e._z,
      a = e._w,
      o = t._x,
      l = t._y,
      c = t._z,
      u = t._w;
    return (
      (this._x = n * u + a * o + i * c - s * l),
      (this._y = i * u + a * l + s * o - n * c),
      (this._z = s * u + a * c + n * l - i * o),
      (this._w = a * u - n * o - i * l - s * c),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (t === 0) return this;
    if (t === 1) return this.copy(e);
    const n = this._x,
      i = this._y,
      s = this._z,
      a = this._w;
    let o = a * e._w + n * e._x + i * e._y + s * e._z;
    if (
      (o < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (o = -o))
        : this.copy(e),
      o >= 1)
    )
      return (this._w = a), (this._x = n), (this._y = i), (this._z = s), this;
    const l = 1 - o * o;
    if (l <= Number.EPSILON) {
      const p = 1 - t;
      return (
        (this._w = p * a + t * this._w),
        (this._x = p * n + t * this._x),
        (this._y = p * i + t * this._y),
        (this._z = p * s + t * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const c = Math.sqrt(l),
      u = Math.atan2(c, o),
      h = Math.sin((1 - t) * u) / c,
      f = Math.sin(t * u) / c;
    return (
      (this._w = a * h + this._w * f),
      (this._x = n * h + this._x * f),
      (this._y = i * h + this._y * f),
      (this._z = s * h + this._z * f),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, n) {
    return this.copy(e).slerp(t, n);
  }
  random() {
    const e = Math.random(),
      t = Math.sqrt(1 - e),
      n = Math.sqrt(e),
      i = 2 * Math.PI * Math.random(),
      s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(i),
      n * Math.sin(s),
      n * Math.cos(s),
      t * Math.sin(i)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class H {
  constructor(e = 0, t = 0, n = 0) {
    (H.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = n);
  }
  set(e, t, n) {
    return (
      n === void 0 && (n = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = n),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(pp.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(pp.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[3] * n + s[6] * i),
      (this.y = s[1] * t + s[4] * n + s[7] * i),
      (this.z = s[2] * t + s[5] * n + s[8] * i),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      s = e.elements,
      a = 1 / (s[3] * t + s[7] * n + s[11] * i + s[15]);
    return (
      (this.x = (s[0] * t + s[4] * n + s[8] * i + s[12]) * a),
      (this.y = (s[1] * t + s[5] * n + s[9] * i + s[13]) * a),
      (this.z = (s[2] * t + s[6] * n + s[10] * i + s[14]) * a),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      s = e.x,
      a = e.y,
      o = e.z,
      l = e.w,
      c = l * t + a * i - o * n,
      u = l * n + o * t - s * i,
      h = l * i + s * n - a * t,
      f = -s * t - a * n - o * i;
    return (
      (this.x = c * l + f * -s + u * -o - h * -a),
      (this.y = u * l + f * -a + h * -s - c * -o),
      (this.z = h * l + f * -o + c * -a - u * -s),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      n = this.y,
      i = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * n + s[8] * i),
      (this.y = s[1] * t + s[5] * n + s[9] * i),
      (this.z = s[2] * t + s[6] * n + s[10] * i),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    const n = this.length();
    return this.divideScalar(n || 1).multiplyScalar(
      Math.max(e, Math.min(t, n))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)),
      (this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)),
      (this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, n) {
    return (
      (this.x = e.x + (t.x - e.x) * n),
      (this.y = e.y + (t.y - e.y) * n),
      (this.z = e.z + (t.z - e.z) * n),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const n = e.x,
      i = e.y,
      s = e.z,
      a = t.x,
      o = t.y,
      l = t.z;
    return (
      (this.x = i * l - s * o),
      (this.y = s * a - n * l),
      (this.z = n * o - i * a),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (t === 0) return this.set(0, 0, 0);
    const n = e.dot(this) / t;
    return this.copy(e).multiplyScalar(n);
  }
  projectOnPlane(e) {
    return Bu.copy(this).projectOnVector(e), this.sub(Bu);
  }
  reflect(e) {
    return this.sub(Bu.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (t === 0) return Math.PI / 2;
    const n = this.dot(e) / t;
    return Math.acos($t(n, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      n = this.y - e.y,
      i = this.z - e.z;
    return t * t + n * n + i * i;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, n) {
    const i = Math.sin(t) * e;
    return (
      (this.x = i * Math.sin(n)),
      (this.y = Math.cos(t) * e),
      (this.z = i * Math.cos(n)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, n) {
    return (
      (this.x = e * Math.sin(t)), (this.y = n), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      n = this.setFromMatrixColumn(e, 1).length(),
      i = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = n), (this.z = i), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, t * 4);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, t * 3);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = (Math.random() - 0.5) * 2,
      t = Math.random() * Math.PI * 2,
      n = Math.sqrt(1 - e ** 2);
    return (
      (this.x = n * Math.cos(t)), (this.y = n * Math.sin(t)), (this.z = e), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const Bu = new H(),
  pp = new Ni();
class hr {
  constructor(
    e = new H(1 / 0, 1 / 0, 1 / 0),
    t = new H(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t += 3)
      this.expandByPoint(Vi.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, n = e.count; t < n; t++)
      this.expandByPoint(Vi.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const n = Vi.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    if ((e.updateWorldMatrix(!1, !1), e.boundingBox !== void 0))
      e.boundingBox === null && e.computeBoundingBox(),
        Hs.copy(e.boundingBox),
        Hs.applyMatrix4(e.matrixWorld),
        this.union(Hs);
    else {
      const i = e.geometry;
      if (i !== void 0)
        if (t && i.attributes !== void 0 && i.attributes.position !== void 0) {
          const s = i.attributes.position;
          for (let a = 0, o = s.count; a < o; a++)
            Vi.fromBufferAttribute(s, a).applyMatrix4(e.matrixWorld),
              this.expandByPoint(Vi);
        } else
          i.boundingBox === null && i.computeBoundingBox(),
            Hs.copy(i.boundingBox),
            Hs.applyMatrix4(e.matrixWorld),
            this.union(Hs);
    }
    const n = e.children;
    for (let i = 0, s = n.length; i < s; i++) this.expandByObject(n[i], t);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, Vi),
      Vi.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, n;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (n += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (n += e.normal.z * this.min.z)),
      t <= -e.constant && n >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(no),
      wl.subVectors(this.max, no),
      Vs.subVectors(e.a, no),
      Gs.subVectors(e.b, no),
      Ws.subVectors(e.c, no),
      dr.subVectors(Gs, Vs),
      pr.subVectors(Ws, Gs),
      Kr.subVectors(Vs, Ws);
    let t = [
      0,
      -dr.z,
      dr.y,
      0,
      -pr.z,
      pr.y,
      0,
      -Kr.z,
      Kr.y,
      dr.z,
      0,
      -dr.x,
      pr.z,
      0,
      -pr.x,
      Kr.z,
      0,
      -Kr.x,
      -dr.y,
      dr.x,
      0,
      -pr.y,
      pr.x,
      0,
      -Kr.y,
      Kr.x,
      0,
    ];
    return !ku(t, Vs, Gs, Ws, wl) ||
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]), !ku(t, Vs, Gs, Ws, wl))
      ? !1
      : (Rl.crossVectors(dr, pr),
        (t = [Rl.x, Rl.y, Rl.z]),
        ku(t, Vs, Gs, Ws, wl));
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, Vi).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = this.getSize(Vi).length() * 0.5)),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return this.isEmpty()
      ? this
      : (Hi[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        Hi[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        Hi[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        Hi[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        Hi[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        Hi[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        Hi[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        Hi[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(Hi),
        this);
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const Hi = [
    new H(),
    new H(),
    new H(),
    new H(),
    new H(),
    new H(),
    new H(),
    new H(),
  ],
  Vi = new H(),
  Hs = new hr(),
  Vs = new H(),
  Gs = new H(),
  Ws = new H(),
  dr = new H(),
  pr = new H(),
  Kr = new H(),
  no = new H(),
  wl = new H(),
  Rl = new H(),
  $r = new H();
function ku(r, e, t, n, i) {
  for (let s = 0, a = r.length - 3; s <= a; s += 3) {
    $r.fromArray(r, s);
    const o =
        i.x * Math.abs($r.x) + i.y * Math.abs($r.y) + i.z * Math.abs($r.z),
      l = e.dot($r),
      c = t.dot($r),
      u = n.dot($r);
    if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > o) return !1;
  }
  return !0;
}
const Qx = new hr(),
  io = new H(),
  zu = new H();
class fr {
  constructor(e = new H(), t = -1) {
    (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const n = this.center;
    t !== void 0 ? n.copy(t) : Qx.setFromPoints(e).getCenter(n);
    let i = 0;
    for (let s = 0, a = e.length; s < a; s++)
      i = Math.max(i, n.distanceToSquared(e[s]));
    return (this.radius = Math.sqrt(i)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const n = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      n > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    io.subVectors(e, this.center);
    const t = io.lengthSq();
    if (t > this.radius * this.radius) {
      const n = Math.sqrt(t),
        i = (n - this.radius) * 0.5;
      this.center.addScaledVector(io, i / n), (this.radius += i);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (this.center.equals(e.center) === !0
          ? (this.radius = Math.max(this.radius, e.radius))
          : (zu.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(io.copy(e.center).add(zu)),
            this.expandByPoint(io.copy(e.center).sub(zu))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Gi = new H(),
  Hu = new H(),
  Cl = new H(),
  mr = new H(),
  Vu = new H(),
  Pl = new H(),
  Gu = new H();
class au {
  constructor(e = new H(), t = new H(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Gi)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const n = t.dot(this.direction);
    return n < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, n);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Gi.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (Gi.copy(this.origin).addScaledVector(this.direction, t),
        Gi.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, n, i) {
    Hu.copy(e).add(t).multiplyScalar(0.5),
      Cl.copy(t).sub(e).normalize(),
      mr.copy(this.origin).sub(Hu);
    const s = e.distanceTo(t) * 0.5,
      a = -this.direction.dot(Cl),
      o = mr.dot(this.direction),
      l = -mr.dot(Cl),
      c = mr.lengthSq(),
      u = Math.abs(1 - a * a);
    let h, f, p, g;
    if (u > 0)
      if (((h = a * l - o), (f = a * o - l), (g = s * u), h >= 0))
        if (f >= -g)
          if (f <= g) {
            const m = 1 / u;
            (h *= m),
              (f *= m),
              (p = h * (h + a * f + 2 * o) + f * (a * h + f + 2 * l) + c);
          } else
            (f = s),
              (h = Math.max(0, -(a * f + o))),
              (p = -h * h + f * (f + 2 * l) + c);
        else
          (f = -s),
            (h = Math.max(0, -(a * f + o))),
            (p = -h * h + f * (f + 2 * l) + c);
      else
        f <= -g
          ? ((h = Math.max(0, -(-a * s + o))),
            (f = h > 0 ? -s : Math.min(Math.max(-s, -l), s)),
            (p = -h * h + f * (f + 2 * l) + c))
          : f <= g
          ? ((h = 0),
            (f = Math.min(Math.max(-s, -l), s)),
            (p = f * (f + 2 * l) + c))
          : ((h = Math.max(0, -(a * s + o))),
            (f = h > 0 ? s : Math.min(Math.max(-s, -l), s)),
            (p = -h * h + f * (f + 2 * l) + c));
    else
      (f = a > 0 ? -s : s),
        (h = Math.max(0, -(a * f + o))),
        (p = -h * h + f * (f + 2 * l) + c);
    return (
      n && n.copy(this.origin).addScaledVector(this.direction, h),
      i && i.copy(Hu).addScaledVector(Cl, f),
      p
    );
  }
  intersectSphere(e, t) {
    Gi.subVectors(e.center, this.origin);
    const n = Gi.dot(this.direction),
      i = Gi.dot(Gi) - n * n,
      s = e.radius * e.radius;
    if (i > s) return null;
    const a = Math.sqrt(s - i),
      o = n - a,
      l = n + a;
    return l < 0 ? null : o < 0 ? this.at(l, t) : this.at(o, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
    const n = -(this.origin.dot(e.normal) + e.constant) / t;
    return n >= 0 ? n : null;
  }
  intersectPlane(e, t) {
    const n = this.distanceToPlane(e);
    return n === null ? null : this.at(n, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    return t === 0 || e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let n, i, s, a, o, l;
    const c = 1 / this.direction.x,
      u = 1 / this.direction.y,
      h = 1 / this.direction.z,
      f = this.origin;
    return (
      c >= 0
        ? ((n = (e.min.x - f.x) * c), (i = (e.max.x - f.x) * c))
        : ((n = (e.max.x - f.x) * c), (i = (e.min.x - f.x) * c)),
      u >= 0
        ? ((s = (e.min.y - f.y) * u), (a = (e.max.y - f.y) * u))
        : ((s = (e.max.y - f.y) * u), (a = (e.min.y - f.y) * u)),
      n > a ||
      s > i ||
      ((s > n || isNaN(n)) && (n = s),
      (a < i || isNaN(i)) && (i = a),
      h >= 0
        ? ((o = (e.min.z - f.z) * h), (l = (e.max.z - f.z) * h))
        : ((o = (e.max.z - f.z) * h), (l = (e.min.z - f.z) * h)),
      n > l || o > i) ||
      ((o > n || n !== n) && (n = o), (l < i || i !== i) && (i = l), i < 0)
        ? null
        : this.at(n >= 0 ? n : i, t)
    );
  }
  intersectsBox(e) {
    return this.intersectBox(e, Gi) !== null;
  }
  intersectTriangle(e, t, n, i, s) {
    Vu.subVectors(t, e), Pl.subVectors(n, e), Gu.crossVectors(Vu, Pl);
    let a = this.direction.dot(Gu),
      o;
    if (a > 0) {
      if (i) return null;
      o = 1;
    } else if (a < 0) (o = -1), (a = -a);
    else return null;
    mr.subVectors(this.origin, e);
    const l = o * this.direction.dot(Pl.crossVectors(mr, Pl));
    if (l < 0) return null;
    const c = o * this.direction.dot(Vu.cross(mr));
    if (c < 0 || l + c > a) return null;
    const u = -o * mr.dot(Gu);
    return u < 0 ? null : this.at(u / a, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class et {
  constructor() {
    (et.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  }
  set(e, t, n, i, s, a, o, l, c, u, h, f, p, g, m, _) {
    const d = this.elements;
    return (
      (d[0] = e),
      (d[4] = t),
      (d[8] = n),
      (d[12] = i),
      (d[1] = s),
      (d[5] = a),
      (d[9] = o),
      (d[13] = l),
      (d[2] = c),
      (d[6] = u),
      (d[10] = h),
      (d[14] = f),
      (d[3] = p),
      (d[7] = g),
      (d[11] = m),
      (d[15] = _),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new et().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      n = e.elements;
    return (
      (t[0] = n[0]),
      (t[1] = n[1]),
      (t[2] = n[2]),
      (t[3] = n[3]),
      (t[4] = n[4]),
      (t[5] = n[5]),
      (t[6] = n[6]),
      (t[7] = n[7]),
      (t[8] = n[8]),
      (t[9] = n[9]),
      (t[10] = n[10]),
      (t[11] = n[11]),
      (t[12] = n[12]),
      (t[13] = n[13]),
      (t[14] = n[14]),
      (t[15] = n[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      n = e.elements;
    return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, n) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      n.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, n) {
    return (
      this.set(
        e.x,
        t.x,
        n.x,
        0,
        e.y,
        t.y,
        n.y,
        0,
        e.z,
        t.z,
        n.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      n = e.elements,
      i = 1 / Xs.setFromMatrixColumn(e, 0).length(),
      s = 1 / Xs.setFromMatrixColumn(e, 1).length(),
      a = 1 / Xs.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = n[0] * i),
      (t[1] = n[1] * i),
      (t[2] = n[2] * i),
      (t[3] = 0),
      (t[4] = n[4] * s),
      (t[5] = n[5] * s),
      (t[6] = n[6] * s),
      (t[7] = 0),
      (t[8] = n[8] * a),
      (t[9] = n[9] * a),
      (t[10] = n[10] * a),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      n = e.x,
      i = e.y,
      s = e.z,
      a = Math.cos(n),
      o = Math.sin(n),
      l = Math.cos(i),
      c = Math.sin(i),
      u = Math.cos(s),
      h = Math.sin(s);
    if (e.order === "XYZ") {
      const f = a * u,
        p = a * h,
        g = o * u,
        m = o * h;
      (t[0] = l * u),
        (t[4] = -l * h),
        (t[8] = c),
        (t[1] = p + g * c),
        (t[5] = f - m * c),
        (t[9] = -o * l),
        (t[2] = m - f * c),
        (t[6] = g + p * c),
        (t[10] = a * l);
    } else if (e.order === "YXZ") {
      const f = l * u,
        p = l * h,
        g = c * u,
        m = c * h;
      (t[0] = f + m * o),
        (t[4] = g * o - p),
        (t[8] = a * c),
        (t[1] = a * h),
        (t[5] = a * u),
        (t[9] = -o),
        (t[2] = p * o - g),
        (t[6] = m + f * o),
        (t[10] = a * l);
    } else if (e.order === "ZXY") {
      const f = l * u,
        p = l * h,
        g = c * u,
        m = c * h;
      (t[0] = f - m * o),
        (t[4] = -a * h),
        (t[8] = g + p * o),
        (t[1] = p + g * o),
        (t[5] = a * u),
        (t[9] = m - f * o),
        (t[2] = -a * c),
        (t[6] = o),
        (t[10] = a * l);
    } else if (e.order === "ZYX") {
      const f = a * u,
        p = a * h,
        g = o * u,
        m = o * h;
      (t[0] = l * u),
        (t[4] = g * c - p),
        (t[8] = f * c + m),
        (t[1] = l * h),
        (t[5] = m * c + f),
        (t[9] = p * c - g),
        (t[2] = -c),
        (t[6] = o * l),
        (t[10] = a * l);
    } else if (e.order === "YZX") {
      const f = a * l,
        p = a * c,
        g = o * l,
        m = o * c;
      (t[0] = l * u),
        (t[4] = m - f * h),
        (t[8] = g * h + p),
        (t[1] = h),
        (t[5] = a * u),
        (t[9] = -o * u),
        (t[2] = -c * u),
        (t[6] = p * h + g),
        (t[10] = f - m * h);
    } else if (e.order === "XZY") {
      const f = a * l,
        p = a * c,
        g = o * l,
        m = o * c;
      (t[0] = l * u),
        (t[4] = -h),
        (t[8] = c * u),
        (t[1] = f * h + m),
        (t[5] = a * u),
        (t[9] = p * h - g),
        (t[2] = g * h - p),
        (t[6] = o * u),
        (t[10] = m * h + f);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(ey, e, ty);
  }
  lookAt(e, t, n) {
    const i = this.elements;
    return (
      Nn.subVectors(e, t),
      Nn.lengthSq() === 0 && (Nn.z = 1),
      Nn.normalize(),
      _r.crossVectors(n, Nn),
      _r.lengthSq() === 0 &&
        (Math.abs(n.z) === 1 ? (Nn.x += 1e-4) : (Nn.z += 1e-4),
        Nn.normalize(),
        _r.crossVectors(n, Nn)),
      _r.normalize(),
      Ll.crossVectors(Nn, _r),
      (i[0] = _r.x),
      (i[4] = Ll.x),
      (i[8] = Nn.x),
      (i[1] = _r.y),
      (i[5] = Ll.y),
      (i[9] = Nn.y),
      (i[2] = _r.z),
      (i[6] = Ll.z),
      (i[10] = Nn.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const n = e.elements,
      i = t.elements,
      s = this.elements,
      a = n[0],
      o = n[4],
      l = n[8],
      c = n[12],
      u = n[1],
      h = n[5],
      f = n[9],
      p = n[13],
      g = n[2],
      m = n[6],
      _ = n[10],
      d = n[14],
      y = n[3],
      v = n[7],
      S = n[11],
      E = n[15],
      b = i[0],
      M = i[4],
      C = i[8],
      x = i[12],
      T = i[1],
      D = i[5],
      N = i[9],
      L = i[13],
      F = i[2],
      I = i[6],
      j = i[10],
      A = i[14],
      k = i[3],
      G = i[7],
      z = i[11],
      oe = i[15];
    return (
      (s[0] = a * b + o * T + l * F + c * k),
      (s[4] = a * M + o * D + l * I + c * G),
      (s[8] = a * C + o * N + l * j + c * z),
      (s[12] = a * x + o * L + l * A + c * oe),
      (s[1] = u * b + h * T + f * F + p * k),
      (s[5] = u * M + h * D + f * I + p * G),
      (s[9] = u * C + h * N + f * j + p * z),
      (s[13] = u * x + h * L + f * A + p * oe),
      (s[2] = g * b + m * T + _ * F + d * k),
      (s[6] = g * M + m * D + _ * I + d * G),
      (s[10] = g * C + m * N + _ * j + d * z),
      (s[14] = g * x + m * L + _ * A + d * oe),
      (s[3] = y * b + v * T + S * F + E * k),
      (s[7] = y * M + v * D + S * I + E * G),
      (s[11] = y * C + v * N + S * j + E * z),
      (s[15] = y * x + v * L + S * A + E * oe),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      n = e[4],
      i = e[8],
      s = e[12],
      a = e[1],
      o = e[5],
      l = e[9],
      c = e[13],
      u = e[2],
      h = e[6],
      f = e[10],
      p = e[14],
      g = e[3],
      m = e[7],
      _ = e[11],
      d = e[15];
    return (
      g *
        (+s * l * h -
          i * c * h -
          s * o * f +
          n * c * f +
          i * o * p -
          n * l * p) +
      m *
        (+t * l * p -
          t * c * f +
          s * a * f -
          i * a * p +
          i * c * u -
          s * l * u) +
      _ *
        (+t * c * h -
          t * o * p -
          s * a * h +
          n * a * p +
          s * o * u -
          n * c * u) +
      d *
        (-i * o * u - t * l * h + t * o * f + i * a * h - n * a * f + n * l * u)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, n) {
    const i = this.elements;
    return (
      e.isVector3
        ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
        : ((i[12] = e), (i[13] = t), (i[14] = n)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      n = e[1],
      i = e[2],
      s = e[3],
      a = e[4],
      o = e[5],
      l = e[6],
      c = e[7],
      u = e[8],
      h = e[9],
      f = e[10],
      p = e[11],
      g = e[12],
      m = e[13],
      _ = e[14],
      d = e[15],
      y = h * _ * c - m * f * c + m * l * p - o * _ * p - h * l * d + o * f * d,
      v = g * f * c - u * _ * c - g * l * p + a * _ * p + u * l * d - a * f * d,
      S = u * m * c - g * h * c + g * o * p - a * m * p - u * o * d + a * h * d,
      E = g * h * l - u * m * l - g * o * f + a * m * f + u * o * _ - a * h * _,
      b = t * y + n * v + i * S + s * E;
    if (b === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const M = 1 / b;
    return (
      (e[0] = y * M),
      (e[1] =
        (m * f * s -
          h * _ * s -
          m * i * p +
          n * _ * p +
          h * i * d -
          n * f * d) *
        M),
      (e[2] =
        (o * _ * s -
          m * l * s +
          m * i * c -
          n * _ * c -
          o * i * d +
          n * l * d) *
        M),
      (e[3] =
        (h * l * s -
          o * f * s -
          h * i * c +
          n * f * c +
          o * i * p -
          n * l * p) *
        M),
      (e[4] = v * M),
      (e[5] =
        (u * _ * s -
          g * f * s +
          g * i * p -
          t * _ * p -
          u * i * d +
          t * f * d) *
        M),
      (e[6] =
        (g * l * s -
          a * _ * s -
          g * i * c +
          t * _ * c +
          a * i * d -
          t * l * d) *
        M),
      (e[7] =
        (a * f * s -
          u * l * s +
          u * i * c -
          t * f * c -
          a * i * p +
          t * l * p) *
        M),
      (e[8] = S * M),
      (e[9] =
        (g * h * s -
          u * m * s -
          g * n * p +
          t * m * p +
          u * n * d -
          t * h * d) *
        M),
      (e[10] =
        (a * m * s -
          g * o * s +
          g * n * c -
          t * m * c -
          a * n * d +
          t * o * d) *
        M),
      (e[11] =
        (u * o * s -
          a * h * s -
          u * n * c +
          t * h * c +
          a * n * p -
          t * o * p) *
        M),
      (e[12] = E * M),
      (e[13] =
        (u * m * i -
          g * h * i +
          g * n * f -
          t * m * f -
          u * n * _ +
          t * h * _) *
        M),
      (e[14] =
        (g * o * i -
          a * m * i -
          g * n * l +
          t * m * l +
          a * n * _ -
          t * o * _) *
        M),
      (e[15] =
        (a * h * i -
          u * o * i +
          u * n * l -
          t * h * l -
          a * n * f +
          t * o * f) *
        M),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      n = e.x,
      i = e.y,
      s = e.z;
    return (
      (t[0] *= n),
      (t[4] *= i),
      (t[8] *= s),
      (t[1] *= n),
      (t[5] *= i),
      (t[9] *= s),
      (t[2] *= n),
      (t[6] *= i),
      (t[10] *= s),
      (t[3] *= n),
      (t[7] *= i),
      (t[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, n, i));
  }
  makeTranslation(e, t, n) {
    return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this;
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      n = Math.sin(e);
    return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const n = Math.cos(t),
      i = Math.sin(t),
      s = 1 - n,
      a = e.x,
      o = e.y,
      l = e.z,
      c = s * a,
      u = s * o;
    return (
      this.set(
        c * a + n,
        c * o - i * l,
        c * l + i * o,
        0,
        c * o + i * l,
        u * o + n,
        u * l - i * a,
        0,
        c * l - i * o,
        u * l + i * a,
        s * l * l + n,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, n) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, n, i, s, a) {
    return this.set(1, n, s, 0, e, 1, a, 0, t, i, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, n) {
    const i = this.elements,
      s = t._x,
      a = t._y,
      o = t._z,
      l = t._w,
      c = s + s,
      u = a + a,
      h = o + o,
      f = s * c,
      p = s * u,
      g = s * h,
      m = a * u,
      _ = a * h,
      d = o * h,
      y = l * c,
      v = l * u,
      S = l * h,
      E = n.x,
      b = n.y,
      M = n.z;
    return (
      (i[0] = (1 - (m + d)) * E),
      (i[1] = (p + S) * E),
      (i[2] = (g - v) * E),
      (i[3] = 0),
      (i[4] = (p - S) * b),
      (i[5] = (1 - (f + d)) * b),
      (i[6] = (_ + y) * b),
      (i[7] = 0),
      (i[8] = (g + v) * M),
      (i[9] = (_ - y) * M),
      (i[10] = (1 - (f + m)) * M),
      (i[11] = 0),
      (i[12] = e.x),
      (i[13] = e.y),
      (i[14] = e.z),
      (i[15] = 1),
      this
    );
  }
  decompose(e, t, n) {
    const i = this.elements;
    let s = Xs.set(i[0], i[1], i[2]).length();
    const a = Xs.set(i[4], i[5], i[6]).length(),
      o = Xs.set(i[8], i[9], i[10]).length();
    this.determinant() < 0 && (s = -s),
      (e.x = i[12]),
      (e.y = i[13]),
      (e.z = i[14]),
      ci.copy(this);
    const c = 1 / s,
      u = 1 / a,
      h = 1 / o;
    return (
      (ci.elements[0] *= c),
      (ci.elements[1] *= c),
      (ci.elements[2] *= c),
      (ci.elements[4] *= u),
      (ci.elements[5] *= u),
      (ci.elements[6] *= u),
      (ci.elements[8] *= h),
      (ci.elements[9] *= h),
      (ci.elements[10] *= h),
      t.setFromRotationMatrix(ci),
      (n.x = s),
      (n.y = a),
      (n.z = o),
      this
    );
  }
  makePerspective(e, t, n, i, s, a) {
    const o = this.elements,
      l = (2 * s) / (t - e),
      c = (2 * s) / (n - i),
      u = (t + e) / (t - e),
      h = (n + i) / (n - i),
      f = -(a + s) / (a - s),
      p = (-2 * a * s) / (a - s);
    return (
      (o[0] = l),
      (o[4] = 0),
      (o[8] = u),
      (o[12] = 0),
      (o[1] = 0),
      (o[5] = c),
      (o[9] = h),
      (o[13] = 0),
      (o[2] = 0),
      (o[6] = 0),
      (o[10] = f),
      (o[14] = p),
      (o[3] = 0),
      (o[7] = 0),
      (o[11] = -1),
      (o[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, n, i, s, a) {
    const o = this.elements,
      l = 1 / (t - e),
      c = 1 / (n - i),
      u = 1 / (a - s),
      h = (t + e) * l,
      f = (n + i) * c,
      p = (a + s) * u;
    return (
      (o[0] = 2 * l),
      (o[4] = 0),
      (o[8] = 0),
      (o[12] = -h),
      (o[1] = 0),
      (o[5] = 2 * c),
      (o[9] = 0),
      (o[13] = -f),
      (o[2] = 0),
      (o[6] = 0),
      (o[10] = -2 * u),
      (o[14] = -p),
      (o[3] = 0),
      (o[7] = 0),
      (o[11] = 0),
      (o[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      n = e.elements;
    for (let i = 0; i < 16; i++) if (t[i] !== n[i]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const n = this.elements;
    return (
      (e[t] = n[0]),
      (e[t + 1] = n[1]),
      (e[t + 2] = n[2]),
      (e[t + 3] = n[3]),
      (e[t + 4] = n[4]),
      (e[t + 5] = n[5]),
      (e[t + 6] = n[6]),
      (e[t + 7] = n[7]),
      (e[t + 8] = n[8]),
      (e[t + 9] = n[9]),
      (e[t + 10] = n[10]),
      (e[t + 11] = n[11]),
      (e[t + 12] = n[12]),
      (e[t + 13] = n[13]),
      (e[t + 14] = n[14]),
      (e[t + 15] = n[15]),
      e
    );
  }
}
const Xs = new H(),
  ci = new et(),
  ey = new H(0, 0, 0),
  ty = new H(1, 1, 1),
  _r = new H(),
  Ll = new H(),
  Nn = new H(),
  mp = new et(),
  _p = new Ni();
class ou {
  constructor(e = 0, t = 0, n = 0, i = ou.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._order = i);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, n, i = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = n),
      (this._order = i),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, n = !0) {
    const i = e.elements,
      s = i[0],
      a = i[4],
      o = i[8],
      l = i[1],
      c = i[5],
      u = i[9],
      h = i[2],
      f = i[6],
      p = i[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin($t(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(-u, p)), (this._z = Math.atan2(-a, s)))
            : ((this._x = Math.atan2(f, c)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-$t(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._y = Math.atan2(o, p)), (this._z = Math.atan2(l, c)))
            : ((this._y = Math.atan2(-h, s)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin($t(f, -1, 1))),
          Math.abs(f) < 0.9999999
            ? ((this._y = Math.atan2(-h, p)), (this._z = Math.atan2(-a, c)))
            : ((this._y = 0), (this._z = Math.atan2(l, s)));
        break;
      case "ZYX":
        (this._y = Math.asin(-$t(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._x = Math.atan2(f, p)), (this._z = Math.atan2(l, s)))
            : ((this._x = 0), (this._z = Math.atan2(-a, c)));
        break;
      case "YZX":
        (this._z = Math.asin($t(l, -1, 1))),
          Math.abs(l) < 0.9999999
            ? ((this._x = Math.atan2(-u, c)), (this._y = Math.atan2(-h, s)))
            : ((this._x = 0), (this._y = Math.atan2(o, p)));
        break;
      case "XZY":
        (this._z = Math.asin(-$t(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(f, c)), (this._y = Math.atan2(o, s)))
            : ((this._x = Math.atan2(-u, p)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), n === !0 && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, n) {
    return (
      mp.makeRotationFromQuaternion(e), this.setFromRotationMatrix(mp, t, n)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return _p.setFromEuler(this), this.setFromQuaternion(_p, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      e[3] !== void 0 && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
ou.DEFAULT_ORDER = "XYZ";
class Rf {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return (this.mask & e.mask) !== 0;
  }
  isEnabled(e) {
    return (this.mask & ((1 << e) | 0)) !== 0;
  }
}
let ny = 0;
const gp = new H(),
  Ys = new Ni(),
  Wi = new et(),
  Dl = new H(),
  ro = new H(),
  iy = new H(),
  ry = new Ni(),
  vp = new H(1, 0, 0),
  xp = new H(0, 1, 0),
  yp = new H(0, 0, 1),
  sy = { type: "added" },
  Ep = { type: "removed" };
class Tt extends Ds {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: ny++ }),
      (this.uuid = gi()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Tt.DEFAULT_UP.clone());
    const e = new H(),
      t = new ou(),
      n = new Ni(),
      i = new H(1, 1, 1);
    function s() {
      n.setFromEuler(t, !1);
    }
    function a() {
      t.setFromQuaternion(n, void 0, !1);
    }
    t._onChange(s),
      n._onChange(a),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: n },
        scale: { configurable: !0, enumerable: !0, value: i },
        modelViewMatrix: { value: new et() },
        normalMatrix: { value: new it() },
      }),
      (this.matrix = new et()),
      (this.matrixWorld = new et()),
      (this.matrixAutoUpdate = Tt.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.matrixWorldAutoUpdate = Tt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.layers = new Rf()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return Ys.setFromAxisAngle(e, t), this.quaternion.multiply(Ys), this;
  }
  rotateOnWorldAxis(e, t) {
    return Ys.setFromAxisAngle(e, t), this.quaternion.premultiply(Ys), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(vp, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(xp, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(yp, e);
  }
  translateOnAxis(e, t) {
    return (
      gp.copy(e).applyQuaternion(this.quaternion),
      this.position.add(gp.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(vp, e);
  }
  translateY(e) {
    return this.translateOnAxis(xp, e);
  }
  translateZ(e) {
    return this.translateOnAxis(yp, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(Wi.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, n) {
    e.isVector3 ? Dl.copy(e) : Dl.set(e, t, n);
    const i = this.parent;
    this.updateWorldMatrix(!0, !1),
      ro.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? Wi.lookAt(ro, Dl, this.up)
        : Wi.lookAt(Dl, ro, this.up),
      this.quaternion.setFromRotationMatrix(Wi),
      i &&
        (Wi.extractRotation(i.matrixWorld),
        Ys.setFromRotationMatrix(Wi),
        this.quaternion.premultiply(Ys.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (e.parent !== null && e.parent.remove(e),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(sy))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      t !== -1 &&
        ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent(Ep)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return e !== null && e.remove(this), this;
  }
  clear() {
    for (let e = 0; e < this.children.length; e++) {
      const t = this.children[e];
      (t.parent = null), t.dispatchEvent(Ep);
    }
    return (this.children.length = 0), this;
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      Wi.copy(this.matrixWorld).invert(),
      e.parent !== null &&
        (e.parent.updateWorldMatrix(!0, !1), Wi.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(Wi),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let n = 0, i = this.children.length; n < i; n++) {
      const a = this.children[n].getObjectByProperty(e, t);
      if (a !== void 0) return a;
    }
  }
  getObjectsByProperty(e, t) {
    let n = [];
    this[e] === t && n.push(this);
    for (let i = 0, s = this.children.length; i < s; i++) {
      const a = this.children[i].getObjectsByProperty(e, t);
      a.length > 0 && (n = n.concat(a));
    }
    return n;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ro, e, iy), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(ro, ry, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
  }
  traverseVisible(e) {
    if (this.visible === !1) return;
    e(this);
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    t !== null && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (this.parent === null
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let n = 0, i = t.length; n < i; n++) {
      const s = t[n];
      (s.matrixWorldAutoUpdate === !0 || e === !0) && s.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const n = this.parent;
    if (
      (e === !0 &&
        n !== null &&
        n.matrixWorldAutoUpdate === !0 &&
        n.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      this.parent === null
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      t === !0)
    ) {
      const i = this.children;
      for (let s = 0, a = i.length; s < a; s++) {
        const o = i[s];
        o.matrixWorldAutoUpdate === !0 && o.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string",
      n = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (n.metadata = {
        version: 4.5,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const i = {};
    (i.uuid = this.uuid),
      (i.type = this.type),
      this.name !== "" && (i.name = this.name),
      this.castShadow === !0 && (i.castShadow = !0),
      this.receiveShadow === !0 && (i.receiveShadow = !0),
      this.visible === !1 && (i.visible = !1),
      this.frustumCulled === !1 && (i.frustumCulled = !1),
      this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (i.userData = this.userData),
      (i.layers = this.layers.mask),
      (i.matrix = this.matrix.toArray()),
      (i.up = this.up.toArray()),
      this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((i.type = "InstancedMesh"),
        (i.count = this.count),
        (i.instanceMatrix = this.instanceMatrix.toJSON()),
        this.instanceColor !== null &&
          (i.instanceColor = this.instanceColor.toJSON()));
    function s(o, l) {
      return o[l.uuid] === void 0 && (o[l.uuid] = l.toJSON(e)), l.uuid;
    }
    if (this.isScene)
      this.background &&
        (this.background.isColor
          ? (i.background = this.background.toJSON())
          : this.background.isTexture &&
            (i.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          this.environment.isRenderTargetTexture !== !0 &&
          (i.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      i.geometry = s(e.geometries, this.geometry);
      const o = this.geometry.parameters;
      if (o !== void 0 && o.shapes !== void 0) {
        const l = o.shapes;
        if (Array.isArray(l))
          for (let c = 0, u = l.length; c < u; c++) {
            const h = l[c];
            s(e.shapes, h);
          }
        else s(e.shapes, l);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((i.bindMode = this.bindMode),
        (i.bindMatrix = this.bindMatrix.toArray()),
        this.skeleton !== void 0 &&
          (s(e.skeletons, this.skeleton), (i.skeleton = this.skeleton.uuid))),
      this.material !== void 0)
    )
      if (Array.isArray(this.material)) {
        const o = [];
        for (let l = 0, c = this.material.length; l < c; l++)
          o.push(s(e.materials, this.material[l]));
        i.material = o;
      } else i.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      i.children = [];
      for (let o = 0; o < this.children.length; o++)
        i.children.push(this.children[o].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      i.animations = [];
      for (let o = 0; o < this.animations.length; o++) {
        const l = this.animations[o];
        i.animations.push(s(e.animations, l));
      }
    }
    if (t) {
      const o = a(e.geometries),
        l = a(e.materials),
        c = a(e.textures),
        u = a(e.images),
        h = a(e.shapes),
        f = a(e.skeletons),
        p = a(e.animations),
        g = a(e.nodes);
      o.length > 0 && (n.geometries = o),
        l.length > 0 && (n.materials = l),
        c.length > 0 && (n.textures = c),
        u.length > 0 && (n.images = u),
        h.length > 0 && (n.shapes = h),
        f.length > 0 && (n.skeletons = f),
        p.length > 0 && (n.animations = p),
        g.length > 0 && (n.nodes = g);
    }
    return (n.object = i), n;
    function a(o) {
      const l = [];
      for (const c in o) {
        const u = o[c];
        delete u.metadata, l.push(u);
      }
      return l;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      t === !0)
    )
      for (let n = 0; n < e.children.length; n++) {
        const i = e.children[n];
        this.add(i.clone());
      }
    return this;
  }
}
Tt.DEFAULT_UP = new H(0, 1, 0);
Tt.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Tt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const ui = new H(),
  Xi = new H(),
  Wu = new H(),
  Yi = new H(),
  qs = new H(),
  js = new H(),
  Sp = new H(),
  Xu = new H(),
  Yu = new H(),
  qu = new H();
let Il = !1;
class di {
  constructor(e = new H(), t = new H(), n = new H()) {
    (this.a = e), (this.b = t), (this.c = n);
  }
  static getNormal(e, t, n, i) {
    i.subVectors(n, t), ui.subVectors(e, t), i.cross(ui);
    const s = i.lengthSq();
    return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0);
  }
  static getBarycoord(e, t, n, i, s) {
    ui.subVectors(i, t), Xi.subVectors(n, t), Wu.subVectors(e, t);
    const a = ui.dot(ui),
      o = ui.dot(Xi),
      l = ui.dot(Wu),
      c = Xi.dot(Xi),
      u = Xi.dot(Wu),
      h = a * c - o * o;
    if (h === 0) return s.set(-2, -1, -1);
    const f = 1 / h,
      p = (c * l - o * u) * f,
      g = (a * u - o * l) * f;
    return s.set(1 - p - g, g, p);
  }
  static containsPoint(e, t, n, i) {
    return (
      this.getBarycoord(e, t, n, i, Yi),
      Yi.x >= 0 && Yi.y >= 0 && Yi.x + Yi.y <= 1
    );
  }
  static getUV(e, t, n, i, s, a, o, l) {
    return (
      Il === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (Il = !0)),
      this.getInterpolation(e, t, n, i, s, a, o, l)
    );
  }
  static getInterpolation(e, t, n, i, s, a, o, l) {
    return (
      this.getBarycoord(e, t, n, i, Yi),
      l.setScalar(0),
      l.addScaledVector(s, Yi.x),
      l.addScaledVector(a, Yi.y),
      l.addScaledVector(o, Yi.z),
      l
    );
  }
  static isFrontFacing(e, t, n, i) {
    return ui.subVectors(n, t), Xi.subVectors(e, t), ui.cross(Xi).dot(i) < 0;
  }
  set(e, t, n) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
  }
  setFromPointsAndIndices(e, t, n, i) {
    return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
  }
  setFromAttributeAndIndices(e, t, n, i) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, n),
      this.c.fromBufferAttribute(e, i),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      ui.subVectors(this.c, this.b),
      Xi.subVectors(this.a, this.b),
      ui.cross(Xi).length() * 0.5
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return di.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return di.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, n, i, s) {
    return (
      Il === !1 &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (Il = !0)),
      di.getInterpolation(e, this.a, this.b, this.c, t, n, i, s)
    );
  }
  getInterpolation(e, t, n, i, s) {
    return di.getInterpolation(e, this.a, this.b, this.c, t, n, i, s);
  }
  containsPoint(e) {
    return di.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return di.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const n = this.a,
      i = this.b,
      s = this.c;
    let a, o;
    qs.subVectors(i, n), js.subVectors(s, n), Xu.subVectors(e, n);
    const l = qs.dot(Xu),
      c = js.dot(Xu);
    if (l <= 0 && c <= 0) return t.copy(n);
    Yu.subVectors(e, i);
    const u = qs.dot(Yu),
      h = js.dot(Yu);
    if (u >= 0 && h <= u) return t.copy(i);
    const f = l * h - u * c;
    if (f <= 0 && l >= 0 && u <= 0)
      return (a = l / (l - u)), t.copy(n).addScaledVector(qs, a);
    qu.subVectors(e, s);
    const p = qs.dot(qu),
      g = js.dot(qu);
    if (g >= 0 && p <= g) return t.copy(s);
    const m = p * c - l * g;
    if (m <= 0 && c >= 0 && g <= 0)
      return (o = c / (c - g)), t.copy(n).addScaledVector(js, o);
    const _ = u * g - p * h;
    if (_ <= 0 && h - u >= 0 && p - g >= 0)
      return (
        Sp.subVectors(s, i),
        (o = (h - u) / (h - u + (p - g))),
        t.copy(i).addScaledVector(Sp, o)
      );
    const d = 1 / (_ + m + f);
    return (
      (a = m * d),
      (o = f * d),
      t.copy(n).addScaledVector(qs, a).addScaledVector(js, o)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}
let ay = 0;
class Pi extends Ds {
  constructor() {
    super(),
      (this.isMaterial = !0),
      Object.defineProperty(this, "id", { value: ay++ }),
      (this.uuid = gi()),
      (this.name = ""),
      (this.type = "Material"),
      (this.blending = Sa),
      (this.side = or),
      (this.vertexColors = !1),
      (this.opacity = 1),
      (this.transparent = !1),
      (this.blendSrc = N_),
      (this.blendDst = O_),
      (this.blendEquation = la),
      (this.blendSrcAlpha = null),
      (this.blendDstAlpha = null),
      (this.blendEquationAlpha = null),
      (this.depthFunc = Rh),
      (this.depthTest = !0),
      (this.depthWrite = !0),
      (this.stencilWriteMask = 255),
      (this.stencilFunc = Lx),
      (this.stencilRef = 0),
      (this.stencilFuncMask = 255),
      (this.stencilFail = Nu),
      (this.stencilZFail = Nu),
      (this.stencilZPass = Nu),
      (this.stencilWrite = !1),
      (this.clippingPlanes = null),
      (this.clipIntersection = !1),
      (this.clipShadows = !1),
      (this.shadowSide = null),
      (this.colorWrite = !0),
      (this.precision = null),
      (this.polygonOffset = !1),
      (this.polygonOffsetFactor = 0),
      (this.polygonOffsetUnits = 0),
      (this.dithering = !1),
      (this.alphaToCoverage = !1),
      (this.premultipliedAlpha = !1),
      (this.forceSinglePass = !1),
      (this.visible = !0),
      (this.toneMapped = !0),
      (this.userData = {}),
      (this.version = 0),
      (this._alphaTest = 0);
  }
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(e) {
    this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  setValues(e) {
    if (e !== void 0)
      for (const t in e) {
        const n = e[t];
        if (n === void 0) {
          console.warn(
            `THREE.Material: parameter '${t}' has value of undefined.`
          );
          continue;
        }
        const i = this[t];
        if (i === void 0) {
          console.warn(
            `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
          );
          continue;
        }
        i && i.isColor
          ? i.set(n)
          : i && i.isVector3 && n && n.isVector3
          ? i.copy(n)
          : (this[t] = n);
      }
  }
  toJSON(e) {
    const t = e === void 0 || typeof e == "string";
    t && (e = { textures: {}, images: {} });
    const n = {
      metadata: {
        version: 4.5,
        type: "Material",
        generator: "Material.toJSON",
      },
    };
    (n.uuid = this.uuid),
      (n.type = this.type),
      this.name !== "" && (n.name = this.name),
      this.color && this.color.isColor && (n.color = this.color.getHex()),
      this.roughness !== void 0 && (n.roughness = this.roughness),
      this.metalness !== void 0 && (n.metalness = this.metalness),
      this.sheen !== void 0 && (n.sheen = this.sheen),
      this.sheenColor &&
        this.sheenColor.isColor &&
        (n.sheenColor = this.sheenColor.getHex()),
      this.sheenRoughness !== void 0 &&
        (n.sheenRoughness = this.sheenRoughness),
      this.emissive &&
        this.emissive.isColor &&
        (n.emissive = this.emissive.getHex()),
      this.emissiveIntensity &&
        this.emissiveIntensity !== 1 &&
        (n.emissiveIntensity = this.emissiveIntensity),
      this.specular &&
        this.specular.isColor &&
        (n.specular = this.specular.getHex()),
      this.specularIntensity !== void 0 &&
        (n.specularIntensity = this.specularIntensity),
      this.specularColor &&
        this.specularColor.isColor &&
        (n.specularColor = this.specularColor.getHex()),
      this.shininess !== void 0 && (n.shininess = this.shininess),
      this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
      this.clearcoatRoughness !== void 0 &&
        (n.clearcoatRoughness = this.clearcoatRoughness),
      this.clearcoatMap &&
        this.clearcoatMap.isTexture &&
        (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
      this.clearcoatRoughnessMap &&
        this.clearcoatRoughnessMap.isTexture &&
        (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
      this.clearcoatNormalMap &&
        this.clearcoatNormalMap.isTexture &&
        ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
        (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
      this.iridescence !== void 0 && (n.iridescence = this.iridescence),
      this.iridescenceIOR !== void 0 &&
        (n.iridescenceIOR = this.iridescenceIOR),
      this.iridescenceThicknessRange !== void 0 &&
        (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
      this.iridescenceMap &&
        this.iridescenceMap.isTexture &&
        (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
      this.iridescenceThicknessMap &&
        this.iridescenceThicknessMap.isTexture &&
        (n.iridescenceThicknessMap =
          this.iridescenceThicknessMap.toJSON(e).uuid),
      this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
      this.matcap &&
        this.matcap.isTexture &&
        (n.matcap = this.matcap.toJSON(e).uuid),
      this.alphaMap &&
        this.alphaMap.isTexture &&
        (n.alphaMap = this.alphaMap.toJSON(e).uuid),
      this.lightMap &&
        this.lightMap.isTexture &&
        ((n.lightMap = this.lightMap.toJSON(e).uuid),
        (n.lightMapIntensity = this.lightMapIntensity)),
      this.aoMap &&
        this.aoMap.isTexture &&
        ((n.aoMap = this.aoMap.toJSON(e).uuid),
        (n.aoMapIntensity = this.aoMapIntensity)),
      this.bumpMap &&
        this.bumpMap.isTexture &&
        ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
        (n.bumpScale = this.bumpScale)),
      this.normalMap &&
        this.normalMap.isTexture &&
        ((n.normalMap = this.normalMap.toJSON(e).uuid),
        (n.normalMapType = this.normalMapType),
        (n.normalScale = this.normalScale.toArray())),
      this.displacementMap &&
        this.displacementMap.isTexture &&
        ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
        (n.displacementScale = this.displacementScale),
        (n.displacementBias = this.displacementBias)),
      this.roughnessMap &&
        this.roughnessMap.isTexture &&
        (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
      this.metalnessMap &&
        this.metalnessMap.isTexture &&
        (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
      this.emissiveMap &&
        this.emissiveMap.isTexture &&
        (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
      this.specularMap &&
        this.specularMap.isTexture &&
        (n.specularMap = this.specularMap.toJSON(e).uuid),
      this.specularIntensityMap &&
        this.specularIntensityMap.isTexture &&
        (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
      this.specularColorMap &&
        this.specularColorMap.isTexture &&
        (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
      this.envMap &&
        this.envMap.isTexture &&
        ((n.envMap = this.envMap.toJSON(e).uuid),
        this.combine !== void 0 && (n.combine = this.combine)),
      this.envMapIntensity !== void 0 &&
        (n.envMapIntensity = this.envMapIntensity),
      this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
      this.refractionRatio !== void 0 &&
        (n.refractionRatio = this.refractionRatio),
      this.gradientMap &&
        this.gradientMap.isTexture &&
        (n.gradientMap = this.gradientMap.toJSON(e).uuid),
      this.transmission !== void 0 && (n.transmission = this.transmission),
      this.transmissionMap &&
        this.transmissionMap.isTexture &&
        (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
      this.thickness !== void 0 && (n.thickness = this.thickness),
      this.thicknessMap &&
        this.thicknessMap.isTexture &&
        (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
      this.attenuationDistance !== void 0 &&
        this.attenuationDistance !== 1 / 0 &&
        (n.attenuationDistance = this.attenuationDistance),
      this.attenuationColor !== void 0 &&
        (n.attenuationColor = this.attenuationColor.getHex()),
      this.size !== void 0 && (n.size = this.size),
      this.shadowSide !== null && (n.shadowSide = this.shadowSide),
      this.sizeAttenuation !== void 0 &&
        (n.sizeAttenuation = this.sizeAttenuation),
      this.blending !== Sa && (n.blending = this.blending),
      this.side !== or && (n.side = this.side),
      this.vertexColors && (n.vertexColors = !0),
      this.opacity < 1 && (n.opacity = this.opacity),
      this.transparent === !0 && (n.transparent = this.transparent),
      (n.depthFunc = this.depthFunc),
      (n.depthTest = this.depthTest),
      (n.depthWrite = this.depthWrite),
      (n.colorWrite = this.colorWrite),
      (n.stencilWrite = this.stencilWrite),
      (n.stencilWriteMask = this.stencilWriteMask),
      (n.stencilFunc = this.stencilFunc),
      (n.stencilRef = this.stencilRef),
      (n.stencilFuncMask = this.stencilFuncMask),
      (n.stencilFail = this.stencilFail),
      (n.stencilZFail = this.stencilZFail),
      (n.stencilZPass = this.stencilZPass),
      this.rotation !== void 0 &&
        this.rotation !== 0 &&
        (n.rotation = this.rotation),
      this.polygonOffset === !0 && (n.polygonOffset = !0),
      this.polygonOffsetFactor !== 0 &&
        (n.polygonOffsetFactor = this.polygonOffsetFactor),
      this.polygonOffsetUnits !== 0 &&
        (n.polygonOffsetUnits = this.polygonOffsetUnits),
      this.linewidth !== void 0 &&
        this.linewidth !== 1 &&
        (n.linewidth = this.linewidth),
      this.dashSize !== void 0 && (n.dashSize = this.dashSize),
      this.gapSize !== void 0 && (n.gapSize = this.gapSize),
      this.scale !== void 0 && (n.scale = this.scale),
      this.dithering === !0 && (n.dithering = !0),
      this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
      this.alphaToCoverage === !0 && (n.alphaToCoverage = this.alphaToCoverage),
      this.premultipliedAlpha === !0 &&
        (n.premultipliedAlpha = this.premultipliedAlpha),
      this.forceSinglePass === !0 && (n.forceSinglePass = this.forceSinglePass),
      this.wireframe === !0 && (n.wireframe = this.wireframe),
      this.wireframeLinewidth > 1 &&
        (n.wireframeLinewidth = this.wireframeLinewidth),
      this.wireframeLinecap !== "round" &&
        (n.wireframeLinecap = this.wireframeLinecap),
      this.wireframeLinejoin !== "round" &&
        (n.wireframeLinejoin = this.wireframeLinejoin),
      this.flatShading === !0 && (n.flatShading = this.flatShading),
      this.visible === !1 && (n.visible = !1),
      this.toneMapped === !1 && (n.toneMapped = !1),
      this.fog === !1 && (n.fog = !1),
      Object.keys(this.userData).length > 0 && (n.userData = this.userData);
    function i(s) {
      const a = [];
      for (const o in s) {
        const l = s[o];
        delete l.metadata, a.push(l);
      }
      return a;
    }
    if (t) {
      const s = i(e.textures),
        a = i(e.images);
      s.length > 0 && (n.textures = s), a.length > 0 && (n.images = a);
    }
    return n;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.name = e.name),
      (this.blending = e.blending),
      (this.side = e.side),
      (this.vertexColors = e.vertexColors),
      (this.opacity = e.opacity),
      (this.transparent = e.transparent),
      (this.blendSrc = e.blendSrc),
      (this.blendDst = e.blendDst),
      (this.blendEquation = e.blendEquation),
      (this.blendSrcAlpha = e.blendSrcAlpha),
      (this.blendDstAlpha = e.blendDstAlpha),
      (this.blendEquationAlpha = e.blendEquationAlpha),
      (this.depthFunc = e.depthFunc),
      (this.depthTest = e.depthTest),
      (this.depthWrite = e.depthWrite),
      (this.stencilWriteMask = e.stencilWriteMask),
      (this.stencilFunc = e.stencilFunc),
      (this.stencilRef = e.stencilRef),
      (this.stencilFuncMask = e.stencilFuncMask),
      (this.stencilFail = e.stencilFail),
      (this.stencilZFail = e.stencilZFail),
      (this.stencilZPass = e.stencilZPass),
      (this.stencilWrite = e.stencilWrite);
    const t = e.clippingPlanes;
    let n = null;
    if (t !== null) {
      const i = t.length;
      n = new Array(i);
      for (let s = 0; s !== i; ++s) n[s] = t[s].clone();
    }
    return (
      (this.clippingPlanes = n),
      (this.clipIntersection = e.clipIntersection),
      (this.clipShadows = e.clipShadows),
      (this.shadowSide = e.shadowSide),
      (this.colorWrite = e.colorWrite),
      (this.precision = e.precision),
      (this.polygonOffset = e.polygonOffset),
      (this.polygonOffsetFactor = e.polygonOffsetFactor),
      (this.polygonOffsetUnits = e.polygonOffsetUnits),
      (this.dithering = e.dithering),
      (this.alphaTest = e.alphaTest),
      (this.alphaToCoverage = e.alphaToCoverage),
      (this.premultipliedAlpha = e.premultipliedAlpha),
      (this.forceSinglePass = e.forceSinglePass),
      (this.visible = e.visible),
      (this.toneMapped = e.toneMapped),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
}
const $_ = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  hi = { h: 0, s: 0, l: 0 },
  Nl = { h: 0, s: 0, l: 0 };
function ju(r, e, t) {
  return (
    t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6
      ? r + (e - r) * 6 * t
      : t < 1 / 2
      ? e
      : t < 2 / 3
      ? r + (e - r) * 6 * (2 / 3 - t)
      : r
  );
}
let Ke = class {
  constructor(e, t, n) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      t === void 0 && n === void 0 ? this.set(e) : this.setRGB(e, t, n)
    );
  }
  set(e) {
    return (
      e && e.isColor
        ? this.copy(e)
        : typeof e == "number"
        ? this.setHex(e)
        : typeof e == "string" && this.setStyle(e),
      this
    );
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = Ve) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (e & 255) / 255),
      li.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, n, i = li.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = n),
      li.toWorkingColorSpace(this, i),
      this
    );
  }
  setHSL(e, t, n, i = li.workingColorSpace) {
    if (((e = wf(e, 1)), (t = $t(t, 0, 1)), (n = $t(n, 0, 1)), t === 0))
      this.r = this.g = this.b = n;
    else {
      const s = n <= 0.5 ? n * (1 + t) : n + t - n * t,
        a = 2 * n - s;
      (this.r = ju(a, s, e + 1 / 3)),
        (this.g = ju(a, s, e)),
        (this.b = ju(a, s, e - 1 / 3));
    }
    return li.toWorkingColorSpace(this, i), this;
  }
  setStyle(e, t = Ve) {
    function n(s) {
      s !== void 0 &&
        parseFloat(s) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let i;
    if ((i = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const a = i[1],
        o = i[2];
      switch (a) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              n(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                t
              )
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              n(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                t
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                o
              ))
          )
            return (
              n(s[4]),
              this.setHSL(
                parseFloat(s[1]) / 360,
                parseFloat(s[2]) / 100,
                parseFloat(s[3]) / 100,
                t
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const s = i[1],
        a = s.length;
      if (a === 3)
        return this.setRGB(
          parseInt(s.charAt(0), 16) / 15,
          parseInt(s.charAt(1), 16) / 15,
          parseInt(s.charAt(2), 16) / 15,
          t
        );
      if (a === 6) return this.setHex(parseInt(s, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = Ve) {
    const n = $_[e.toLowerCase()];
    return (
      n !== void 0
        ? this.setHex(n, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = ba(e.r)), (this.g = ba(e.g)), (this.b = ba(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = Uu(e.r)), (this.g = Uu(e.g)), (this.b = Uu(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = Ve) {
    return (
      li.fromWorkingColorSpace(tn.copy(this), e),
      Math.round($t(tn.r * 255, 0, 255)) * 65536 +
        Math.round($t(tn.g * 255, 0, 255)) * 256 +
        Math.round($t(tn.b * 255, 0, 255))
    );
  }
  getHexString(e = Ve) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = li.workingColorSpace) {
    li.fromWorkingColorSpace(tn.copy(this), t);
    const n = tn.r,
      i = tn.g,
      s = tn.b,
      a = Math.max(n, i, s),
      o = Math.min(n, i, s);
    let l, c;
    const u = (o + a) / 2;
    if (o === a) (l = 0), (c = 0);
    else {
      const h = a - o;
      switch (((c = u <= 0.5 ? h / (a + o) : h / (2 - a - o)), a)) {
        case n:
          l = (i - s) / h + (i < s ? 6 : 0);
          break;
        case i:
          l = (s - n) / h + 2;
          break;
        case s:
          l = (n - i) / h + 4;
          break;
      }
      l /= 6;
    }
    return (e.h = l), (e.s = c), (e.l = u), e;
  }
  getRGB(e, t = li.workingColorSpace) {
    return (
      li.fromWorkingColorSpace(tn.copy(this), t),
      (e.r = tn.r),
      (e.g = tn.g),
      (e.b = tn.b),
      e
    );
  }
  getStyle(e = Ve) {
    li.fromWorkingColorSpace(tn.copy(this), e);
    const t = tn.r,
      n = tn.g,
      i = tn.b;
    return e !== Ve
      ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`
      : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(
          i * 255
        )})`;
  }
  offsetHSL(e, t, n) {
    return (
      this.getHSL(hi),
      (hi.h += e),
      (hi.s += t),
      (hi.l += n),
      this.setHSL(hi.h, hi.s, hi.l),
      this
    );
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, n) {
    return (
      (this.r = e.r + (t.r - e.r) * n),
      (this.g = e.g + (t.g - e.g) * n),
      (this.b = e.b + (t.b - e.b) * n),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(hi), e.getHSL(Nl);
    const n = To(hi.h, Nl.h, t),
      i = To(hi.s, Nl.s, t),
      s = To(hi.l, Nl.l, t);
    return this.setHSL(n, i, s), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      n = this.g,
      i = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * t + s[3] * n + s[6] * i),
      (this.g = s[1] * t + s[4] * n + s[7] * i),
      (this.b = s[2] * t + s[5] * n + s[8] * i),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
};
const tn = new Ke();
Ke.NAMES = $_;
class Sr extends Pi {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new Ke(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = U_),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const Nt = new H(),
  Ol = new We();
class xn {
  constructor(e, t, n = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.normalized = n),
      (this.usage = Ih),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, n) {
    (e *= this.itemSize), (n *= t.itemSize);
    for (let i = 0, s = this.itemSize; i < s; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (this.itemSize === 2)
      for (let t = 0, n = this.count; t < n; t++)
        Ol.fromBufferAttribute(this, t),
          Ol.applyMatrix3(e),
          this.setXY(t, Ol.x, Ol.y);
    else if (this.itemSize === 3)
      for (let t = 0, n = this.count; t < n; t++)
        Nt.fromBufferAttribute(this, t),
          Nt.applyMatrix3(e),
          this.setXYZ(t, Nt.x, Nt.y, Nt.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Nt.fromBufferAttribute(this, t),
        Nt.applyMatrix4(e),
        this.setXYZ(t, Nt.x, Nt.y, Nt.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Nt.fromBufferAttribute(this, t),
        Nt.applyNormalMatrix(e),
        this.setXYZ(t, Nt.x, Nt.y, Nt.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      Nt.fromBufferAttribute(this, t),
        Nt.transformDirection(e),
        this.setXYZ(t, Nt.x, Nt.y, Nt.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Qi(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = dt(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Qi(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = dt(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Qi(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = dt(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Qi(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = dt(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, n) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = dt(t, this.array)), (n = dt(n, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = dt(t, this.array)),
        (n = dt(n, this.array)),
        (i = dt(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, n, i, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = dt(t, this.array)),
        (n = dt(n, this.array)),
        (i = dt(i, this.array)),
        (s = dt(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = n),
      (this.array[e + 2] = i),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      this.name !== "" && (e.name = this.name),
      this.usage !== Ih && (e.usage = this.usage),
      (this.updateRange.offset !== 0 || this.updateRange.count !== -1) &&
        (e.updateRange = this.updateRange),
      e
    );
  }
  copyColorsArray() {
    console.error(
      "THREE.BufferAttribute: copyColorsArray() was removed in r144."
    );
  }
  copyVector2sArray() {
    console.error(
      "THREE.BufferAttribute: copyVector2sArray() was removed in r144."
    );
  }
  copyVector3sArray() {
    console.error(
      "THREE.BufferAttribute: copyVector3sArray() was removed in r144."
    );
  }
  copyVector4sArray() {
    console.error(
      "THREE.BufferAttribute: copyVector4sArray() was removed in r144."
    );
  }
}
class Z_ extends xn {
  constructor(e, t, n) {
    super(new Uint16Array(e), t, n);
  }
}
class J_ extends xn {
  constructor(e, t, n) {
    super(new Uint32Array(e), t, n);
  }
}
class rn extends xn {
  constructor(e, t, n) {
    super(new Float32Array(e), t, n);
  }
}
let oy = 0;
const Xn = new et(),
  Ku = new Tt(),
  Ks = new H(),
  On = new hr(),
  so = new hr(),
  Wt = new H();
class xi extends Ds {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: oy++ }),
      (this.uuid = gi()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (Y_(e) ? J_ : Z_)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return this.attributes[e] !== void 0;
  }
  addGroup(e, t, n = 0) {
    this.groups.push({ start: e, count: t, materialIndex: n });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    t !== void 0 && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const n = this.attributes.normal;
    if (n !== void 0) {
      const s = new it().getNormalMatrix(e);
      n.applyNormalMatrix(s), (n.needsUpdate = !0);
    }
    const i = this.attributes.tangent;
    return (
      i !== void 0 && (i.transformDirection(e), (i.needsUpdate = !0)),
      this.boundingBox !== null && this.computeBoundingBox(),
      this.boundingSphere !== null && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return Xn.makeRotationFromQuaternion(e), this.applyMatrix4(Xn), this;
  }
  rotateX(e) {
    return Xn.makeRotationX(e), this.applyMatrix4(Xn), this;
  }
  rotateY(e) {
    return Xn.makeRotationY(e), this.applyMatrix4(Xn), this;
  }
  rotateZ(e) {
    return Xn.makeRotationZ(e), this.applyMatrix4(Xn), this;
  }
  translate(e, t, n) {
    return Xn.makeTranslation(e, t, n), this.applyMatrix4(Xn), this;
  }
  scale(e, t, n) {
    return Xn.makeScale(e, t, n), this.applyMatrix4(Xn), this;
  }
  lookAt(e) {
    return Ku.lookAt(e), Ku.updateMatrix(), this.applyMatrix4(Ku.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(Ks).negate(),
      this.translate(Ks.x, Ks.y, Ks.z),
      this
    );
  }
  setFromPoints(e) {
    const t = [];
    for (let n = 0, i = e.length; n < i; n++) {
      const s = e[n];
      t.push(s.x, s.y, s.z || 0);
    }
    return this.setAttribute("position", new rn(t, 3)), this;
  }
  computeBoundingBox() {
    this.boundingBox === null && (this.boundingBox = new hr());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingBox.set(
          new H(-1 / 0, -1 / 0, -1 / 0),
          new H(1 / 0, 1 / 0, 1 / 0)
        );
      return;
    }
    if (e !== void 0) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let n = 0, i = t.length; n < i; n++) {
          const s = t[n];
          On.setFromBufferAttribute(s),
            this.morphTargetsRelative
              ? (Wt.addVectors(this.boundingBox.min, On.min),
                this.boundingBox.expandByPoint(Wt),
                Wt.addVectors(this.boundingBox.max, On.max),
                this.boundingBox.expandByPoint(Wt))
              : (this.boundingBox.expandByPoint(On.min),
                this.boundingBox.expandByPoint(On.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    this.boundingSphere === null && (this.boundingSphere = new fr());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this
      ),
        this.boundingSphere.set(new H(), 1 / 0);
      return;
    }
    if (e) {
      const n = this.boundingSphere.center;
      if ((On.setFromBufferAttribute(e), t))
        for (let s = 0, a = t.length; s < a; s++) {
          const o = t[s];
          so.setFromBufferAttribute(o),
            this.morphTargetsRelative
              ? (Wt.addVectors(On.min, so.min),
                On.expandByPoint(Wt),
                Wt.addVectors(On.max, so.max),
                On.expandByPoint(Wt))
              : (On.expandByPoint(so.min), On.expandByPoint(so.max));
        }
      On.getCenter(n);
      let i = 0;
      for (let s = 0, a = e.count; s < a; s++)
        Wt.fromBufferAttribute(e, s),
          (i = Math.max(i, n.distanceToSquared(Wt)));
      if (t)
        for (let s = 0, a = t.length; s < a; s++) {
          const o = t[s],
            l = this.morphTargetsRelative;
          for (let c = 0, u = o.count; c < u; c++)
            Wt.fromBufferAttribute(o, c),
              l && (Ks.fromBufferAttribute(e, c), Wt.add(Ks)),
              (i = Math.max(i, n.distanceToSquared(Wt)));
        }
      (this.boundingSphere.radius = Math.sqrt(i)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      e === null ||
      t.position === void 0 ||
      t.normal === void 0 ||
      t.uv === void 0
    ) {
      console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
      return;
    }
    const n = e.array,
      i = t.position.array,
      s = t.normal.array,
      a = t.uv.array,
      o = i.length / 3;
    this.hasAttribute("tangent") === !1 &&
      this.setAttribute("tangent", new xn(new Float32Array(4 * o), 4));
    const l = this.getAttribute("tangent").array,
      c = [],
      u = [];
    for (let T = 0; T < o; T++) (c[T] = new H()), (u[T] = new H());
    const h = new H(),
      f = new H(),
      p = new H(),
      g = new We(),
      m = new We(),
      _ = new We(),
      d = new H(),
      y = new H();
    function v(T, D, N) {
      h.fromArray(i, T * 3),
        f.fromArray(i, D * 3),
        p.fromArray(i, N * 3),
        g.fromArray(a, T * 2),
        m.fromArray(a, D * 2),
        _.fromArray(a, N * 2),
        f.sub(h),
        p.sub(h),
        m.sub(g),
        _.sub(g);
      const L = 1 / (m.x * _.y - _.x * m.y);
      isFinite(L) &&
        (d
          .copy(f)
          .multiplyScalar(_.y)
          .addScaledVector(p, -m.y)
          .multiplyScalar(L),
        y
          .copy(p)
          .multiplyScalar(m.x)
          .addScaledVector(f, -_.x)
          .multiplyScalar(L),
        c[T].add(d),
        c[D].add(d),
        c[N].add(d),
        u[T].add(y),
        u[D].add(y),
        u[N].add(y));
    }
    let S = this.groups;
    S.length === 0 && (S = [{ start: 0, count: n.length }]);
    for (let T = 0, D = S.length; T < D; ++T) {
      const N = S[T],
        L = N.start,
        F = N.count;
      for (let I = L, j = L + F; I < j; I += 3) v(n[I + 0], n[I + 1], n[I + 2]);
    }
    const E = new H(),
      b = new H(),
      M = new H(),
      C = new H();
    function x(T) {
      M.fromArray(s, T * 3), C.copy(M);
      const D = c[T];
      E.copy(D),
        E.sub(M.multiplyScalar(M.dot(D))).normalize(),
        b.crossVectors(C, D);
      const L = b.dot(u[T]) < 0 ? -1 : 1;
      (l[T * 4] = E.x),
        (l[T * 4 + 1] = E.y),
        (l[T * 4 + 2] = E.z),
        (l[T * 4 + 3] = L);
    }
    for (let T = 0, D = S.length; T < D; ++T) {
      const N = S[T],
        L = N.start,
        F = N.count;
      for (let I = L, j = L + F; I < j; I += 3)
        x(n[I + 0]), x(n[I + 1]), x(n[I + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (t !== void 0) {
      let n = this.getAttribute("normal");
      if (n === void 0)
        (n = new xn(new Float32Array(t.count * 3), 3)),
          this.setAttribute("normal", n);
      else for (let f = 0, p = n.count; f < p; f++) n.setXYZ(f, 0, 0, 0);
      const i = new H(),
        s = new H(),
        a = new H(),
        o = new H(),
        l = new H(),
        c = new H(),
        u = new H(),
        h = new H();
      if (e)
        for (let f = 0, p = e.count; f < p; f += 3) {
          const g = e.getX(f + 0),
            m = e.getX(f + 1),
            _ = e.getX(f + 2);
          i.fromBufferAttribute(t, g),
            s.fromBufferAttribute(t, m),
            a.fromBufferAttribute(t, _),
            u.subVectors(a, s),
            h.subVectors(i, s),
            u.cross(h),
            o.fromBufferAttribute(n, g),
            l.fromBufferAttribute(n, m),
            c.fromBufferAttribute(n, _),
            o.add(u),
            l.add(u),
            c.add(u),
            n.setXYZ(g, o.x, o.y, o.z),
            n.setXYZ(m, l.x, l.y, l.z),
            n.setXYZ(_, c.x, c.y, c.z);
        }
      else
        for (let f = 0, p = t.count; f < p; f += 3)
          i.fromBufferAttribute(t, f + 0),
            s.fromBufferAttribute(t, f + 1),
            a.fromBufferAttribute(t, f + 2),
            u.subVectors(a, s),
            h.subVectors(i, s),
            u.cross(h),
            n.setXYZ(f + 0, u.x, u.y, u.z),
            n.setXYZ(f + 1, u.x, u.y, u.z),
            n.setXYZ(f + 2, u.x, u.y, u.z);
      this.normalizeNormals(), (n.needsUpdate = !0);
    }
  }
  merge() {
    return (
      console.error(
        "THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeGeometries() instead."
      ),
      this
    );
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, n = e.count; t < n; t++)
      Wt.fromBufferAttribute(e, t),
        Wt.normalize(),
        e.setXYZ(t, Wt.x, Wt.y, Wt.z);
  }
  toNonIndexed() {
    function e(o, l) {
      const c = o.array,
        u = o.itemSize,
        h = o.normalized,
        f = new c.constructor(l.length * u);
      let p = 0,
        g = 0;
      for (let m = 0, _ = l.length; m < _; m++) {
        o.isInterleavedBufferAttribute
          ? (p = l[m] * o.data.stride + o.offset)
          : (p = l[m] * u);
        for (let d = 0; d < u; d++) f[g++] = c[p++];
      }
      return new xn(f, u, h);
    }
    if (this.index === null)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new xi(),
      n = this.index.array,
      i = this.attributes;
    for (const o in i) {
      const l = i[o],
        c = e(l, n);
      t.setAttribute(o, c);
    }
    const s = this.morphAttributes;
    for (const o in s) {
      const l = [],
        c = s[o];
      for (let u = 0, h = c.length; u < h; u++) {
        const f = c[u],
          p = e(f, n);
        l.push(p);
      }
      t.morphAttributes[o] = l;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const a = this.groups;
    for (let o = 0, l = a.length; o < l; o++) {
      const c = a[o];
      t.addGroup(c.start, c.count, c.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      this.name !== "" && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      this.parameters !== void 0)
    ) {
      const l = this.parameters;
      for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    t !== null &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const n = this.attributes;
    for (const l in n) {
      const c = n[l];
      e.data.attributes[l] = c.toJSON(e.data);
    }
    const i = {};
    let s = !1;
    for (const l in this.morphAttributes) {
      const c = this.morphAttributes[l],
        u = [];
      for (let h = 0, f = c.length; h < f; h++) {
        const p = c[h];
        u.push(p.toJSON(e.data));
      }
      u.length > 0 && ((i[l] = u), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = i),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const a = this.groups;
    a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
    const o = this.boundingSphere;
    return (
      o !== null &&
        (e.data.boundingSphere = {
          center: o.center.toArray(),
          radius: o.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const n = e.index;
    n !== null && this.setIndex(n.clone(t));
    const i = e.attributes;
    for (const c in i) {
      const u = i[c];
      this.setAttribute(c, u.clone(t));
    }
    const s = e.morphAttributes;
    for (const c in s) {
      const u = [],
        h = s[c];
      for (let f = 0, p = h.length; f < p; f++) u.push(h[f].clone(t));
      this.morphAttributes[c] = u;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const a = e.groups;
    for (let c = 0, u = a.length; c < u; c++) {
      const h = a[c];
      this.addGroup(h.start, h.count, h.materialIndex);
    }
    const o = e.boundingBox;
    o !== null && (this.boundingBox = o.clone());
    const l = e.boundingSphere;
    return (
      l !== null && (this.boundingSphere = l.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const Mp = new et(),
  Mi = new au(),
  Ul = new fr(),
  bp = new H(),
  $s = new H(),
  Zs = new H(),
  Js = new H(),
  $u = new H(),
  Fl = new H(),
  Bl = new We(),
  kl = new We(),
  zl = new We(),
  Tp = new H(),
  Ap = new H(),
  wp = new H(),
  Hl = new H(),
  Vl = new H();
class Vn extends Tt {
  constructor(e = new xi(), t = new Sr()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.morphTargetInfluences !== void 0 &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      e.morphTargetDictionary !== void 0 &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, a = i.length; s < a; s++) {
          const o = i[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = s);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const n = this.geometry,
      i = n.attributes.position,
      s = n.morphAttributes.position,
      a = n.morphTargetsRelative;
    t.fromBufferAttribute(i, e);
    const o = this.morphTargetInfluences;
    if (s && o) {
      Fl.set(0, 0, 0);
      for (let l = 0, c = s.length; l < c; l++) {
        const u = o[l],
          h = s[l];
        u !== 0 &&
          ($u.fromBufferAttribute(h, e),
          a ? Fl.addScaledVector($u, u) : Fl.addScaledVector($u.sub(t), u));
      }
      t.add(Fl);
    }
    return t;
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.material,
      s = this.matrixWorld;
    i !== void 0 &&
      (n.boundingSphere === null && n.computeBoundingSphere(),
      Ul.copy(n.boundingSphere),
      Ul.applyMatrix4(s),
      Mi.copy(e.ray).recast(e.near),
      !(
        Ul.containsPoint(Mi.origin) === !1 &&
        (Mi.intersectSphere(Ul, bp) === null ||
          Mi.origin.distanceToSquared(bp) > (e.far - e.near) ** 2)
      ) &&
        (Mp.copy(s).invert(),
        Mi.copy(e.ray).applyMatrix4(Mp),
        !(n.boundingBox !== null && Mi.intersectsBox(n.boundingBox) === !1) &&
          this._computeIntersections(e, t)));
  }
  _computeIntersections(e, t) {
    let n;
    const i = this.geometry,
      s = this.material,
      a = i.index,
      o = i.attributes.position,
      l = i.attributes.uv,
      c = i.attributes.uv1,
      u = i.attributes.normal,
      h = i.groups,
      f = i.drawRange;
    if (a !== null)
      if (Array.isArray(s))
        for (let p = 0, g = h.length; p < g; p++) {
          const m = h[p],
            _ = s[m.materialIndex],
            d = Math.max(m.start, f.start),
            y = Math.min(
              a.count,
              Math.min(m.start + m.count, f.start + f.count)
            );
          for (let v = d, S = y; v < S; v += 3) {
            const E = a.getX(v),
              b = a.getX(v + 1),
              M = a.getX(v + 2);
            (n = Gl(this, _, e, Mi, l, c, u, E, b, M)),
              n &&
                ((n.faceIndex = Math.floor(v / 3)),
                (n.face.materialIndex = m.materialIndex),
                t.push(n));
          }
        }
      else {
        const p = Math.max(0, f.start),
          g = Math.min(a.count, f.start + f.count);
        for (let m = p, _ = g; m < _; m += 3) {
          const d = a.getX(m),
            y = a.getX(m + 1),
            v = a.getX(m + 2);
          (n = Gl(this, s, e, Mi, l, c, u, d, y, v)),
            n && ((n.faceIndex = Math.floor(m / 3)), t.push(n));
        }
      }
    else if (o !== void 0)
      if (Array.isArray(s))
        for (let p = 0, g = h.length; p < g; p++) {
          const m = h[p],
            _ = s[m.materialIndex],
            d = Math.max(m.start, f.start),
            y = Math.min(
              o.count,
              Math.min(m.start + m.count, f.start + f.count)
            );
          for (let v = d, S = y; v < S; v += 3) {
            const E = v,
              b = v + 1,
              M = v + 2;
            (n = Gl(this, _, e, Mi, l, c, u, E, b, M)),
              n &&
                ((n.faceIndex = Math.floor(v / 3)),
                (n.face.materialIndex = m.materialIndex),
                t.push(n));
          }
        }
      else {
        const p = Math.max(0, f.start),
          g = Math.min(o.count, f.start + f.count);
        for (let m = p, _ = g; m < _; m += 3) {
          const d = m,
            y = m + 1,
            v = m + 2;
          (n = Gl(this, s, e, Mi, l, c, u, d, y, v)),
            n && ((n.faceIndex = Math.floor(m / 3)), t.push(n));
        }
      }
  }
}
function ly(r, e, t, n, i, s, a, o) {
  let l;
  if (
    (e.side === bn
      ? (l = n.intersectTriangle(a, s, i, !0, o))
      : (l = n.intersectTriangle(i, s, a, e.side === or, o)),
    l === null)
  )
    return null;
  Vl.copy(o), Vl.applyMatrix4(r.matrixWorld);
  const c = t.ray.origin.distanceTo(Vl);
  return c < t.near || c > t.far
    ? null
    : { distance: c, point: Vl.clone(), object: r };
}
function Gl(r, e, t, n, i, s, a, o, l, c) {
  r.getVertexPosition(o, $s),
    r.getVertexPosition(l, Zs),
    r.getVertexPosition(c, Js);
  const u = ly(r, e, t, n, $s, Zs, Js, Hl);
  if (u) {
    i &&
      (Bl.fromBufferAttribute(i, o),
      kl.fromBufferAttribute(i, l),
      zl.fromBufferAttribute(i, c),
      (u.uv = di.getInterpolation(Hl, $s, Zs, Js, Bl, kl, zl, new We()))),
      s &&
        (Bl.fromBufferAttribute(s, o),
        kl.fromBufferAttribute(s, l),
        zl.fromBufferAttribute(s, c),
        (u.uv1 = di.getInterpolation(Hl, $s, Zs, Js, Bl, kl, zl, new We())),
        (u.uv2 = u.uv1)),
      a &&
        (Tp.fromBufferAttribute(a, o),
        Ap.fromBufferAttribute(a, l),
        wp.fromBufferAttribute(a, c),
        (u.normal = di.getInterpolation(Hl, $s, Zs, Js, Tp, Ap, wp, new H())),
        u.normal.dot(n.direction) > 0 && u.normal.multiplyScalar(-1));
    const h = { a: o, b: l, c, normal: new H(), materialIndex: 0 };
    di.getNormal($s, Zs, Js, h.normal), (u.face = h);
  }
  return u;
}
class fl extends xi {
  constructor(e = 1, t = 1, n = 1, i = 1, s = 1, a = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: n,
        widthSegments: i,
        heightSegments: s,
        depthSegments: a,
      });
    const o = this;
    (i = Math.floor(i)), (s = Math.floor(s)), (a = Math.floor(a));
    const l = [],
      c = [],
      u = [],
      h = [];
    let f = 0,
      p = 0;
    g("z", "y", "x", -1, -1, n, t, e, a, s, 0),
      g("z", "y", "x", 1, -1, n, t, -e, a, s, 1),
      g("x", "z", "y", 1, 1, e, n, t, i, a, 2),
      g("x", "z", "y", 1, -1, e, n, -t, i, a, 3),
      g("x", "y", "z", 1, -1, e, t, n, i, s, 4),
      g("x", "y", "z", -1, -1, e, t, -n, i, s, 5),
      this.setIndex(l),
      this.setAttribute("position", new rn(c, 3)),
      this.setAttribute("normal", new rn(u, 3)),
      this.setAttribute("uv", new rn(h, 2));
    function g(m, _, d, y, v, S, E, b, M, C, x) {
      const T = S / M,
        D = E / C,
        N = S / 2,
        L = E / 2,
        F = b / 2,
        I = M + 1,
        j = C + 1;
      let A = 0,
        k = 0;
      const G = new H();
      for (let z = 0; z < j; z++) {
        const oe = z * D - L;
        for (let te = 0; te < I; te++) {
          const X = te * T - N;
          (G[m] = X * y),
            (G[_] = oe * v),
            (G[d] = F),
            c.push(G.x, G.y, G.z),
            (G[m] = 0),
            (G[_] = 0),
            (G[d] = b > 0 ? 1 : -1),
            u.push(G.x, G.y, G.z),
            h.push(te / M),
            h.push(1 - z / C),
            (A += 1);
        }
      }
      for (let z = 0; z < C; z++)
        for (let oe = 0; oe < M; oe++) {
          const te = f + oe + I * z,
            X = f + oe + I * (z + 1),
            Y = f + (oe + 1) + I * (z + 1),
            le = f + (oe + 1) + I * z;
          l.push(te, X, le), l.push(X, Y, le), (k += 6);
        }
      o.addGroup(p, k, x), (p += k), (f += A);
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new fl(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}
function ka(r) {
  const e = {};
  for (const t in r) {
    e[t] = {};
    for (const n in r[t]) {
      const i = r[t][n];
      i &&
      (i.isColor ||
        i.isMatrix3 ||
        i.isMatrix4 ||
        i.isVector2 ||
        i.isVector3 ||
        i.isVector4 ||
        i.isTexture ||
        i.isQuaternion)
        ? i.isRenderTargetTexture
          ? (console.warn(
              "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
            ),
            (e[t][n] = null))
          : (e[t][n] = i.clone())
        : Array.isArray(i)
        ? (e[t][n] = i.slice())
        : (e[t][n] = i);
    }
  }
  return e;
}
function hn(r) {
  const e = {};
  for (let t = 0; t < r.length; t++) {
    const n = ka(r[t]);
    for (const i in n) e[i] = n[i];
  }
  return e;
}
function cy(r) {
  const e = [];
  for (let t = 0; t < r.length; t++) e.push(r[t].clone());
  return e;
}
function Q_(r) {
  return r.getRenderTarget() === null ? r.outputColorSpace : Ii;
}
const uy = { clone: ka, merge: hn };
var hy = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
  fy = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Ir extends Pi {
  constructor(e) {
    super(),
      (this.isShaderMaterial = !0),
      (this.type = "ShaderMaterial"),
      (this.defines = {}),
      (this.uniforms = {}),
      (this.uniformsGroups = []),
      (this.vertexShader = hy),
      (this.fragmentShader = fy),
      (this.linewidth = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.fog = !1),
      (this.lights = !1),
      (this.clipping = !1),
      (this.forceSinglePass = !0),
      (this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1,
      }),
      (this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv1: [0, 0],
      }),
      (this.index0AttributeName = void 0),
      (this.uniformsNeedUpdate = !1),
      (this.glslVersion = null),
      e !== void 0 && this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.fragmentShader = e.fragmentShader),
      (this.vertexShader = e.vertexShader),
      (this.uniforms = ka(e.uniforms)),
      (this.uniformsGroups = cy(e.uniformsGroups)),
      (this.defines = Object.assign({}, e.defines)),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.fog = e.fog),
      (this.lights = e.lights),
      (this.clipping = e.clipping),
      (this.extensions = Object.assign({}, e.extensions)),
      (this.glslVersion = e.glslVersion),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    (t.glslVersion = this.glslVersion), (t.uniforms = {});
    for (const i in this.uniforms) {
      const a = this.uniforms[i].value;
      a && a.isTexture
        ? (t.uniforms[i] = { type: "t", value: a.toJSON(e).uuid })
        : a && a.isColor
        ? (t.uniforms[i] = { type: "c", value: a.getHex() })
        : a && a.isVector2
        ? (t.uniforms[i] = { type: "v2", value: a.toArray() })
        : a && a.isVector3
        ? (t.uniforms[i] = { type: "v3", value: a.toArray() })
        : a && a.isVector4
        ? (t.uniforms[i] = { type: "v4", value: a.toArray() })
        : a && a.isMatrix3
        ? (t.uniforms[i] = { type: "m3", value: a.toArray() })
        : a && a.isMatrix4
        ? (t.uniforms[i] = { type: "m4", value: a.toArray() })
        : (t.uniforms[i] = { value: a });
    }
    Object.keys(this.defines).length > 0 && (t.defines = this.defines),
      (t.vertexShader = this.vertexShader),
      (t.fragmentShader = this.fragmentShader),
      (t.lights = this.lights),
      (t.clipping = this.clipping);
    const n = {};
    for (const i in this.extensions) this.extensions[i] === !0 && (n[i] = !0);
    return Object.keys(n).length > 0 && (t.extensions = n), t;
  }
}
class eg extends Tt {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new et()),
      (this.projectionMatrix = new et()),
      (this.projectionMatrixInverse = new et());
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      this
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class mn extends eg {
  constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = n),
      (this.far = i),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = Ba * 2 * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(bo * 0.5 * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return Ba * 2 * Math.atan(Math.tan(bo * 0.5 * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, t, n, i, s, a) {
    (this.aspect = e / t),
      this.view === null &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = s),
      (this.view.height = a),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(bo * 0.5 * this.fov)) / this.zoom,
      n = 2 * t,
      i = this.aspect * n,
      s = -0.5 * i;
    const a = this.view;
    if (this.view !== null && this.view.enabled) {
      const l = a.fullWidth,
        c = a.fullHeight;
      (s += (a.offsetX * i) / l),
        (t -= (a.offsetY * n) / c),
        (i *= a.width / l),
        (n *= a.height / c);
    }
    const o = this.filmOffset;
    o !== 0 && (s += (e * o) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(s, s + i, t, t - n, e, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const Qs = -90,
  ea = 1;
class dy extends Tt {
  constructor(e, t, n) {
    super(), (this.type = "CubeCamera"), (this.renderTarget = n);
    const i = new mn(Qs, ea, e, t);
    (i.layers = this.layers), i.up.set(0, 1, 0), i.lookAt(1, 0, 0), this.add(i);
    const s = new mn(Qs, ea, e, t);
    (s.layers = this.layers),
      s.up.set(0, 1, 0),
      s.lookAt(-1, 0, 0),
      this.add(s);
    const a = new mn(Qs, ea, e, t);
    (a.layers = this.layers),
      a.up.set(0, 0, -1),
      a.lookAt(0, 1, 0),
      this.add(a);
    const o = new mn(Qs, ea, e, t);
    (o.layers = this.layers),
      o.up.set(0, 0, 1),
      o.lookAt(0, -1, 0),
      this.add(o);
    const l = new mn(Qs, ea, e, t);
    (l.layers = this.layers), l.up.set(0, 1, 0), l.lookAt(0, 0, 1), this.add(l);
    const c = new mn(Qs, ea, e, t);
    (c.layers = this.layers),
      c.up.set(0, 1, 0),
      c.lookAt(0, 0, -1),
      this.add(c);
  }
  update(e, t) {
    this.parent === null && this.updateMatrixWorld();
    const n = this.renderTarget,
      [i, s, a, o, l, c] = this.children,
      u = e.getRenderTarget(),
      h = e.toneMapping,
      f = e.xr.enabled;
    (e.toneMapping = rr), (e.xr.enabled = !1);
    const p = n.texture.generateMipmaps;
    (n.texture.generateMipmaps = !1),
      e.setRenderTarget(n, 0),
      e.render(t, i),
      e.setRenderTarget(n, 1),
      e.render(t, s),
      e.setRenderTarget(n, 2),
      e.render(t, a),
      e.setRenderTarget(n, 3),
      e.render(t, o),
      e.setRenderTarget(n, 4),
      e.render(t, l),
      (n.texture.generateMipmaps = p),
      e.setRenderTarget(n, 5),
      e.render(t, c),
      e.setRenderTarget(u),
      (e.toneMapping = h),
      (e.xr.enabled = f),
      (n.texture.needsPMREMUpdate = !0);
  }
}
class tg extends Qt {
  constructor(e, t, n, i, s, a, o, l, c, u) {
    (e = e !== void 0 ? e : []),
      (t = t !== void 0 ? t : Ia),
      super(e, t, n, i, s, a, o, l, c, u),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class py extends bs {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const n = { width: e, height: e, depth: 1 },
      i = [n, n, n, n, n, n];
    t.encoding !== void 0 &&
      (Ao(
        "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (t.colorSpace = t.encoding === fs ? Ve : ds)),
      (this.texture = new tg(
        i,
        t.mapping,
        t.wrapS,
        t.wrapT,
        t.magFilter,
        t.minFilter,
        t.format,
        t.type,
        t.anisotropy,
        t.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        t.generateMipmaps !== void 0 ? t.generateMipmaps : !1),
      (this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Sn);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const n = {
        uniforms: { tEquirect: { value: null } },
        vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
        fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
      },
      i = new fl(5, 5, 5),
      s = new Ir({
        name: "CubemapFromEquirect",
        uniforms: ka(n.uniforms),
        vertexShader: n.vertexShader,
        fragmentShader: n.fragmentShader,
        side: bn,
        blending: Cr,
      });
    s.uniforms.tEquirect.value = t;
    const a = new Vn(i, s),
      o = t.minFilter;
    return (
      t.minFilter === Ss && (t.minFilter = Sn),
      new dy(1, 10, this).update(e, a),
      (t.minFilter = o),
      a.geometry.dispose(),
      a.material.dispose(),
      this
    );
  }
  clear(e, t, n, i) {
    const s = e.getRenderTarget();
    for (let a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(t, n, i);
    e.setRenderTarget(s);
  }
}
const Zu = new H(),
  my = new H(),
  _y = new it();
class ts {
  constructor(e = new H(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, n, i) {
    return this.normal.set(e, t, n), (this.constant = i), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, n) {
    const i = Zu.subVectors(n, t).cross(my.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(i, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const n = e.delta(Zu),
      i = this.normal.dot(n);
    if (i === 0)
      return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / i;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(n, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      n = this.distanceToPoint(e.end);
    return (t < 0 && n > 0) || (n < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const n = t || _y.getNormalMatrix(e),
      i = this.coplanarPoint(Zu).applyMatrix4(e),
      s = this.normal.applyMatrix3(n).normalize();
    return (this.constant = -i.dot(s)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Zr = new fr(),
  Wl = new H();
class Cf {
  constructor(
    e = new ts(),
    t = new ts(),
    n = new ts(),
    i = new ts(),
    s = new ts(),
    a = new ts()
  ) {
    this.planes = [e, t, n, i, s, a];
  }
  set(e, t, n, i, s, a) {
    const o = this.planes;
    return (
      o[0].copy(e),
      o[1].copy(t),
      o[2].copy(n),
      o[3].copy(i),
      o[4].copy(s),
      o[5].copy(a),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
    return this;
  }
  setFromProjectionMatrix(e) {
    const t = this.planes,
      n = e.elements,
      i = n[0],
      s = n[1],
      a = n[2],
      o = n[3],
      l = n[4],
      c = n[5],
      u = n[6],
      h = n[7],
      f = n[8],
      p = n[9],
      g = n[10],
      m = n[11],
      _ = n[12],
      d = n[13],
      y = n[14],
      v = n[15];
    return (
      t[0].setComponents(o - i, h - l, m - f, v - _).normalize(),
      t[1].setComponents(o + i, h + l, m + f, v + _).normalize(),
      t[2].setComponents(o + s, h + c, m + p, v + d).normalize(),
      t[3].setComponents(o - s, h - c, m - p, v - d).normalize(),
      t[4].setComponents(o - a, h - u, m - g, v - y).normalize(),
      t[5].setComponents(o + a, h + u, m + g, v + y).normalize(),
      this
    );
  }
  intersectsObject(e) {
    if (e.boundingSphere !== void 0)
      e.boundingSphere === null && e.computeBoundingSphere(),
        Zr.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      t.boundingSphere === null && t.computeBoundingSphere(),
        Zr.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Zr);
  }
  intersectsSprite(e) {
    return (
      Zr.center.set(0, 0, 0),
      (Zr.radius = 0.7071067811865476),
      Zr.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Zr)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      n = e.center,
      i = -e.radius;
    for (let s = 0; s < 6; s++) if (t[s].distanceToPoint(n) < i) return !1;
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) {
      const i = t[n];
      if (
        ((Wl.x = i.normal.x > 0 ? e.max.x : e.min.x),
        (Wl.y = i.normal.y > 0 ? e.max.y : e.min.y),
        (Wl.z = i.normal.z > 0 ? e.max.z : e.min.z),
        i.distanceToPoint(Wl) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let n = 0; n < 6; n++) if (t[n].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function ng() {
  let r = null,
    e = !1,
    t = null,
    n = null;
  function i(s, a) {
    t(s, a), (n = r.requestAnimationFrame(i));
  }
  return {
    start: function () {
      e !== !0 && t !== null && ((n = r.requestAnimationFrame(i)), (e = !0));
    },
    stop: function () {
      r.cancelAnimationFrame(n), (e = !1);
    },
    setAnimationLoop: function (s) {
      t = s;
    },
    setContext: function (s) {
      r = s;
    },
  };
}
function gy(r, e) {
  const t = e.isWebGL2,
    n = new WeakMap();
  function i(c, u) {
    const h = c.array,
      f = c.usage,
      p = r.createBuffer();
    r.bindBuffer(u, p), r.bufferData(u, h, f), c.onUploadCallback();
    let g;
    if (h instanceof Float32Array) g = r.FLOAT;
    else if (h instanceof Uint16Array)
      if (c.isFloat16BufferAttribute)
        if (t) g = r.HALF_FLOAT;
        else
          throw new Error(
            "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
          );
      else g = r.UNSIGNED_SHORT;
    else if (h instanceof Int16Array) g = r.SHORT;
    else if (h instanceof Uint32Array) g = r.UNSIGNED_INT;
    else if (h instanceof Int32Array) g = r.INT;
    else if (h instanceof Int8Array) g = r.BYTE;
    else if (h instanceof Uint8Array) g = r.UNSIGNED_BYTE;
    else if (h instanceof Uint8ClampedArray) g = r.UNSIGNED_BYTE;
    else
      throw new Error(
        "THREE.WebGLAttributes: Unsupported buffer data format: " + h
      );
    return {
      buffer: p,
      type: g,
      bytesPerElement: h.BYTES_PER_ELEMENT,
      version: c.version,
    };
  }
  function s(c, u, h) {
    const f = u.array,
      p = u.updateRange;
    r.bindBuffer(h, c),
      p.count === -1
        ? r.bufferSubData(h, 0, f)
        : (t
            ? r.bufferSubData(
                h,
                p.offset * f.BYTES_PER_ELEMENT,
                f,
                p.offset,
                p.count
              )
            : r.bufferSubData(
                h,
                p.offset * f.BYTES_PER_ELEMENT,
                f.subarray(p.offset, p.offset + p.count)
              ),
          (p.count = -1)),
      u.onUploadCallback();
  }
  function a(c) {
    return c.isInterleavedBufferAttribute && (c = c.data), n.get(c);
  }
  function o(c) {
    c.isInterleavedBufferAttribute && (c = c.data);
    const u = n.get(c);
    u && (r.deleteBuffer(u.buffer), n.delete(c));
  }
  function l(c, u) {
    if (c.isGLBufferAttribute) {
      const f = n.get(c);
      (!f || f.version < c.version) &&
        n.set(c, {
          buffer: c.buffer,
          type: c.type,
          bytesPerElement: c.elementSize,
          version: c.version,
        });
      return;
    }
    c.isInterleavedBufferAttribute && (c = c.data);
    const h = n.get(c);
    h === void 0
      ? n.set(c, i(c, u))
      : h.version < c.version && (s(h.buffer, c, u), (h.version = c.version));
  }
  return { get: a, remove: o, update: l };
}
class lu extends xi {
  constructor(e = 1, t = 1, n = 1, i = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: n,
        heightSegments: i,
      });
    const s = e / 2,
      a = t / 2,
      o = Math.floor(n),
      l = Math.floor(i),
      c = o + 1,
      u = l + 1,
      h = e / o,
      f = t / l,
      p = [],
      g = [],
      m = [],
      _ = [];
    for (let d = 0; d < u; d++) {
      const y = d * f - a;
      for (let v = 0; v < c; v++) {
        const S = v * h - s;
        g.push(S, -y, 0), m.push(0, 0, 1), _.push(v / o), _.push(1 - d / l);
      }
    }
    for (let d = 0; d < l; d++)
      for (let y = 0; y < o; y++) {
        const v = y + c * d,
          S = y + c * (d + 1),
          E = y + 1 + c * (d + 1),
          b = y + 1 + c * d;
        p.push(v, S, b), p.push(S, E, b);
      }
    this.setIndex(p),
      this.setAttribute("position", new rn(g, 3)),
      this.setAttribute("normal", new rn(m, 3)),
      this.setAttribute("uv", new rn(_, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new lu(e.width, e.height, e.widthSegments, e.heightSegments);
  }
}
var vy = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
  xy = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  yy = `#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,
  Ey = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
  Sy = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
  My = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
  by = "vec3 transformed = vec3( position );",
  Ty = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
  Ay = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
  wy = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			 return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float R21 = R12;
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
  Ry = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = dFdx( surf_pos.xyz );
		vec3 vSigmaY = dFdy( surf_pos.xyz );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
  Cy = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,
  Py = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
  Ly = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
  Dy = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
  Iy = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
  Ny = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
  Oy = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,
  Uy = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,
  Fy = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
  By = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
  ky = `vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
  zy = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
  Hy = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
  Vy = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
  Gy = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
  Wy = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
  Xy = `vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
  Yy = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
  qy = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
  jy = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
  Ky = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
  $y = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
  Zy = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
  Jy = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
  Qy = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
  eE = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
  tE = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
  nE = `#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,
  iE = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
  rE = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
  sE = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
  aE = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
  oE = `#if defined( USE_ENVMAP )
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,
  lE = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
  cE = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
  uE = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
  hE = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
  fE = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif`,
  dE = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec3 sheenSpecular = vec3( 0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
  pE = `
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometry.viewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
  mE = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
  _E = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,
  gE = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
  vE = `#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
  xE = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,
  yE = `#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,
  EE = `#ifdef USE_MAP
	diffuseColor *= texture2D( map, vMapUv );
#endif`,
  SE = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
  ME = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
  bE = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
  TE = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
  AE = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
  wE = `#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
  RE = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,
  CE = `#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,
  PE = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,
  LE = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#ifdef USE_NORMALMAP_TANGENTSPACE
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal, vNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 geometryNormal = normal;`,
  DE = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
  IE = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  NE = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
  OE = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
  UE = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
  FE = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,
  BE = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
  kE = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
  zE = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
  HE = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
  VE = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
  GE = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
  WE = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
  XE = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
  YE = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
  qE = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
  jE = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
  KE = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,
  $E = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
  ZE = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
  JE = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
  QE = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
  eS = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,
  tS = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
  nS = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
  iS = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
  rS = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
  sS = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
  aS = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
  oS = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmission.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
#endif`,
  lS = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,
  cS = `#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  uS = `#ifdef USE_UV
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
  hS = `#ifdef USE_UV
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
  fS = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const dS = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
  pS = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  mS = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  _S = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  gS = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
  vS = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  xS = `#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
  yS = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,
  ES = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
  SS = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
  MS = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
  bS = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,
  TS = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  AS = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  wS = `#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
  RS = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  CS = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  PS = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  LS = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
  DS = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  IS = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
  NS = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
  OS = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  US = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  FS = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
  BS = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  kS = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  zS = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
  HS = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
  VS = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
  GS = `#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
  WS = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  XS = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
  YS = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,
  Ze = {
    alphamap_fragment: vy,
    alphamap_pars_fragment: xy,
    alphatest_fragment: yy,
    alphatest_pars_fragment: Ey,
    aomap_fragment: Sy,
    aomap_pars_fragment: My,
    begin_vertex: by,
    beginnormal_vertex: Ty,
    bsdfs: Ay,
    iridescence_fragment: wy,
    bumpmap_pars_fragment: Ry,
    clipping_planes_fragment: Cy,
    clipping_planes_pars_fragment: Py,
    clipping_planes_pars_vertex: Ly,
    clipping_planes_vertex: Dy,
    color_fragment: Iy,
    color_pars_fragment: Ny,
    color_pars_vertex: Oy,
    color_vertex: Uy,
    common: Fy,
    cube_uv_reflection_fragment: By,
    defaultnormal_vertex: ky,
    displacementmap_pars_vertex: zy,
    displacementmap_vertex: Hy,
    emissivemap_fragment: Vy,
    emissivemap_pars_fragment: Gy,
    encodings_fragment: Wy,
    encodings_pars_fragment: Xy,
    envmap_fragment: Yy,
    envmap_common_pars_fragment: qy,
    envmap_pars_fragment: jy,
    envmap_pars_vertex: Ky,
    envmap_physical_pars_fragment: oE,
    envmap_vertex: $y,
    fog_vertex: Zy,
    fog_pars_vertex: Jy,
    fog_fragment: Qy,
    fog_pars_fragment: eE,
    gradientmap_pars_fragment: tE,
    lightmap_fragment: nE,
    lightmap_pars_fragment: iE,
    lights_lambert_fragment: rE,
    lights_lambert_pars_fragment: sE,
    lights_pars_begin: aE,
    lights_toon_fragment: lE,
    lights_toon_pars_fragment: cE,
    lights_phong_fragment: uE,
    lights_phong_pars_fragment: hE,
    lights_physical_fragment: fE,
    lights_physical_pars_fragment: dE,
    lights_fragment_begin: pE,
    lights_fragment_maps: mE,
    lights_fragment_end: _E,
    logdepthbuf_fragment: gE,
    logdepthbuf_pars_fragment: vE,
    logdepthbuf_pars_vertex: xE,
    logdepthbuf_vertex: yE,
    map_fragment: EE,
    map_pars_fragment: SE,
    map_particle_fragment: ME,
    map_particle_pars_fragment: bE,
    metalnessmap_fragment: TE,
    metalnessmap_pars_fragment: AE,
    morphcolor_vertex: wE,
    morphnormal_vertex: RE,
    morphtarget_pars_vertex: CE,
    morphtarget_vertex: PE,
    normal_fragment_begin: LE,
    normal_fragment_maps: DE,
    normal_pars_fragment: IE,
    normal_pars_vertex: NE,
    normal_vertex: OE,
    normalmap_pars_fragment: UE,
    clearcoat_normal_fragment_begin: FE,
    clearcoat_normal_fragment_maps: BE,
    clearcoat_pars_fragment: kE,
    iridescence_pars_fragment: zE,
    output_fragment: HE,
    packing: VE,
    premultiplied_alpha_fragment: GE,
    project_vertex: WE,
    dithering_fragment: XE,
    dithering_pars_fragment: YE,
    roughnessmap_fragment: qE,
    roughnessmap_pars_fragment: jE,
    shadowmap_pars_fragment: KE,
    shadowmap_pars_vertex: $E,
    shadowmap_vertex: ZE,
    shadowmask_pars_fragment: JE,
    skinbase_vertex: QE,
    skinning_pars_vertex: eS,
    skinning_vertex: tS,
    skinnormal_vertex: nS,
    specularmap_fragment: iS,
    specularmap_pars_fragment: rS,
    tonemapping_fragment: sS,
    tonemapping_pars_fragment: aS,
    transmission_fragment: oS,
    transmission_pars_fragment: lS,
    uv_pars_fragment: cS,
    uv_pars_vertex: uS,
    uv_vertex: hS,
    worldpos_vertex: fS,
    background_vert: dS,
    background_frag: pS,
    backgroundCube_vert: mS,
    backgroundCube_frag: _S,
    cube_vert: gS,
    cube_frag: vS,
    depth_vert: xS,
    depth_frag: yS,
    distanceRGBA_vert: ES,
    distanceRGBA_frag: SS,
    equirect_vert: MS,
    equirect_frag: bS,
    linedashed_vert: TS,
    linedashed_frag: AS,
    meshbasic_vert: wS,
    meshbasic_frag: RS,
    meshlambert_vert: CS,
    meshlambert_frag: PS,
    meshmatcap_vert: LS,
    meshmatcap_frag: DS,
    meshnormal_vert: IS,
    meshnormal_frag: NS,
    meshphong_vert: OS,
    meshphong_frag: US,
    meshphysical_vert: FS,
    meshphysical_frag: BS,
    meshtoon_vert: kS,
    meshtoon_frag: zS,
    points_vert: HS,
    points_frag: VS,
    shadow_vert: GS,
    shadow_frag: WS,
    sprite_vert: XS,
    sprite_frag: YS,
  },
  Ee = {
    common: {
      diffuse: { value: new Ke(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new it() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new it() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new it() },
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new it() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new it() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new it() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new it() },
      normalScale: { value: new We(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new it() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new it() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new it() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new it() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Ke(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Ke(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
      uvTransform: { value: new it() },
    },
    sprite: {
      diffuse: { value: new Ke(16777215) },
      opacity: { value: 1 },
      center: { value: new We(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new it() },
      alphaMap: { value: null },
      alphaTest: { value: 0 },
    },
  },
  Ai = {
    basic: {
      uniforms: hn([
        Ee.common,
        Ee.specularmap,
        Ee.envmap,
        Ee.aomap,
        Ee.lightmap,
        Ee.fog,
      ]),
      vertexShader: Ze.meshbasic_vert,
      fragmentShader: Ze.meshbasic_frag,
    },
    lambert: {
      uniforms: hn([
        Ee.common,
        Ee.specularmap,
        Ee.envmap,
        Ee.aomap,
        Ee.lightmap,
        Ee.emissivemap,
        Ee.bumpmap,
        Ee.normalmap,
        Ee.displacementmap,
        Ee.fog,
        Ee.lights,
        { emissive: { value: new Ke(0) } },
      ]),
      vertexShader: Ze.meshlambert_vert,
      fragmentShader: Ze.meshlambert_frag,
    },
    phong: {
      uniforms: hn([
        Ee.common,
        Ee.specularmap,
        Ee.envmap,
        Ee.aomap,
        Ee.lightmap,
        Ee.emissivemap,
        Ee.bumpmap,
        Ee.normalmap,
        Ee.displacementmap,
        Ee.fog,
        Ee.lights,
        {
          emissive: { value: new Ke(0) },
          specular: { value: new Ke(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: Ze.meshphong_vert,
      fragmentShader: Ze.meshphong_frag,
    },
    standard: {
      uniforms: hn([
        Ee.common,
        Ee.envmap,
        Ee.aomap,
        Ee.lightmap,
        Ee.emissivemap,
        Ee.bumpmap,
        Ee.normalmap,
        Ee.displacementmap,
        Ee.roughnessmap,
        Ee.metalnessmap,
        Ee.fog,
        Ee.lights,
        {
          emissive: { value: new Ke(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: Ze.meshphysical_vert,
      fragmentShader: Ze.meshphysical_frag,
    },
    toon: {
      uniforms: hn([
        Ee.common,
        Ee.aomap,
        Ee.lightmap,
        Ee.emissivemap,
        Ee.bumpmap,
        Ee.normalmap,
        Ee.displacementmap,
        Ee.gradientmap,
        Ee.fog,
        Ee.lights,
        { emissive: { value: new Ke(0) } },
      ]),
      vertexShader: Ze.meshtoon_vert,
      fragmentShader: Ze.meshtoon_frag,
    },
    matcap: {
      uniforms: hn([
        Ee.common,
        Ee.bumpmap,
        Ee.normalmap,
        Ee.displacementmap,
        Ee.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: Ze.meshmatcap_vert,
      fragmentShader: Ze.meshmatcap_frag,
    },
    points: {
      uniforms: hn([Ee.points, Ee.fog]),
      vertexShader: Ze.points_vert,
      fragmentShader: Ze.points_frag,
    },
    dashed: {
      uniforms: hn([
        Ee.common,
        Ee.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: Ze.linedashed_vert,
      fragmentShader: Ze.linedashed_frag,
    },
    depth: {
      uniforms: hn([Ee.common, Ee.displacementmap]),
      vertexShader: Ze.depth_vert,
      fragmentShader: Ze.depth_frag,
    },
    normal: {
      uniforms: hn([
        Ee.common,
        Ee.bumpmap,
        Ee.normalmap,
        Ee.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: Ze.meshnormal_vert,
      fragmentShader: Ze.meshnormal_frag,
    },
    sprite: {
      uniforms: hn([Ee.sprite, Ee.fog]),
      vertexShader: Ze.sprite_vert,
      fragmentShader: Ze.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new it() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Ze.background_vert,
      fragmentShader: Ze.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: Ze.backgroundCube_vert,
      fragmentShader: Ze.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: Ze.cube_vert,
      fragmentShader: Ze.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: Ze.equirect_vert,
      fragmentShader: Ze.equirect_frag,
    },
    distanceRGBA: {
      uniforms: hn([
        Ee.common,
        Ee.displacementmap,
        {
          referencePosition: { value: new H() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: Ze.distanceRGBA_vert,
      fragmentShader: Ze.distanceRGBA_frag,
    },
    shadow: {
      uniforms: hn([
        Ee.lights,
        Ee.fog,
        { color: { value: new Ke(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: Ze.shadow_vert,
      fragmentShader: Ze.shadow_frag,
    },
  };
Ai.physical = {
  uniforms: hn([
    Ai.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new it() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new it() },
      clearcoatNormalScale: { value: new We(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new it() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new it() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new it() },
      sheen: { value: 0 },
      sheenColor: { value: new Ke(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new it() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new it() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new it() },
      transmissionSamplerSize: { value: new We() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new it() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Ke(0) },
      specularColor: { value: new Ke(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new it() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new it() },
    },
  ]),
  vertexShader: Ze.meshphysical_vert,
  fragmentShader: Ze.meshphysical_frag,
};
const Xl = { r: 0, b: 0, g: 0 };
function qS(r, e, t, n, i, s, a) {
  const o = new Ke(0);
  let l = s === !0 ? 0 : 1,
    c,
    u,
    h = null,
    f = 0,
    p = null;
  function g(_, d) {
    let y = !1,
      v = d.isScene === !0 ? d.background : null;
    switch (
      (v && v.isTexture && (v = (d.backgroundBlurriness > 0 ? t : e).get(v)),
      v === null ? m(o, l) : v && v.isColor && (m(v, 1), (y = !0)),
      r.xr.getEnvironmentBlendMode())
    ) {
      case "opaque":
        y = !0;
        break;
      case "additive":
        n.buffers.color.setClear(0, 0, 0, 1, a), (y = !0);
        break;
      case "alpha-blend":
        n.buffers.color.setClear(0, 0, 0, 0, a), (y = !0);
        break;
    }
    (r.autoClear || y) &&
      r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil),
      v && (v.isCubeTexture || v.mapping === su)
        ? (u === void 0 &&
            ((u = new Vn(
              new fl(1, 1, 1),
              new Ir({
                name: "BackgroundCubeMaterial",
                uniforms: ka(Ai.backgroundCube.uniforms),
                vertexShader: Ai.backgroundCube.vertexShader,
                fragmentShader: Ai.backgroundCube.fragmentShader,
                side: bn,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            u.geometry.deleteAttribute("normal"),
            u.geometry.deleteAttribute("uv"),
            (u.onBeforeRender = function (b, M, C) {
              this.matrixWorld.copyPosition(C.matrixWorld);
            }),
            Object.defineProperty(u.material, "envMap", {
              get: function () {
                return this.uniforms.envMap.value;
              },
            }),
            i.update(u)),
          (u.material.uniforms.envMap.value = v),
          (u.material.uniforms.flipEnvMap.value =
            v.isCubeTexture && v.isRenderTargetTexture === !1 ? -1 : 1),
          (u.material.uniforms.backgroundBlurriness.value =
            d.backgroundBlurriness),
          (u.material.uniforms.backgroundIntensity.value =
            d.backgroundIntensity),
          (u.material.toneMapped = v.colorSpace !== Ve),
          (h !== v || f !== v.version || p !== r.toneMapping) &&
            ((u.material.needsUpdate = !0),
            (h = v),
            (f = v.version),
            (p = r.toneMapping)),
          u.layers.enableAll(),
          _.unshift(u, u.geometry, u.material, 0, 0, null))
        : v &&
          v.isTexture &&
          (c === void 0 &&
            ((c = new Vn(
              new lu(2, 2),
              new Ir({
                name: "BackgroundMaterial",
                uniforms: ka(Ai.background.uniforms),
                vertexShader: Ai.background.vertexShader,
                fragmentShader: Ai.background.fragmentShader,
                side: or,
                depthTest: !1,
                depthWrite: !1,
                fog: !1,
              })
            )),
            c.geometry.deleteAttribute("normal"),
            Object.defineProperty(c.material, "map", {
              get: function () {
                return this.uniforms.t2D.value;
              },
            }),
            i.update(c)),
          (c.material.uniforms.t2D.value = v),
          (c.material.uniforms.backgroundIntensity.value =
            d.backgroundIntensity),
          (c.material.toneMapped = v.colorSpace !== Ve),
          v.matrixAutoUpdate === !0 && v.updateMatrix(),
          c.material.uniforms.uvTransform.value.copy(v.matrix),
          (h !== v || f !== v.version || p !== r.toneMapping) &&
            ((c.material.needsUpdate = !0),
            (h = v),
            (f = v.version),
            (p = r.toneMapping)),
          c.layers.enableAll(),
          _.unshift(c, c.geometry, c.material, 0, 0, null));
  }
  function m(_, d) {
    _.getRGB(Xl, Q_(r)), n.buffers.color.setClear(Xl.r, Xl.g, Xl.b, d, a);
  }
  return {
    getClearColor: function () {
      return o;
    },
    setClearColor: function (_, d = 1) {
      o.set(_), (l = d), m(o, l);
    },
    getClearAlpha: function () {
      return l;
    },
    setClearAlpha: function (_) {
      (l = _), m(o, l);
    },
    render: g,
  };
}
function jS(r, e, t, n) {
  const i = r.getParameter(r.MAX_VERTEX_ATTRIBS),
    s = n.isWebGL2 ? null : e.get("OES_vertex_array_object"),
    a = n.isWebGL2 || s !== null,
    o = {},
    l = _(null);
  let c = l,
    u = !1;
  function h(F, I, j, A, k) {
    let G = !1;
    if (a) {
      const z = m(A, j, I);
      c !== z && ((c = z), p(c.object)),
        (G = d(F, A, j, k)),
        G && y(F, A, j, k);
    } else {
      const z = I.wireframe === !0;
      (c.geometry !== A.id || c.program !== j.id || c.wireframe !== z) &&
        ((c.geometry = A.id), (c.program = j.id), (c.wireframe = z), (G = !0));
    }
    k !== null && t.update(k, r.ELEMENT_ARRAY_BUFFER),
      (G || u) &&
        ((u = !1),
        C(F, I, j, A),
        k !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, t.get(k).buffer));
  }
  function f() {
    return n.isWebGL2 ? r.createVertexArray() : s.createVertexArrayOES();
  }
  function p(F) {
    return n.isWebGL2 ? r.bindVertexArray(F) : s.bindVertexArrayOES(F);
  }
  function g(F) {
    return n.isWebGL2 ? r.deleteVertexArray(F) : s.deleteVertexArrayOES(F);
  }
  function m(F, I, j) {
    const A = j.wireframe === !0;
    let k = o[F.id];
    k === void 0 && ((k = {}), (o[F.id] = k));
    let G = k[I.id];
    G === void 0 && ((G = {}), (k[I.id] = G));
    let z = G[A];
    return z === void 0 && ((z = _(f())), (G[A] = z)), z;
  }
  function _(F) {
    const I = [],
      j = [],
      A = [];
    for (let k = 0; k < i; k++) (I[k] = 0), (j[k] = 0), (A[k] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: I,
      enabledAttributes: j,
      attributeDivisors: A,
      object: F,
      attributes: {},
      index: null,
    };
  }
  function d(F, I, j, A) {
    const k = c.attributes,
      G = I.attributes;
    let z = 0;
    const oe = j.getAttributes();
    for (const te in oe)
      if (oe[te].location >= 0) {
        const Y = k[te];
        let le = G[te];
        if (
          (le === void 0 &&
            (te === "instanceMatrix" &&
              F.instanceMatrix &&
              (le = F.instanceMatrix),
            te === "instanceColor" &&
              F.instanceColor &&
              (le = F.instanceColor)),
          Y === void 0 || Y.attribute !== le || (le && Y.data !== le.data))
        )
          return !0;
        z++;
      }
    return c.attributesNum !== z || c.index !== A;
  }
  function y(F, I, j, A) {
    const k = {},
      G = I.attributes;
    let z = 0;
    const oe = j.getAttributes();
    for (const te in oe)
      if (oe[te].location >= 0) {
        let Y = G[te];
        Y === void 0 &&
          (te === "instanceMatrix" &&
            F.instanceMatrix &&
            (Y = F.instanceMatrix),
          te === "instanceColor" && F.instanceColor && (Y = F.instanceColor));
        const le = {};
        (le.attribute = Y),
          Y && Y.data && (le.data = Y.data),
          (k[te] = le),
          z++;
      }
    (c.attributes = k), (c.attributesNum = z), (c.index = A);
  }
  function v() {
    const F = c.newAttributes;
    for (let I = 0, j = F.length; I < j; I++) F[I] = 0;
  }
  function S(F) {
    E(F, 0);
  }
  function E(F, I) {
    const j = c.newAttributes,
      A = c.enabledAttributes,
      k = c.attributeDivisors;
    (j[F] = 1),
      A[F] === 0 && (r.enableVertexAttribArray(F), (A[F] = 1)),
      k[F] !== I &&
        ((n.isWebGL2 ? r : e.get("ANGLE_instanced_arrays"))[
          n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
        ](F, I),
        (k[F] = I));
  }
  function b() {
    const F = c.newAttributes,
      I = c.enabledAttributes;
    for (let j = 0, A = I.length; j < A; j++)
      I[j] !== F[j] && (r.disableVertexAttribArray(j), (I[j] = 0));
  }
  function M(F, I, j, A, k, G) {
    n.isWebGL2 === !0 && (j === r.INT || j === r.UNSIGNED_INT)
      ? r.vertexAttribIPointer(F, I, j, k, G)
      : r.vertexAttribPointer(F, I, j, A, k, G);
  }
  function C(F, I, j, A) {
    if (
      n.isWebGL2 === !1 &&
      (F.isInstancedMesh || A.isInstancedBufferGeometry) &&
      e.get("ANGLE_instanced_arrays") === null
    )
      return;
    v();
    const k = A.attributes,
      G = j.getAttributes(),
      z = I.defaultAttributeValues;
    for (const oe in G) {
      const te = G[oe];
      if (te.location >= 0) {
        let X = k[oe];
        if (
          (X === void 0 &&
            (oe === "instanceMatrix" &&
              F.instanceMatrix &&
              (X = F.instanceMatrix),
            oe === "instanceColor" && F.instanceColor && (X = F.instanceColor)),
          X !== void 0)
        ) {
          const Y = X.normalized,
            le = X.itemSize,
            W = t.get(X);
          if (W === void 0) continue;
          const O = W.buffer,
            Me = W.type,
            ve = W.bytesPerElement;
          if (X.isInterleavedBufferAttribute) {
            const re = X.data,
              be = re.stride,
              Fe = X.offset;
            if (re.isInstancedInterleavedBuffer) {
              for (let ae = 0; ae < te.locationSize; ae++)
                E(te.location + ae, re.meshPerAttribute);
              F.isInstancedMesh !== !0 &&
                A._maxInstanceCount === void 0 &&
                (A._maxInstanceCount = re.meshPerAttribute * re.count);
            } else
              for (let ae = 0; ae < te.locationSize; ae++) S(te.location + ae);
            r.bindBuffer(r.ARRAY_BUFFER, O);
            for (let ae = 0; ae < te.locationSize; ae++)
              M(
                te.location + ae,
                le / te.locationSize,
                Me,
                Y,
                be * ve,
                (Fe + (le / te.locationSize) * ae) * ve
              );
          } else {
            if (X.isInstancedBufferAttribute) {
              for (let re = 0; re < te.locationSize; re++)
                E(te.location + re, X.meshPerAttribute);
              F.isInstancedMesh !== !0 &&
                A._maxInstanceCount === void 0 &&
                (A._maxInstanceCount = X.meshPerAttribute * X.count);
            } else
              for (let re = 0; re < te.locationSize; re++) S(te.location + re);
            r.bindBuffer(r.ARRAY_BUFFER, O);
            for (let re = 0; re < te.locationSize; re++)
              M(
                te.location + re,
                le / te.locationSize,
                Me,
                Y,
                le * ve,
                (le / te.locationSize) * re * ve
              );
          }
        } else if (z !== void 0) {
          const Y = z[oe];
          if (Y !== void 0)
            switch (Y.length) {
              case 2:
                r.vertexAttrib2fv(te.location, Y);
                break;
              case 3:
                r.vertexAttrib3fv(te.location, Y);
                break;
              case 4:
                r.vertexAttrib4fv(te.location, Y);
                break;
              default:
                r.vertexAttrib1fv(te.location, Y);
            }
        }
      }
    }
    b();
  }
  function x() {
    N();
    for (const F in o) {
      const I = o[F];
      for (const j in I) {
        const A = I[j];
        for (const k in A) g(A[k].object), delete A[k];
        delete I[j];
      }
      delete o[F];
    }
  }
  function T(F) {
    if (o[F.id] === void 0) return;
    const I = o[F.id];
    for (const j in I) {
      const A = I[j];
      for (const k in A) g(A[k].object), delete A[k];
      delete I[j];
    }
    delete o[F.id];
  }
  function D(F) {
    for (const I in o) {
      const j = o[I];
      if (j[F.id] === void 0) continue;
      const A = j[F.id];
      for (const k in A) g(A[k].object), delete A[k];
      delete j[F.id];
    }
  }
  function N() {
    L(), (u = !0), c !== l && ((c = l), p(c.object));
  }
  function L() {
    (l.geometry = null), (l.program = null), (l.wireframe = !1);
  }
  return {
    setup: h,
    reset: N,
    resetDefaultState: L,
    dispose: x,
    releaseStatesOfGeometry: T,
    releaseStatesOfProgram: D,
    initAttributes: v,
    enableAttribute: S,
    disableUnusedAttributes: b,
  };
}
function KS(r, e, t, n) {
  const i = n.isWebGL2;
  let s;
  function a(c) {
    s = c;
  }
  function o(c, u) {
    r.drawArrays(s, c, u), t.update(u, s, 1);
  }
  function l(c, u, h) {
    if (h === 0) return;
    let f, p;
    if (i) (f = r), (p = "drawArraysInstanced");
    else if (
      ((f = e.get("ANGLE_instanced_arrays")),
      (p = "drawArraysInstancedANGLE"),
      f === null)
    ) {
      console.error(
        "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    f[p](s, c, u, h), t.update(u, s, h);
  }
  (this.setMode = a), (this.render = o), (this.renderInstances = l);
}
function $S(r, e, t) {
  let n;
  function i() {
    if (n !== void 0) return n;
    if (e.has("EXT_texture_filter_anisotropic") === !0) {
      const M = e.get("EXT_texture_filter_anisotropic");
      n = r.getParameter(M.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else n = 0;
    return n;
  }
  function s(M) {
    if (M === "highp") {
      if (
        r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision >
          0 &&
        r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      M = "mediump";
    }
    return M === "mediump" &&
      r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision >
        0 &&
      r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  const a =
    typeof WebGL2RenderingContext < "u" &&
    r.constructor.name === "WebGL2RenderingContext";
  let o = t.precision !== void 0 ? t.precision : "highp";
  const l = s(o);
  l !== o &&
    (console.warn(
      "THREE.WebGLRenderer:",
      o,
      "not supported, using",
      l,
      "instead."
    ),
    (o = l));
  const c = a || e.has("WEBGL_draw_buffers"),
    u = t.logarithmicDepthBuffer === !0,
    h = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS),
    f = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    p = r.getParameter(r.MAX_TEXTURE_SIZE),
    g = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE),
    m = r.getParameter(r.MAX_VERTEX_ATTRIBS),
    _ = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS),
    d = r.getParameter(r.MAX_VARYING_VECTORS),
    y = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS),
    v = f > 0,
    S = a || e.has("OES_texture_float"),
    E = v && S,
    b = a ? r.getParameter(r.MAX_SAMPLES) : 0;
  return {
    isWebGL2: a,
    drawBuffers: c,
    getMaxAnisotropy: i,
    getMaxPrecision: s,
    precision: o,
    logarithmicDepthBuffer: u,
    maxTextures: h,
    maxVertexTextures: f,
    maxTextureSize: p,
    maxCubemapSize: g,
    maxAttributes: m,
    maxVertexUniforms: _,
    maxVaryings: d,
    maxFragmentUniforms: y,
    vertexTextures: v,
    floatFragmentTextures: S,
    floatVertexTextures: E,
    maxSamples: b,
  };
}
function ZS(r) {
  const e = this;
  let t = null,
    n = 0,
    i = !1,
    s = !1;
  const a = new ts(),
    o = new it(),
    l = { value: null, needsUpdate: !1 };
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (h, f) {
      const p = h.length !== 0 || f || n !== 0 || i;
      return (i = f), (n = h.length), p;
    }),
    (this.beginShadows = function () {
      (s = !0), u(null);
    }),
    (this.endShadows = function () {
      s = !1;
    }),
    (this.setGlobalState = function (h, f) {
      t = u(h, f, 0);
    }),
    (this.setState = function (h, f, p) {
      const g = h.clippingPlanes,
        m = h.clipIntersection,
        _ = h.clipShadows,
        d = r.get(h);
      if (!i || g === null || g.length === 0 || (s && !_)) s ? u(null) : c();
      else {
        const y = s ? 0 : n,
          v = y * 4;
        let S = d.clippingState || null;
        (l.value = S), (S = u(g, f, v, p));
        for (let E = 0; E !== v; ++E) S[E] = t[E];
        (d.clippingState = S),
          (this.numIntersection = m ? this.numPlanes : 0),
          (this.numPlanes += y);
      }
    });
  function c() {
    l.value !== t && ((l.value = t), (l.needsUpdate = n > 0)),
      (e.numPlanes = n),
      (e.numIntersection = 0);
  }
  function u(h, f, p, g) {
    const m = h !== null ? h.length : 0;
    let _ = null;
    if (m !== 0) {
      if (((_ = l.value), g !== !0 || _ === null)) {
        const d = p + m * 4,
          y = f.matrixWorldInverse;
        o.getNormalMatrix(y),
          (_ === null || _.length < d) && (_ = new Float32Array(d));
        for (let v = 0, S = p; v !== m; ++v, S += 4)
          a.copy(h[v]).applyMatrix4(y, o),
            a.normal.toArray(_, S),
            (_[S + 3] = a.constant);
      }
      (l.value = _), (l.needsUpdate = !0);
    }
    return (e.numPlanes = m), (e.numIntersection = 0), _;
  }
}
function JS(r) {
  let e = new WeakMap();
  function t(a, o) {
    return o === Ch ? (a.mapping = Ia) : o === Ph && (a.mapping = Na), a;
  }
  function n(a) {
    if (a && a.isTexture && a.isRenderTargetTexture === !1) {
      const o = a.mapping;
      if (o === Ch || o === Ph)
        if (e.has(a)) {
          const l = e.get(a).texture;
          return t(l, a.mapping);
        } else {
          const l = a.image;
          if (l && l.height > 0) {
            const c = new py(l.height / 2);
            return (
              c.fromEquirectangularTexture(r, a),
              e.set(a, c),
              a.addEventListener("dispose", i),
              t(c.texture, a.mapping)
            );
          } else return null;
        }
    }
    return a;
  }
  function i(a) {
    const o = a.target;
    o.removeEventListener("dispose", i);
    const l = e.get(o);
    l !== void 0 && (e.delete(o), l.dispose());
  }
  function s() {
    e = new WeakMap();
  }
  return { get: n, dispose: s };
}
class Pf extends eg {
  constructor(e = -1, t = 1, n = 1, i = -1, s = 0.1, a = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = n),
      (this.bottom = i),
      (this.near = s),
      (this.far = a),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = e.view === null ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, n, i, s, a) {
    this.view === null &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = n),
      (this.view.offsetY = i),
      (this.view.width = s),
      (this.view.height = a),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    this.view !== null && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      n = (this.right + this.left) / 2,
      i = (this.top + this.bottom) / 2;
    let s = n - e,
      a = n + e,
      o = i + t,
      l = i - t;
    if (this.view !== null && this.view.enabled) {
      const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
        u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (s += c * this.view.offsetX),
        (a = s + c * this.view.width),
        (o -= u * this.view.offsetY),
        (l = o - u * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(s, a, o, l, this.near, this.far),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      this.view !== null && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
const ma = 4,
  Rp = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  as = 20,
  Ju = new Pf(),
  Cp = new Ke();
let Qu = null;
const ns = (1 + Math.sqrt(5)) / 2,
  ta = 1 / ns,
  Pp = [
    new H(1, 1, 1),
    new H(-1, 1, 1),
    new H(1, 1, -1),
    new H(-1, 1, -1),
    new H(0, ns, ta),
    new H(0, ns, -ta),
    new H(ta, 0, ns),
    new H(-ta, 0, ns),
    new H(ns, ta, 0),
    new H(-ns, ta, 0),
  ];
class Lp {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, n = 0.1, i = 100) {
    (Qu = this._renderer.getRenderTarget()), this._setSize(256);
    const s = this._allocateTargets();
    return (
      (s.depthBuffer = !0),
      this._sceneToCubeUV(e, n, i, s),
      t > 0 && this._blur(s, 0, 0, t),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    this._cubemapMaterial === null &&
      ((this._cubemapMaterial = Np()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    this._equirectMaterial === null &&
      ((this._equirectMaterial = Ip()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
      this._equirectMaterial !== null && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    this._blurMaterial !== null && this._blurMaterial.dispose(),
      this._pingPongRenderTarget !== null &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(Qu),
      (e.scissorTest = !1),
      Yl(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === Ia || e.mapping === Na
      ? this._setSize(
          e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (Qu = this._renderer.getRenderTarget());
    const n = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      n = {
        magFilter: Sn,
        minFilter: Sn,
        generateMipmaps: !1,
        type: Vo,
        format: Qn,
        colorSpace: Ii,
        depthBuffer: !1,
      },
      i = Dp(e, t, n);
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      this._pingPongRenderTarget !== null && this._dispose(),
        (this._pingPongRenderTarget = Dp(e, t, n));
      const { _lodMax: s } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = QS(s)),
        (this._blurMaterial = eM(s, e, t));
    }
    return i;
  }
  _compileMaterial(e) {
    const t = new Vn(this._lodPlanes[0], e);
    this._renderer.compile(t, Ju);
  }
  _sceneToCubeUV(e, t, n, i) {
    const o = new mn(90, 1, t, n),
      l = [1, -1, 1, 1, 1, 1],
      c = [1, 1, 1, -1, -1, -1],
      u = this._renderer,
      h = u.autoClear,
      f = u.toneMapping;
    u.getClearColor(Cp), (u.toneMapping = rr), (u.autoClear = !1);
    const p = new Sr({
        name: "PMREM.Background",
        side: bn,
        depthWrite: !1,
        depthTest: !1,
      }),
      g = new Vn(new fl(), p);
    let m = !1;
    const _ = e.background;
    _
      ? _.isColor && (p.color.copy(_), (e.background = null), (m = !0))
      : (p.color.copy(Cp), (m = !0));
    for (let d = 0; d < 6; d++) {
      const y = d % 3;
      y === 0
        ? (o.up.set(0, l[d], 0), o.lookAt(c[d], 0, 0))
        : y === 1
        ? (o.up.set(0, 0, l[d]), o.lookAt(0, c[d], 0))
        : (o.up.set(0, l[d], 0), o.lookAt(0, 0, c[d]));
      const v = this._cubeSize;
      Yl(i, y * v, d > 2 ? v : 0, v, v),
        u.setRenderTarget(i),
        m && u.render(g, o),
        u.render(e, o);
    }
    g.geometry.dispose(),
      g.material.dispose(),
      (u.toneMapping = f),
      (u.autoClear = h),
      (e.background = _);
  }
  _textureToCubeUV(e, t) {
    const n = this._renderer,
      i = e.mapping === Ia || e.mapping === Na;
    i
      ? (this._cubemapMaterial === null && (this._cubemapMaterial = Np()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          e.isRenderTargetTexture === !1 ? -1 : 1))
      : this._equirectMaterial === null && (this._equirectMaterial = Ip());
    const s = i ? this._cubemapMaterial : this._equirectMaterial,
      a = new Vn(this._lodPlanes[0], s),
      o = s.uniforms;
    o.envMap.value = e;
    const l = this._cubeSize;
    Yl(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(a, Ju);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      n = t.autoClear;
    t.autoClear = !1;
    for (let i = 1; i < this._lodPlanes.length; i++) {
      const s = Math.sqrt(
          this._sigmas[i] * this._sigmas[i] -
            this._sigmas[i - 1] * this._sigmas[i - 1]
        ),
        a = Pp[(i - 1) % Pp.length];
      this._blur(e, i - 1, i, s, a);
    }
    t.autoClear = n;
  }
  _blur(e, t, n, i, s) {
    const a = this._pingPongRenderTarget;
    this._halfBlur(e, a, t, n, i, "latitudinal", s),
      this._halfBlur(a, e, n, n, i, "longitudinal", s);
  }
  _halfBlur(e, t, n, i, s, a, o) {
    const l = this._renderer,
      c = this._blurMaterial;
    a !== "latitudinal" &&
      a !== "longitudinal" &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const u = 3,
      h = new Vn(this._lodPlanes[i], c),
      f = c.uniforms,
      p = this._sizeLods[n] - 1,
      g = isFinite(s) ? Math.PI / (2 * p) : (2 * Math.PI) / (2 * as - 1),
      m = s / g,
      _ = isFinite(s) ? 1 + Math.floor(u * m) : as;
    _ > as &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${_} samples when the maximum is set to ${as}`
      );
    const d = [];
    let y = 0;
    for (let M = 0; M < as; ++M) {
      const C = M / m,
        x = Math.exp((-C * C) / 2);
      d.push(x), M === 0 ? (y += x) : M < _ && (y += 2 * x);
    }
    for (let M = 0; M < d.length; M++) d[M] = d[M] / y;
    (f.envMap.value = e.texture),
      (f.samples.value = _),
      (f.weights.value = d),
      (f.latitudinal.value = a === "latitudinal"),
      o && (f.poleAxis.value = o);
    const { _lodMax: v } = this;
    (f.dTheta.value = g), (f.mipInt.value = v - n);
    const S = this._sizeLods[i],
      E = 3 * S * (i > v - ma ? i - v + ma : 0),
      b = 4 * (this._cubeSize - S);
    Yl(t, E, b, 3 * S, 2 * S), l.setRenderTarget(t), l.render(h, Ju);
  }
}
function QS(r) {
  const e = [],
    t = [],
    n = [];
  let i = r;
  const s = r - ma + 1 + Rp.length;
  for (let a = 0; a < s; a++) {
    const o = Math.pow(2, i);
    t.push(o);
    let l = 1 / o;
    a > r - ma ? (l = Rp[a - r + ma - 1]) : a === 0 && (l = 0), n.push(l);
    const c = 1 / (o - 2),
      u = -c,
      h = 1 + c,
      f = [u, u, h, u, h, h, u, u, h, h, u, h],
      p = 6,
      g = 6,
      m = 3,
      _ = 2,
      d = 1,
      y = new Float32Array(m * g * p),
      v = new Float32Array(_ * g * p),
      S = new Float32Array(d * g * p);
    for (let b = 0; b < p; b++) {
      const M = ((b % 3) * 2) / 3 - 1,
        C = b > 2 ? 0 : -1,
        x = [
          M,
          C,
          0,
          M + 2 / 3,
          C,
          0,
          M + 2 / 3,
          C + 1,
          0,
          M,
          C,
          0,
          M + 2 / 3,
          C + 1,
          0,
          M,
          C + 1,
          0,
        ];
      y.set(x, m * g * b), v.set(f, _ * g * b);
      const T = [b, b, b, b, b, b];
      S.set(T, d * g * b);
    }
    const E = new xi();
    E.setAttribute("position", new xn(y, m)),
      E.setAttribute("uv", new xn(v, _)),
      E.setAttribute("faceIndex", new xn(S, d)),
      e.push(E),
      i > ma && i--;
  }
  return { lodPlanes: e, sizeLods: t, sigmas: n };
}
function Dp(r, e, t) {
  const n = new bs(r, e, t);
  return (
    (n.texture.mapping = su),
    (n.texture.name = "PMREM.cubeUv"),
    (n.scissorTest = !0),
    n
  );
}
function Yl(r, e, t, n, i) {
  r.viewport.set(e, t, n, i), r.scissor.set(e, t, n, i);
}
function eM(r, e, t) {
  const n = new Float32Array(as),
    i = new H(0, 1, 0);
  return new Ir({
    name: "SphericalGaussianBlur",
    defines: {
      n: as,
      CUBEUV_TEXEL_WIDTH: 1 / e,
      CUBEUV_TEXEL_HEIGHT: 1 / t,
      CUBEUV_MAX_MIP: `${r}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: i },
    },
    vertexShader: Lf(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: Cr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Ip() {
  return new Ir({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: Lf(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: Cr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Np() {
  return new Ir({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: Lf(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: Cr,
    depthTest: !1,
    depthWrite: !1,
  });
}
function Lf() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;
}
function tM(r) {
  let e = new WeakMap(),
    t = null;
  function n(o) {
    if (o && o.isTexture) {
      const l = o.mapping,
        c = l === Ch || l === Ph,
        u = l === Ia || l === Na;
      if (c || u)
        if (o.isRenderTargetTexture && o.needsPMREMUpdate === !0) {
          o.needsPMREMUpdate = !1;
          let h = e.get(o);
          return (
            t === null && (t = new Lp(r)),
            (h = c ? t.fromEquirectangular(o, h) : t.fromCubemap(o, h)),
            e.set(o, h),
            h.texture
          );
        } else {
          if (e.has(o)) return e.get(o).texture;
          {
            const h = o.image;
            if ((c && h && h.height > 0) || (u && h && i(h))) {
              t === null && (t = new Lp(r));
              const f = c ? t.fromEquirectangular(o) : t.fromCubemap(o);
              return e.set(o, f), o.addEventListener("dispose", s), f.texture;
            } else return null;
          }
        }
    }
    return o;
  }
  function i(o) {
    let l = 0;
    const c = 6;
    for (let u = 0; u < c; u++) o[u] !== void 0 && l++;
    return l === c;
  }
  function s(o) {
    const l = o.target;
    l.removeEventListener("dispose", s);
    const c = e.get(l);
    c !== void 0 && (e.delete(l), c.dispose());
  }
  function a() {
    (e = new WeakMap()), t !== null && (t.dispose(), (t = null));
  }
  return { get: n, dispose: a };
}
function nM(r) {
  const e = {};
  function t(n) {
    if (e[n] !== void 0) return e[n];
    let i;
    switch (n) {
      case "WEBGL_depth_texture":
        i =
          r.getExtension("WEBGL_depth_texture") ||
          r.getExtension("MOZ_WEBGL_depth_texture") ||
          r.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        i =
          r.getExtension("EXT_texture_filter_anisotropic") ||
          r.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        i =
          r.getExtension("WEBGL_compressed_texture_s3tc") ||
          r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        i =
          r.getExtension("WEBGL_compressed_texture_pvrtc") ||
          r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        i = r.getExtension(n);
    }
    return (e[n] = i), i;
  }
  return {
    has: function (n) {
      return t(n) !== null;
    },
    init: function (n) {
      n.isWebGL2
        ? t("EXT_color_buffer_float")
        : (t("WEBGL_depth_texture"),
          t("OES_texture_float"),
          t("OES_texture_half_float"),
          t("OES_texture_half_float_linear"),
          t("OES_standard_derivatives"),
          t("OES_element_index_uint"),
          t("OES_vertex_array_object"),
          t("ANGLE_instanced_arrays")),
        t("OES_texture_float_linear"),
        t("EXT_color_buffer_half_float"),
        t("WEBGL_multisampled_render_to_texture");
    },
    get: function (n) {
      const i = t(n);
      return (
        i === null &&
          console.warn(
            "THREE.WebGLRenderer: " + n + " extension not supported."
          ),
        i
      );
    },
  };
}
function iM(r, e, t, n) {
  const i = {},
    s = new WeakMap();
  function a(h) {
    const f = h.target;
    f.index !== null && e.remove(f.index);
    for (const g in f.attributes) e.remove(f.attributes[g]);
    f.removeEventListener("dispose", a), delete i[f.id];
    const p = s.get(f);
    p && (e.remove(p), s.delete(f)),
      n.releaseStatesOfGeometry(f),
      f.isInstancedBufferGeometry === !0 && delete f._maxInstanceCount,
      t.memory.geometries--;
  }
  function o(h, f) {
    return (
      i[f.id] === !0 ||
        (f.addEventListener("dispose", a),
        (i[f.id] = !0),
        t.memory.geometries++),
      f
    );
  }
  function l(h) {
    const f = h.attributes;
    for (const g in f) e.update(f[g], r.ARRAY_BUFFER);
    const p = h.morphAttributes;
    for (const g in p) {
      const m = p[g];
      for (let _ = 0, d = m.length; _ < d; _++) e.update(m[_], r.ARRAY_BUFFER);
    }
  }
  function c(h) {
    const f = [],
      p = h.index,
      g = h.attributes.position;
    let m = 0;
    if (p !== null) {
      const y = p.array;
      m = p.version;
      for (let v = 0, S = y.length; v < S; v += 3) {
        const E = y[v + 0],
          b = y[v + 1],
          M = y[v + 2];
        f.push(E, b, b, M, M, E);
      }
    } else {
      const y = g.array;
      m = g.version;
      for (let v = 0, S = y.length / 3 - 1; v < S; v += 3) {
        const E = v + 0,
          b = v + 1,
          M = v + 2;
        f.push(E, b, b, M, M, E);
      }
    }
    const _ = new (Y_(f) ? J_ : Z_)(f, 1);
    _.version = m;
    const d = s.get(h);
    d && e.remove(d), s.set(h, _);
  }
  function u(h) {
    const f = s.get(h);
    if (f) {
      const p = h.index;
      p !== null && f.version < p.version && c(h);
    } else c(h);
    return s.get(h);
  }
  return { get: o, update: l, getWireframeAttribute: u };
}
function rM(r, e, t, n) {
  const i = n.isWebGL2;
  let s;
  function a(f) {
    s = f;
  }
  let o, l;
  function c(f) {
    (o = f.type), (l = f.bytesPerElement);
  }
  function u(f, p) {
    r.drawElements(s, p, o, f * l), t.update(p, s, 1);
  }
  function h(f, p, g) {
    if (g === 0) return;
    let m, _;
    if (i) (m = r), (_ = "drawElementsInstanced");
    else if (
      ((m = e.get("ANGLE_instanced_arrays")),
      (_ = "drawElementsInstancedANGLE"),
      m === null)
    ) {
      console.error(
        "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
      );
      return;
    }
    m[_](s, p, o, f * l, g), t.update(p, s, g);
  }
  (this.setMode = a),
    (this.setIndex = c),
    (this.render = u),
    (this.renderInstances = h);
}
function sM(r) {
  const e = { geometries: 0, textures: 0 },
    t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  function n(s, a, o) {
    switch ((t.calls++, a)) {
      case r.TRIANGLES:
        t.triangles += o * (s / 3);
        break;
      case r.LINES:
        t.lines += o * (s / 2);
        break;
      case r.LINE_STRIP:
        t.lines += o * (s - 1);
        break;
      case r.LINE_LOOP:
        t.lines += o * s;
        break;
      case r.POINTS:
        t.points += o * s;
        break;
      default:
        console.error("THREE.WebGLInfo: Unknown draw mode:", a);
        break;
    }
  }
  function i() {
    t.frame++, (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
  }
  return {
    memory: e,
    render: t,
    programs: null,
    autoReset: !0,
    reset: i,
    update: n,
  };
}
function aM(r, e) {
  return r[0] - e[0];
}
function oM(r, e) {
  return Math.abs(e[1]) - Math.abs(r[1]);
}
function lM(r, e, t) {
  const n = {},
    i = new Float32Array(8),
    s = new WeakMap(),
    a = new mt(),
    o = [];
  for (let c = 0; c < 8; c++) o[c] = [c, 0];
  function l(c, u, h) {
    const f = c.morphTargetInfluences;
    if (e.isWebGL2 === !0) {
      const g =
          u.morphAttributes.position ||
          u.morphAttributes.normal ||
          u.morphAttributes.color,
        m = g !== void 0 ? g.length : 0;
      let _ = s.get(u);
      if (_ === void 0 || _.count !== m) {
        let I = function () {
          L.dispose(), s.delete(u), u.removeEventListener("dispose", I);
        };
        var p = I;
        _ !== void 0 && _.texture.dispose();
        const v = u.morphAttributes.position !== void 0,
          S = u.morphAttributes.normal !== void 0,
          E = u.morphAttributes.color !== void 0,
          b = u.morphAttributes.position || [],
          M = u.morphAttributes.normal || [],
          C = u.morphAttributes.color || [];
        let x = 0;
        v === !0 && (x = 1), S === !0 && (x = 2), E === !0 && (x = 3);
        let T = u.attributes.position.count * x,
          D = 1;
        T > e.maxTextureSize &&
          ((D = Math.ceil(T / e.maxTextureSize)), (T = e.maxTextureSize));
        const N = new Float32Array(T * D * 4 * m),
          L = new K_(N, T, D, m);
        (L.type = Er), (L.needsUpdate = !0);
        const F = x * 4;
        for (let j = 0; j < m; j++) {
          const A = b[j],
            k = M[j],
            G = C[j],
            z = T * D * 4 * j;
          for (let oe = 0; oe < A.count; oe++) {
            const te = oe * F;
            v === !0 &&
              (a.fromBufferAttribute(A, oe),
              (N[z + te + 0] = a.x),
              (N[z + te + 1] = a.y),
              (N[z + te + 2] = a.z),
              (N[z + te + 3] = 0)),
              S === !0 &&
                (a.fromBufferAttribute(k, oe),
                (N[z + te + 4] = a.x),
                (N[z + te + 5] = a.y),
                (N[z + te + 6] = a.z),
                (N[z + te + 7] = 0)),
              E === !0 &&
                (a.fromBufferAttribute(G, oe),
                (N[z + te + 8] = a.x),
                (N[z + te + 9] = a.y),
                (N[z + te + 10] = a.z),
                (N[z + te + 11] = G.itemSize === 4 ? a.w : 1));
          }
        }
        (_ = { count: m, texture: L, size: new We(T, D) }),
          s.set(u, _),
          u.addEventListener("dispose", I);
      }
      let d = 0;
      for (let v = 0; v < f.length; v++) d += f[v];
      const y = u.morphTargetsRelative ? 1 : 1 - d;
      h.getUniforms().setValue(r, "morphTargetBaseInfluence", y),
        h.getUniforms().setValue(r, "morphTargetInfluences", f),
        h.getUniforms().setValue(r, "morphTargetsTexture", _.texture, t),
        h.getUniforms().setValue(r, "morphTargetsTextureSize", _.size);
    } else {
      const g = f === void 0 ? 0 : f.length;
      let m = n[u.id];
      if (m === void 0 || m.length !== g) {
        m = [];
        for (let S = 0; S < g; S++) m[S] = [S, 0];
        n[u.id] = m;
      }
      for (let S = 0; S < g; S++) {
        const E = m[S];
        (E[0] = S), (E[1] = f[S]);
      }
      m.sort(oM);
      for (let S = 0; S < 8; S++)
        S < g && m[S][1]
          ? ((o[S][0] = m[S][0]), (o[S][1] = m[S][1]))
          : ((o[S][0] = Number.MAX_SAFE_INTEGER), (o[S][1] = 0));
      o.sort(aM);
      const _ = u.morphAttributes.position,
        d = u.morphAttributes.normal;
      let y = 0;
      for (let S = 0; S < 8; S++) {
        const E = o[S],
          b = E[0],
          M = E[1];
        b !== Number.MAX_SAFE_INTEGER && M
          ? (_ &&
              u.getAttribute("morphTarget" + S) !== _[b] &&
              u.setAttribute("morphTarget" + S, _[b]),
            d &&
              u.getAttribute("morphNormal" + S) !== d[b] &&
              u.setAttribute("morphNormal" + S, d[b]),
            (i[S] = M),
            (y += M))
          : (_ &&
              u.hasAttribute("morphTarget" + S) === !0 &&
              u.deleteAttribute("morphTarget" + S),
            d &&
              u.hasAttribute("morphNormal" + S) === !0 &&
              u.deleteAttribute("morphNormal" + S),
            (i[S] = 0));
      }
      const v = u.morphTargetsRelative ? 1 : 1 - y;
      h.getUniforms().setValue(r, "morphTargetBaseInfluence", v),
        h.getUniforms().setValue(r, "morphTargetInfluences", i);
    }
  }
  return { update: l };
}
function cM(r, e, t, n) {
  let i = new WeakMap();
  function s(l) {
    const c = n.render.frame,
      u = l.geometry,
      h = e.get(l, u);
    return (
      i.get(h) !== c && (e.update(h), i.set(h, c)),
      l.isInstancedMesh &&
        (l.hasEventListener("dispose", o) === !1 &&
          l.addEventListener("dispose", o),
        t.update(l.instanceMatrix, r.ARRAY_BUFFER),
        l.instanceColor !== null && t.update(l.instanceColor, r.ARRAY_BUFFER)),
      h
    );
  }
  function a() {
    i = new WeakMap();
  }
  function o(l) {
    const c = l.target;
    c.removeEventListener("dispose", o),
      t.remove(c.instanceMatrix),
      c.instanceColor !== null && t.remove(c.instanceColor);
  }
  return { update: s, dispose: a };
}
const ig = new Qt(),
  rg = new K_(),
  sg = new Jx(),
  ag = new tg(),
  Op = [],
  Up = [],
  Fp = new Float32Array(16),
  Bp = new Float32Array(9),
  kp = new Float32Array(4);
function Ka(r, e, t) {
  const n = r[0];
  if (n <= 0 || n > 0) return r;
  const i = e * t;
  let s = Op[i];
  if ((s === void 0 && ((s = new Float32Array(i)), (Op[i] = s)), e !== 0)) {
    n.toArray(s, 0);
    for (let a = 1, o = 0; a !== e; ++a) (o += t), r[a].toArray(s, o);
  }
  return s;
}
function Ht(r, e) {
  if (r.length !== e.length) return !1;
  for (let t = 0, n = r.length; t < n; t++) if (r[t] !== e[t]) return !1;
  return !0;
}
function Vt(r, e) {
  for (let t = 0, n = e.length; t < n; t++) r[t] = e[t];
}
function cu(r, e) {
  let t = Up[e];
  t === void 0 && ((t = new Int32Array(e)), (Up[e] = t));
  for (let n = 0; n !== e; ++n) t[n] = r.allocateTextureUnit();
  return t;
}
function uM(r, e) {
  const t = this.cache;
  t[0] !== e && (r.uniform1f(this.addr, e), (t[0] = e));
}
function hM(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (r.uniform2f(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Ht(t, e)) return;
    r.uniform2fv(this.addr, e), Vt(t, e);
  }
}
function fM(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (r.uniform3f(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else if (e.r !== void 0)
    (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) &&
      (r.uniform3f(this.addr, e.r, e.g, e.b),
      (t[0] = e.r),
      (t[1] = e.g),
      (t[2] = e.b));
  else {
    if (Ht(t, e)) return;
    r.uniform3fv(this.addr, e), Vt(t, e);
  }
}
function dM(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (r.uniform4f(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Ht(t, e)) return;
    r.uniform4fv(this.addr, e), Vt(t, e);
  }
}
function pM(r, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (Ht(t, e)) return;
    r.uniformMatrix2fv(this.addr, !1, e), Vt(t, e);
  } else {
    if (Ht(t, n)) return;
    kp.set(n), r.uniformMatrix2fv(this.addr, !1, kp), Vt(t, n);
  }
}
function mM(r, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (Ht(t, e)) return;
    r.uniformMatrix3fv(this.addr, !1, e), Vt(t, e);
  } else {
    if (Ht(t, n)) return;
    Bp.set(n), r.uniformMatrix3fv(this.addr, !1, Bp), Vt(t, n);
  }
}
function _M(r, e) {
  const t = this.cache,
    n = e.elements;
  if (n === void 0) {
    if (Ht(t, e)) return;
    r.uniformMatrix4fv(this.addr, !1, e), Vt(t, e);
  } else {
    if (Ht(t, n)) return;
    Fp.set(n), r.uniformMatrix4fv(this.addr, !1, Fp), Vt(t, n);
  }
}
function gM(r, e) {
  const t = this.cache;
  t[0] !== e && (r.uniform1i(this.addr, e), (t[0] = e));
}
function vM(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (r.uniform2i(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Ht(t, e)) return;
    r.uniform2iv(this.addr, e), Vt(t, e);
  }
}
function xM(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (r.uniform3i(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Ht(t, e)) return;
    r.uniform3iv(this.addr, e), Vt(t, e);
  }
}
function yM(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (r.uniform4i(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Ht(t, e)) return;
    r.uniform4iv(this.addr, e), Vt(t, e);
  }
}
function EM(r, e) {
  const t = this.cache;
  t[0] !== e && (r.uniform1ui(this.addr, e), (t[0] = e));
}
function SM(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y) &&
      (r.uniform2ui(this.addr, e.x, e.y), (t[0] = e.x), (t[1] = e.y));
  else {
    if (Ht(t, e)) return;
    r.uniform2uiv(this.addr, e), Vt(t, e);
  }
}
function MM(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) &&
      (r.uniform3ui(this.addr, e.x, e.y, e.z),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z));
  else {
    if (Ht(t, e)) return;
    r.uniform3uiv(this.addr, e), Vt(t, e);
  }
}
function bM(r, e) {
  const t = this.cache;
  if (e.x !== void 0)
    (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) &&
      (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
      (t[0] = e.x),
      (t[1] = e.y),
      (t[2] = e.z),
      (t[3] = e.w));
  else {
    if (Ht(t, e)) return;
    r.uniform4uiv(this.addr, e), Vt(t, e);
  }
}
function TM(r, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
    t.setTexture2D(e || ig, i);
}
function AM(r, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
    t.setTexture3D(e || sg, i);
}
function wM(r, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
    t.setTextureCube(e || ag, i);
}
function RM(r, e, t) {
  const n = this.cache,
    i = t.allocateTextureUnit();
  n[0] !== i && (r.uniform1i(this.addr, i), (n[0] = i)),
    t.setTexture2DArray(e || rg, i);
}
function CM(r) {
  switch (r) {
    case 5126:
      return uM;
    case 35664:
      return hM;
    case 35665:
      return fM;
    case 35666:
      return dM;
    case 35674:
      return pM;
    case 35675:
      return mM;
    case 35676:
      return _M;
    case 5124:
    case 35670:
      return gM;
    case 35667:
    case 35671:
      return vM;
    case 35668:
    case 35672:
      return xM;
    case 35669:
    case 35673:
      return yM;
    case 5125:
      return EM;
    case 36294:
      return SM;
    case 36295:
      return MM;
    case 36296:
      return bM;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return TM;
    case 35679:
    case 36299:
    case 36307:
      return AM;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return wM;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return RM;
  }
}
function PM(r, e) {
  r.uniform1fv(this.addr, e);
}
function LM(r, e) {
  const t = Ka(e, this.size, 2);
  r.uniform2fv(this.addr, t);
}
function DM(r, e) {
  const t = Ka(e, this.size, 3);
  r.uniform3fv(this.addr, t);
}
function IM(r, e) {
  const t = Ka(e, this.size, 4);
  r.uniform4fv(this.addr, t);
}
function NM(r, e) {
  const t = Ka(e, this.size, 4);
  r.uniformMatrix2fv(this.addr, !1, t);
}
function OM(r, e) {
  const t = Ka(e, this.size, 9);
  r.uniformMatrix3fv(this.addr, !1, t);
}
function UM(r, e) {
  const t = Ka(e, this.size, 16);
  r.uniformMatrix4fv(this.addr, !1, t);
}
function FM(r, e) {
  r.uniform1iv(this.addr, e);
}
function BM(r, e) {
  r.uniform2iv(this.addr, e);
}
function kM(r, e) {
  r.uniform3iv(this.addr, e);
}
function zM(r, e) {
  r.uniform4iv(this.addr, e);
}
function HM(r, e) {
  r.uniform1uiv(this.addr, e);
}
function VM(r, e) {
  r.uniform2uiv(this.addr, e);
}
function GM(r, e) {
  r.uniform3uiv(this.addr, e);
}
function WM(r, e) {
  r.uniform4uiv(this.addr, e);
}
function XM(r, e, t) {
  const n = this.cache,
    i = e.length,
    s = cu(t, i);
  Ht(n, s) || (r.uniform1iv(this.addr, s), Vt(n, s));
  for (let a = 0; a !== i; ++a) t.setTexture2D(e[a] || ig, s[a]);
}
function YM(r, e, t) {
  const n = this.cache,
    i = e.length,
    s = cu(t, i);
  Ht(n, s) || (r.uniform1iv(this.addr, s), Vt(n, s));
  for (let a = 0; a !== i; ++a) t.setTexture3D(e[a] || sg, s[a]);
}
function qM(r, e, t) {
  const n = this.cache,
    i = e.length,
    s = cu(t, i);
  Ht(n, s) || (r.uniform1iv(this.addr, s), Vt(n, s));
  for (let a = 0; a !== i; ++a) t.setTextureCube(e[a] || ag, s[a]);
}
function jM(r, e, t) {
  const n = this.cache,
    i = e.length,
    s = cu(t, i);
  Ht(n, s) || (r.uniform1iv(this.addr, s), Vt(n, s));
  for (let a = 0; a !== i; ++a) t.setTexture2DArray(e[a] || rg, s[a]);
}
function KM(r) {
  switch (r) {
    case 5126:
      return PM;
    case 35664:
      return LM;
    case 35665:
      return DM;
    case 35666:
      return IM;
    case 35674:
      return NM;
    case 35675:
      return OM;
    case 35676:
      return UM;
    case 5124:
    case 35670:
      return FM;
    case 35667:
    case 35671:
      return BM;
    case 35668:
    case 35672:
      return kM;
    case 35669:
    case 35673:
      return zM;
    case 5125:
      return HM;
    case 36294:
      return VM;
    case 36295:
      return GM;
    case 36296:
      return WM;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return XM;
    case 35679:
    case 36299:
    case 36307:
      return YM;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return qM;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return jM;
  }
}
class $M {
  constructor(e, t, n) {
    (this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.setValue = CM(t.type));
  }
}
class ZM {
  constructor(e, t, n) {
    (this.id = e),
      (this.addr = n),
      (this.cache = []),
      (this.size = t.size),
      (this.setValue = KM(t.type));
  }
}
class JM {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, n) {
    const i = this.seq;
    for (let s = 0, a = i.length; s !== a; ++s) {
      const o = i[s];
      o.setValue(e, t[o.id], n);
    }
  }
}
const eh = /(\w+)(\])?(\[|\.)?/g;
function zp(r, e) {
  r.seq.push(e), (r.map[e.id] = e);
}
function QM(r, e, t) {
  const n = r.name,
    i = n.length;
  for (eh.lastIndex = 0; ; ) {
    const s = eh.exec(n),
      a = eh.lastIndex;
    let o = s[1];
    const l = s[2] === "]",
      c = s[3];
    if ((l && (o = o | 0), c === void 0 || (c === "[" && a + 2 === i))) {
      zp(t, c === void 0 ? new $M(o, r, e) : new ZM(o, r, e));
      break;
    } else {
      let h = t.map[o];
      h === void 0 && ((h = new JM(o)), zp(t, h)), (t = h);
    }
  }
}
class mc {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let i = 0; i < n; ++i) {
      const s = e.getActiveUniform(t, i),
        a = e.getUniformLocation(t, s.name);
      QM(s, a, this);
    }
  }
  setValue(e, t, n, i) {
    const s = this.map[t];
    s !== void 0 && s.setValue(e, n, i);
  }
  setOptional(e, t, n) {
    const i = t[n];
    i !== void 0 && this.setValue(e, n, i);
  }
  static upload(e, t, n, i) {
    for (let s = 0, a = t.length; s !== a; ++s) {
      const o = t[s],
        l = n[o.id];
      l.needsUpdate !== !1 && o.setValue(e, l.value, i);
    }
  }
  static seqWithValue(e, t) {
    const n = [];
    for (let i = 0, s = e.length; i !== s; ++i) {
      const a = e[i];
      a.id in t && n.push(a);
    }
    return n;
  }
}
function Hp(r, e, t) {
  const n = r.createShader(e);
  return r.shaderSource(n, t), r.compileShader(n), n;
}
let eb = 0;
function tb(r, e) {
  const t = r.split(`
`),
    n = [],
    i = Math.max(e - 6, 0),
    s = Math.min(e + 6, t.length);
  for (let a = i; a < s; a++) {
    const o = a + 1;
    n.push(`${o === e ? ">" : " "} ${o}: ${t[a]}`);
  }
  return n.join(`
`);
}
function nb(r) {
  switch (r) {
    case Ii:
      return ["Linear", "( value )"];
    case Ve:
      return ["sRGB", "( value )"];
    default:
      return (
        console.warn("THREE.WebGLProgram: Unsupported color space:", r),
        ["Linear", "( value )"]
      );
  }
}
function Vp(r, e, t) {
  const n = r.getShaderParameter(e, r.COMPILE_STATUS),
    i = r.getShaderInfoLog(e).trim();
  if (n && i === "") return "";
  const s = /ERROR: 0:(\d+)/.exec(i);
  if (s) {
    const a = parseInt(s[1]);
    return (
      t.toUpperCase() +
      `

` +
      i +
      `

` +
      tb(r.getShaderSource(e), a)
    );
  } else return i;
}
function ib(r, e) {
  const t = nb(e);
  return "vec4 " + r + "( vec4 value ) { return LinearTo" + t[0] + t[1] + "; }";
}
function rb(r, e) {
  let t;
  switch (e) {
    case ax:
      t = "Linear";
      break;
    case ox:
      t = "Reinhard";
      break;
    case lx:
      t = "OptimizedCineon";
      break;
    case cx:
      t = "ACESFilmic";
      break;
    case ux:
      t = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        (t = "Linear");
  }
  return (
    "vec3 " + r + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
  );
}
function sb(r) {
  return [
    r.extensionDerivatives ||
    r.envMapCubeUVHeight ||
    r.bumpMap ||
    r.normalMapTangentSpace ||
    r.clearcoatNormalMap ||
    r.flatShading ||
    r.shaderID === "physical"
      ? "#extension GL_OES_standard_derivatives : enable"
      : "",
    (r.extensionFragDepth || r.logarithmicDepthBuffer) &&
    r.rendererExtensionFragDepth
      ? "#extension GL_EXT_frag_depth : enable"
      : "",
    r.extensionDrawBuffers && r.rendererExtensionDrawBuffers
      ? "#extension GL_EXT_draw_buffers : require"
      : "",
    (r.extensionShaderTextureLOD || r.envMap || r.transmission) &&
    r.rendererExtensionShaderTextureLod
      ? "#extension GL_EXT_shader_texture_lod : enable"
      : "",
  ].filter(go).join(`
`);
}
function ab(r) {
  const e = [];
  for (const t in r) {
    const n = r[t];
    n !== !1 && e.push("#define " + t + " " + n);
  }
  return e.join(`
`);
}
function ob(r, e) {
  const t = {},
    n = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES);
  for (let i = 0; i < n; i++) {
    const s = r.getActiveAttrib(e, i),
      a = s.name;
    let o = 1;
    s.type === r.FLOAT_MAT2 && (o = 2),
      s.type === r.FLOAT_MAT3 && (o = 3),
      s.type === r.FLOAT_MAT4 && (o = 4),
      (t[a] = {
        type: s.type,
        location: r.getAttribLocation(e, a),
        locationSize: o,
      });
  }
  return t;
}
function go(r) {
  return r !== "";
}
function Gp(r, e) {
  const t =
    e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
  return r
    .replace(/NUM_DIR_LIGHTS/g, e.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, t)
    .replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, e.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows);
}
function Wp(r, e) {
  return r
    .replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      e.numClippingPlanes - e.numClipIntersection
    );
}
const lb = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Uh(r) {
  return r.replace(lb, cb);
}
function cb(r, e) {
  const t = Ze[e];
  if (t === void 0) throw new Error("Can not resolve #include <" + e + ">");
  return Uh(t);
}
const ub =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Xp(r) {
  return r.replace(ub, hb);
}
function hb(r, e, t, n) {
  let i = "";
  for (let s = parseInt(e); s < parseInt(t); s++)
    i += n
      .replace(/\[\s*i\s*\]/g, "[ " + s + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, s);
  return i;
}
function Yp(r) {
  let e =
    "precision " +
    r.precision +
    ` float;
precision ` +
    r.precision +
    " int;";
  return (
    r.precision === "highp"
      ? (e += `
#define HIGH_PRECISION`)
      : r.precision === "mediump"
      ? (e += `
#define MEDIUM_PRECISION`)
      : r.precision === "lowp" &&
        (e += `
#define LOW_PRECISION`),
    e
  );
}
function fb(r) {
  let e = "SHADOWMAP_TYPE_BASIC";
  return (
    r.shadowMapType === I_
      ? (e = "SHADOWMAP_TYPE_PCF")
      : r.shadowMapType === Bv
      ? (e = "SHADOWMAP_TYPE_PCF_SOFT")
      : r.shadowMapType === ji && (e = "SHADOWMAP_TYPE_VSM"),
    e
  );
}
function db(r) {
  let e = "ENVMAP_TYPE_CUBE";
  if (r.envMap)
    switch (r.envMapMode) {
      case Ia:
      case Na:
        e = "ENVMAP_TYPE_CUBE";
        break;
      case su:
        e = "ENVMAP_TYPE_CUBE_UV";
        break;
    }
  return e;
}
function pb(r) {
  let e = "ENVMAP_MODE_REFLECTION";
  if (r.envMap)
    switch (r.envMapMode) {
      case Na:
        e = "ENVMAP_MODE_REFRACTION";
        break;
    }
  return e;
}
function mb(r) {
  let e = "ENVMAP_BLENDING_NONE";
  if (r.envMap)
    switch (r.combine) {
      case U_:
        e = "ENVMAP_BLENDING_MULTIPLY";
        break;
      case rx:
        e = "ENVMAP_BLENDING_MIX";
        break;
      case sx:
        e = "ENVMAP_BLENDING_ADD";
        break;
    }
  return e;
}
function _b(r) {
  const e = r.envMapCubeUVHeight;
  if (e === null) return null;
  const t = Math.log2(e) - 2,
    n = 1 / e;
  return {
    texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
    texelHeight: n,
    maxMip: t,
  };
}
function gb(r, e, t, n) {
  const i = r.getContext(),
    s = t.defines;
  let a = t.vertexShader,
    o = t.fragmentShader;
  const l = fb(t),
    c = db(t),
    u = pb(t),
    h = mb(t),
    f = _b(t),
    p = t.isWebGL2 ? "" : sb(t),
    g = ab(s),
    m = i.createProgram();
  let _,
    d,
    y = t.glslVersion
      ? "#version " +
        t.glslVersion +
        `
`
      : "";
  t.isRawShaderMaterial
    ? ((_ = [g].filter(go).join(`
`)),
      _.length > 0 &&
        (_ += `
`),
      (d = [p, g].filter(go).join(`
`)),
      d.length > 0 &&
        (d += `
`))
    : ((_ = [
        Yp(t),
        "#define SHADER_NAME " + t.shaderName,
        g,
        t.instancing ? "#define USE_INSTANCING" : "",
        t.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + u : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.mapUv ? "#define MAP_UV " + t.mapUv : "",
        t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "",
        t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "",
        t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "",
        t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "",
        t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "",
        t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "",
        t.displacementMapUv
          ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv
          : "",
        t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "",
        t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "",
        t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "",
        t.clearcoatNormalMapUv
          ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv
          : "",
        t.clearcoatRoughnessMapUv
          ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv
          : "",
        t.iridescenceMapUv
          ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv
          : "",
        t.iridescenceThicknessMapUv
          ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv
          : "",
        t.sheenColorMapUv
          ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv
          : "",
        t.sheenRoughnessMapUv
          ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv
          : "",
        t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "",
        t.specularColorMapUv
          ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv
          : "",
        t.specularIntensityMapUv
          ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv
          : "",
        t.transmissionMapUv
          ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv
          : "",
        t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "",
        t.vertexTangents ? "#define USE_TANGENT" : "",
        t.vertexColors ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.skinning ? "#define USE_SKINNING" : "",
        t.morphTargets ? "#define USE_MORPHTARGETS" : "",
        t.morphNormals && t.flatShading === !1
          ? "#define USE_MORPHNORMALS"
          : "",
        t.morphColors && t.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE"
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride
          : "",
        t.morphTargetsCount > 0 && t.isWebGL2
          ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount
          : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 modelMatrix;",
        "uniform mat4 modelViewMatrix;",
        "uniform mat4 projectionMatrix;",
        "uniform mat4 viewMatrix;",
        "uniform mat3 normalMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        "#ifdef USE_INSTANCING",
        "	attribute mat4 instanceMatrix;",
        "#endif",
        "#ifdef USE_INSTANCING_COLOR",
        "	attribute vec3 instanceColor;",
        "#endif",
        "attribute vec3 position;",
        "attribute vec3 normal;",
        "attribute vec2 uv;",
        "#ifdef USE_UV1",
        "	attribute vec2 uv1;",
        "#endif",
        "#ifdef USE_UV2",
        "	attribute vec2 uv2;",
        "#endif",
        "#ifdef USE_UV3",
        "	attribute vec2 uv3;",
        "#endif",
        "#ifdef USE_TANGENT",
        "	attribute vec4 tangent;",
        "#endif",
        "#if defined( USE_COLOR_ALPHA )",
        "	attribute vec4 color;",
        "#elif defined( USE_COLOR )",
        "	attribute vec3 color;",
        "#endif",
        "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
        "	attribute vec3 morphTarget0;",
        "	attribute vec3 morphTarget1;",
        "	attribute vec3 morphTarget2;",
        "	attribute vec3 morphTarget3;",
        "	#ifdef USE_MORPHNORMALS",
        "		attribute vec3 morphNormal0;",
        "		attribute vec3 morphNormal1;",
        "		attribute vec3 morphNormal2;",
        "		attribute vec3 morphNormal3;",
        "	#else",
        "		attribute vec3 morphTarget4;",
        "		attribute vec3 morphTarget5;",
        "		attribute vec3 morphTarget6;",
        "		attribute vec3 morphTarget7;",
        "	#endif",
        "#endif",
        "#ifdef USE_SKINNING",
        "	attribute vec4 skinIndex;",
        "	attribute vec4 skinWeight;",
        "#endif",
        `
`,
      ].filter(go).join(`
`)),
      (d = [
        p,
        Yp(t),
        "#define SHADER_NAME " + t.shaderName,
        g,
        t.useFog && t.fog ? "#define USE_FOG" : "",
        t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "",
        t.map ? "#define USE_MAP" : "",
        t.matcap ? "#define USE_MATCAP" : "",
        t.envMap ? "#define USE_ENVMAP" : "",
        t.envMap ? "#define " + c : "",
        t.envMap ? "#define " + u : "",
        t.envMap ? "#define " + h : "",
        f ? "#define CUBEUV_TEXEL_WIDTH " + f.texelWidth : "",
        f ? "#define CUBEUV_TEXEL_HEIGHT " + f.texelHeight : "",
        f ? "#define CUBEUV_MAX_MIP " + f.maxMip + ".0" : "",
        t.lightMap ? "#define USE_LIGHTMAP" : "",
        t.aoMap ? "#define USE_AOMAP" : "",
        t.bumpMap ? "#define USE_BUMPMAP" : "",
        t.normalMap ? "#define USE_NORMALMAP" : "",
        t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
        t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
        t.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
        t.clearcoat ? "#define USE_CLEARCOAT" : "",
        t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
        t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
        t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
        t.iridescence ? "#define USE_IRIDESCENCE" : "",
        t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
        t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
        t.specularMap ? "#define USE_SPECULARMAP" : "",
        t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
        t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
        t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
        t.metalnessMap ? "#define USE_METALNESSMAP" : "",
        t.alphaMap ? "#define USE_ALPHAMAP" : "",
        t.alphaTest ? "#define USE_ALPHATEST" : "",
        t.sheen ? "#define USE_SHEEN" : "",
        t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
        t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
        t.transmission ? "#define USE_TRANSMISSION" : "",
        t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
        t.thicknessMap ? "#define USE_THICKNESSMAP" : "",
        t.vertexTangents ? "#define USE_TANGENT" : "",
        t.vertexColors || t.instancingColor ? "#define USE_COLOR" : "",
        t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
        t.vertexUv1s ? "#define USE_UV1" : "",
        t.vertexUv2s ? "#define USE_UV2" : "",
        t.vertexUv3s ? "#define USE_UV3" : "",
        t.pointsUvs ? "#define USE_POINTS_UV" : "",
        t.gradientMap ? "#define USE_GRADIENTMAP" : "",
        t.flatShading ? "#define FLAT_SHADED" : "",
        t.doubleSided ? "#define DOUBLE_SIDED" : "",
        t.flipSided ? "#define FLIP_SIDED" : "",
        t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
        t.shadowMapEnabled ? "#define " + l : "",
        t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
        t.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
        t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
        t.logarithmicDepthBuffer && t.rendererExtensionFragDepth
          ? "#define USE_LOGDEPTHBUF_EXT"
          : "",
        "uniform mat4 viewMatrix;",
        "uniform vec3 cameraPosition;",
        "uniform bool isOrthographic;",
        t.toneMapping !== rr ? "#define TONE_MAPPING" : "",
        t.toneMapping !== rr ? Ze.tonemapping_pars_fragment : "",
        t.toneMapping !== rr ? rb("toneMapping", t.toneMapping) : "",
        t.dithering ? "#define DITHERING" : "",
        t.opaque ? "#define OPAQUE" : "",
        Ze.encodings_pars_fragment,
        ib("linearToOutputTexel", t.outputColorSpace),
        t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "",
        `
`,
      ].filter(go).join(`
`))),
    (a = Uh(a)),
    (a = Gp(a, t)),
    (a = Wp(a, t)),
    (o = Uh(o)),
    (o = Gp(o, t)),
    (o = Wp(o, t)),
    (a = Xp(a)),
    (o = Xp(o)),
    t.isWebGL2 &&
      t.isRawShaderMaterial !== !0 &&
      ((y = `#version 300 es
`),
      (_ =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join(`
`) +
        `
` +
        _),
      (d =
        [
          "#define varying in",
          t.glslVersion === hp
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          t.glslVersion === hp ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join(`
`) +
        `
` +
        d));
  const v = y + _ + a,
    S = y + d + o,
    E = Hp(i, i.VERTEX_SHADER, v),
    b = Hp(i, i.FRAGMENT_SHADER, S);
  if (
    (i.attachShader(m, E),
    i.attachShader(m, b),
    t.index0AttributeName !== void 0
      ? i.bindAttribLocation(m, 0, t.index0AttributeName)
      : t.morphTargets === !0 && i.bindAttribLocation(m, 0, "position"),
    i.linkProgram(m),
    r.debug.checkShaderErrors)
  ) {
    const x = i.getProgramInfoLog(m).trim(),
      T = i.getShaderInfoLog(E).trim(),
      D = i.getShaderInfoLog(b).trim();
    let N = !0,
      L = !0;
    if (i.getProgramParameter(m, i.LINK_STATUS) === !1)
      if (((N = !1), typeof r.debug.onShaderError == "function"))
        r.debug.onShaderError(i, m, E, b);
      else {
        const F = Vp(i, E, "vertex"),
          I = Vp(i, b, "fragment");
        console.error(
          "THREE.WebGLProgram: Shader Error " +
            i.getError() +
            " - VALIDATE_STATUS " +
            i.getProgramParameter(m, i.VALIDATE_STATUS) +
            `

Program Info Log: ` +
            x +
            `
` +
            F +
            `
` +
            I
        );
      }
    else
      x !== ""
        ? console.warn("THREE.WebGLProgram: Program Info Log:", x)
        : (T === "" || D === "") && (L = !1);
    L &&
      (this.diagnostics = {
        runnable: N,
        programLog: x,
        vertexShader: { log: T, prefix: _ },
        fragmentShader: { log: D, prefix: d },
      });
  }
  i.deleteShader(E), i.deleteShader(b);
  let M;
  this.getUniforms = function () {
    return M === void 0 && (M = new mc(i, m)), M;
  };
  let C;
  return (
    (this.getAttributes = function () {
      return C === void 0 && (C = ob(i, m)), C;
    }),
    (this.destroy = function () {
      n.releaseStatesOfProgram(this),
        i.deleteProgram(m),
        (this.program = void 0);
    }),
    (this.name = t.shaderName),
    (this.id = eb++),
    (this.cacheKey = e),
    (this.usedTimes = 1),
    (this.program = m),
    (this.vertexShader = E),
    (this.fragmentShader = b),
    this
  );
}
let vb = 0;
class xb {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      n = e.fragmentShader,
      i = this._getShaderStage(t),
      s = this._getShaderStage(n),
      a = this._getShaderCacheForMaterial(e);
    return (
      a.has(i) === !1 && (a.add(i), i.usedTimes++),
      a.has(s) === !1 && (a.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const n of t)
      n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let n = t.get(e);
    return n === void 0 && ((n = new Set()), t.set(e, n)), n;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let n = t.get(e);
    return n === void 0 && ((n = new yb(e)), t.set(e, n)), n;
  }
}
class yb {
  constructor(e) {
    (this.id = vb++), (this.code = e), (this.usedTimes = 0);
  }
}
function Eb(r, e, t, n, i, s, a) {
  const o = new Rf(),
    l = new xb(),
    c = [],
    u = i.isWebGL2,
    h = i.logarithmicDepthBuffer,
    f = i.vertexTextures;
  let p = i.precision;
  const g = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function m(x) {
    return x === 1 ? "uv1" : x === 2 ? "uv2" : x === 3 ? "uv3" : "uv";
  }
  function _(x, T, D, N, L) {
    const F = N.fog,
      I = L.geometry,
      j = x.isMeshStandardMaterial ? N.environment : null,
      A = (x.isMeshStandardMaterial ? t : e).get(x.envMap || j),
      k = A && A.mapping === su ? A.image.height : null,
      G = g[x.type];
    x.precision !== null &&
      ((p = i.getMaxPrecision(x.precision)),
      p !== x.precision &&
        console.warn(
          "THREE.WebGLProgram.getParameters:",
          x.precision,
          "not supported, using",
          p,
          "instead."
        ));
    const z =
        I.morphAttributes.position ||
        I.morphAttributes.normal ||
        I.morphAttributes.color,
      oe = z !== void 0 ? z.length : 0;
    let te = 0;
    I.morphAttributes.position !== void 0 && (te = 1),
      I.morphAttributes.normal !== void 0 && (te = 2),
      I.morphAttributes.color !== void 0 && (te = 3);
    let X, Y, le, W;
    if (G) {
      const de = Ai[G];
      (X = de.vertexShader), (Y = de.fragmentShader);
    } else
      (X = x.vertexShader),
        (Y = x.fragmentShader),
        l.update(x),
        (le = l.getVertexShaderID(x)),
        (W = l.getFragmentShaderID(x));
    const O = r.getRenderTarget(),
      Me = L.isInstancedMesh === !0,
      ve = !!x.map,
      re = !!x.matcap,
      be = !!A,
      Fe = !!x.aoMap,
      ae = !!x.lightMap,
      _e = !!x.bumpMap,
      K = !!x.normalMap,
      $e = !!x.displacementMap,
      ct = !!x.emissiveMap,
      Ge = !!x.metalnessMap,
      Xe = !!x.roughnessMap,
      st = x.clearcoat > 0,
      Et = x.iridescence > 0,
      P = x.sheen > 0,
      w = x.transmission > 0,
      $ = st && !!x.clearcoatMap,
      ue = st && !!x.clearcoatNormalMap,
      he = st && !!x.clearcoatRoughnessMap,
      me = Et && !!x.iridescenceMap,
      U = Et && !!x.iridescenceThicknessMap,
      ne = P && !!x.sheenColorMap,
      J = P && !!x.sheenRoughnessMap,
      ge = !!x.specularMap,
      Te = !!x.specularColorMap,
      Le = !!x.specularIntensityMap,
      ye = w && !!x.transmissionMap,
      Ae = w && !!x.thicknessMap,
      xe = !!x.gradientMap,
      ze = !!x.alphaMap,
      ot = x.alphaTest > 0,
      B = !!x.extensions,
      Q = !!I.attributes.uv1,
      fe = !!I.attributes.uv2,
      Se = !!I.attributes.uv3;
    return {
      isWebGL2: u,
      shaderID: G,
      shaderName: x.type,
      vertexShader: X,
      fragmentShader: Y,
      defines: x.defines,
      customVertexShaderID: le,
      customFragmentShaderID: W,
      isRawShaderMaterial: x.isRawShaderMaterial === !0,
      glslVersion: x.glslVersion,
      precision: p,
      instancing: Me,
      instancingColor: Me && L.instanceColor !== null,
      supportsVertexTextures: f,
      outputColorSpace:
        O === null
          ? r.outputColorSpace
          : O.isXRRenderTarget === !0
          ? O.texture.colorSpace
          : Ii,
      map: ve,
      matcap: re,
      envMap: be,
      envMapMode: be && A.mapping,
      envMapCubeUVHeight: k,
      aoMap: Fe,
      lightMap: ae,
      bumpMap: _e,
      normalMap: K,
      displacementMap: f && $e,
      emissiveMap: ct,
      normalMapObjectSpace: K && x.normalMapType === Px,
      normalMapTangentSpace: K && x.normalMapType === V_,
      metalnessMap: Ge,
      roughnessMap: Xe,
      clearcoat: st,
      clearcoatMap: $,
      clearcoatNormalMap: ue,
      clearcoatRoughnessMap: he,
      iridescence: Et,
      iridescenceMap: me,
      iridescenceThicknessMap: U,
      sheen: P,
      sheenColorMap: ne,
      sheenRoughnessMap: J,
      specularMap: ge,
      specularColorMap: Te,
      specularIntensityMap: Le,
      transmission: w,
      transmissionMap: ye,
      thicknessMap: Ae,
      gradientMap: xe,
      opaque: x.transparent === !1 && x.blending === Sa,
      alphaMap: ze,
      alphaTest: ot,
      combine: x.combine,
      mapUv: ve && m(x.map.channel),
      aoMapUv: Fe && m(x.aoMap.channel),
      lightMapUv: ae && m(x.lightMap.channel),
      bumpMapUv: _e && m(x.bumpMap.channel),
      normalMapUv: K && m(x.normalMap.channel),
      displacementMapUv: $e && m(x.displacementMap.channel),
      emissiveMapUv: ct && m(x.emissiveMap.channel),
      metalnessMapUv: Ge && m(x.metalnessMap.channel),
      roughnessMapUv: Xe && m(x.roughnessMap.channel),
      clearcoatMapUv: $ && m(x.clearcoatMap.channel),
      clearcoatNormalMapUv: ue && m(x.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: he && m(x.clearcoatRoughnessMap.channel),
      iridescenceMapUv: me && m(x.iridescenceMap.channel),
      iridescenceThicknessMapUv: U && m(x.iridescenceThicknessMap.channel),
      sheenColorMapUv: ne && m(x.sheenColorMap.channel),
      sheenRoughnessMapUv: J && m(x.sheenRoughnessMap.channel),
      specularMapUv: ge && m(x.specularMap.channel),
      specularColorMapUv: Te && m(x.specularColorMap.channel),
      specularIntensityMapUv: Le && m(x.specularIntensityMap.channel),
      transmissionMapUv: ye && m(x.transmissionMap.channel),
      thicknessMapUv: Ae && m(x.thicknessMap.channel),
      alphaMapUv: ze && m(x.alphaMap.channel),
      vertexTangents: K && !!I.attributes.tangent,
      vertexColors: x.vertexColors,
      vertexAlphas:
        x.vertexColors === !0 &&
        !!I.attributes.color &&
        I.attributes.color.itemSize === 4,
      vertexUv1s: Q,
      vertexUv2s: fe,
      vertexUv3s: Se,
      pointsUvs: L.isPoints === !0 && !!I.attributes.uv && (ve || ze),
      fog: !!F,
      useFog: x.fog === !0,
      fogExp2: F && F.isFogExp2,
      flatShading: x.flatShading === !0,
      sizeAttenuation: x.sizeAttenuation === !0,
      logarithmicDepthBuffer: h,
      skinning: L.isSkinnedMesh === !0,
      morphTargets: I.morphAttributes.position !== void 0,
      morphNormals: I.morphAttributes.normal !== void 0,
      morphColors: I.morphAttributes.color !== void 0,
      morphTargetsCount: oe,
      morphTextureStride: te,
      numDirLights: T.directional.length,
      numPointLights: T.point.length,
      numSpotLights: T.spot.length,
      numSpotLightMaps: T.spotLightMap.length,
      numRectAreaLights: T.rectArea.length,
      numHemiLights: T.hemi.length,
      numDirLightShadows: T.directionalShadowMap.length,
      numPointLightShadows: T.pointShadowMap.length,
      numSpotLightShadows: T.spotShadowMap.length,
      numSpotLightShadowsWithMaps: T.numSpotLightShadowsWithMaps,
      numClippingPlanes: a.numPlanes,
      numClipIntersection: a.numIntersection,
      dithering: x.dithering,
      shadowMapEnabled: r.shadowMap.enabled && D.length > 0,
      shadowMapType: r.shadowMap.type,
      toneMapping: x.toneMapped ? r.toneMapping : rr,
      useLegacyLights: r.useLegacyLights,
      premultipliedAlpha: x.premultipliedAlpha,
      doubleSided: x.side === wi,
      flipSided: x.side === bn,
      useDepthPacking: x.depthPacking >= 0,
      depthPacking: x.depthPacking || 0,
      index0AttributeName: x.index0AttributeName,
      extensionDerivatives: B && x.extensions.derivatives === !0,
      extensionFragDepth: B && x.extensions.fragDepth === !0,
      extensionDrawBuffers: B && x.extensions.drawBuffers === !0,
      extensionShaderTextureLOD: B && x.extensions.shaderTextureLOD === !0,
      rendererExtensionFragDepth: u || n.has("EXT_frag_depth"),
      rendererExtensionDrawBuffers: u || n.has("WEBGL_draw_buffers"),
      rendererExtensionShaderTextureLod: u || n.has("EXT_shader_texture_lod"),
      customProgramCacheKey: x.customProgramCacheKey(),
    };
  }
  function d(x) {
    const T = [];
    if (
      (x.shaderID
        ? T.push(x.shaderID)
        : (T.push(x.customVertexShaderID), T.push(x.customFragmentShaderID)),
      x.defines !== void 0)
    )
      for (const D in x.defines) T.push(D), T.push(x.defines[D]);
    return (
      x.isRawShaderMaterial === !1 &&
        (y(T, x), v(T, x), T.push(r.outputColorSpace)),
      T.push(x.customProgramCacheKey),
      T.join()
    );
  }
  function y(x, T) {
    x.push(T.precision),
      x.push(T.outputColorSpace),
      x.push(T.envMapMode),
      x.push(T.envMapCubeUVHeight),
      x.push(T.mapUv),
      x.push(T.alphaMapUv),
      x.push(T.lightMapUv),
      x.push(T.aoMapUv),
      x.push(T.bumpMapUv),
      x.push(T.normalMapUv),
      x.push(T.displacementMapUv),
      x.push(T.emissiveMapUv),
      x.push(T.metalnessMapUv),
      x.push(T.roughnessMapUv),
      x.push(T.clearcoatMapUv),
      x.push(T.clearcoatNormalMapUv),
      x.push(T.clearcoatRoughnessMapUv),
      x.push(T.iridescenceMapUv),
      x.push(T.iridescenceThicknessMapUv),
      x.push(T.sheenColorMapUv),
      x.push(T.sheenRoughnessMapUv),
      x.push(T.specularMapUv),
      x.push(T.specularColorMapUv),
      x.push(T.specularIntensityMapUv),
      x.push(T.transmissionMapUv),
      x.push(T.thicknessMapUv),
      x.push(T.combine),
      x.push(T.fogExp2),
      x.push(T.sizeAttenuation),
      x.push(T.morphTargetsCount),
      x.push(T.morphAttributeCount),
      x.push(T.numDirLights),
      x.push(T.numPointLights),
      x.push(T.numSpotLights),
      x.push(T.numSpotLightMaps),
      x.push(T.numHemiLights),
      x.push(T.numRectAreaLights),
      x.push(T.numDirLightShadows),
      x.push(T.numPointLightShadows),
      x.push(T.numSpotLightShadows),
      x.push(T.numSpotLightShadowsWithMaps),
      x.push(T.shadowMapType),
      x.push(T.toneMapping),
      x.push(T.numClippingPlanes),
      x.push(T.numClipIntersection),
      x.push(T.depthPacking);
  }
  function v(x, T) {
    o.disableAll(),
      T.isWebGL2 && o.enable(0),
      T.supportsVertexTextures && o.enable(1),
      T.instancing && o.enable(2),
      T.instancingColor && o.enable(3),
      T.matcap && o.enable(4),
      T.envMap && o.enable(5),
      T.normalMapObjectSpace && o.enable(6),
      T.normalMapTangentSpace && o.enable(7),
      T.clearcoat && o.enable(8),
      T.iridescence && o.enable(9),
      T.alphaTest && o.enable(10),
      T.vertexColors && o.enable(11),
      T.vertexAlphas && o.enable(12),
      T.vertexUv1s && o.enable(13),
      T.vertexUv2s && o.enable(14),
      T.vertexUv3s && o.enable(15),
      T.vertexTangents && o.enable(16),
      x.push(o.mask),
      o.disableAll(),
      T.fog && o.enable(0),
      T.useFog && o.enable(1),
      T.flatShading && o.enable(2),
      T.logarithmicDepthBuffer && o.enable(3),
      T.skinning && o.enable(4),
      T.morphTargets && o.enable(5),
      T.morphNormals && o.enable(6),
      T.morphColors && o.enable(7),
      T.premultipliedAlpha && o.enable(8),
      T.shadowMapEnabled && o.enable(9),
      T.useLegacyLights && o.enable(10),
      T.doubleSided && o.enable(11),
      T.flipSided && o.enable(12),
      T.useDepthPacking && o.enable(13),
      T.dithering && o.enable(14),
      T.transmission && o.enable(15),
      T.sheen && o.enable(16),
      T.opaque && o.enable(17),
      T.pointsUvs && o.enable(18),
      x.push(o.mask);
  }
  function S(x) {
    const T = g[x.type];
    let D;
    if (T) {
      const N = Ai[T];
      D = uy.clone(N.uniforms);
    } else D = x.uniforms;
    return D;
  }
  function E(x, T) {
    let D;
    for (let N = 0, L = c.length; N < L; N++) {
      const F = c[N];
      if (F.cacheKey === T) {
        (D = F), ++D.usedTimes;
        break;
      }
    }
    return D === void 0 && ((D = new gb(r, T, x, s)), c.push(D)), D;
  }
  function b(x) {
    if (--x.usedTimes === 0) {
      const T = c.indexOf(x);
      (c[T] = c[c.length - 1]), c.pop(), x.destroy();
    }
  }
  function M(x) {
    l.remove(x);
  }
  function C() {
    l.dispose();
  }
  return {
    getParameters: _,
    getProgramCacheKey: d,
    getUniforms: S,
    acquireProgram: E,
    releaseProgram: b,
    releaseShaderCache: M,
    programs: c,
    dispose: C,
  };
}
function Sb() {
  let r = new WeakMap();
  function e(s) {
    let a = r.get(s);
    return a === void 0 && ((a = {}), r.set(s, a)), a;
  }
  function t(s) {
    r.delete(s);
  }
  function n(s, a, o) {
    r.get(s)[a] = o;
  }
  function i() {
    r = new WeakMap();
  }
  return { get: e, remove: t, update: n, dispose: i };
}
function Mb(r, e) {
  return r.groupOrder !== e.groupOrder
    ? r.groupOrder - e.groupOrder
    : r.renderOrder !== e.renderOrder
    ? r.renderOrder - e.renderOrder
    : r.material.id !== e.material.id
    ? r.material.id - e.material.id
    : r.z !== e.z
    ? r.z - e.z
    : r.id - e.id;
}
function qp(r, e) {
  return r.groupOrder !== e.groupOrder
    ? r.groupOrder - e.groupOrder
    : r.renderOrder !== e.renderOrder
    ? r.renderOrder - e.renderOrder
    : r.z !== e.z
    ? e.z - r.z
    : r.id - e.id;
}
function jp() {
  const r = [];
  let e = 0;
  const t = [],
    n = [],
    i = [];
  function s() {
    (e = 0), (t.length = 0), (n.length = 0), (i.length = 0);
  }
  function a(h, f, p, g, m, _) {
    let d = r[e];
    return (
      d === void 0
        ? ((d = {
            id: h.id,
            object: h,
            geometry: f,
            material: p,
            groupOrder: g,
            renderOrder: h.renderOrder,
            z: m,
            group: _,
          }),
          (r[e] = d))
        : ((d.id = h.id),
          (d.object = h),
          (d.geometry = f),
          (d.material = p),
          (d.groupOrder = g),
          (d.renderOrder = h.renderOrder),
          (d.z = m),
          (d.group = _)),
      e++,
      d
    );
  }
  function o(h, f, p, g, m, _) {
    const d = a(h, f, p, g, m, _);
    p.transmission > 0
      ? n.push(d)
      : p.transparent === !0
      ? i.push(d)
      : t.push(d);
  }
  function l(h, f, p, g, m, _) {
    const d = a(h, f, p, g, m, _);
    p.transmission > 0
      ? n.unshift(d)
      : p.transparent === !0
      ? i.unshift(d)
      : t.unshift(d);
  }
  function c(h, f) {
    t.length > 1 && t.sort(h || Mb),
      n.length > 1 && n.sort(f || qp),
      i.length > 1 && i.sort(f || qp);
  }
  function u() {
    for (let h = e, f = r.length; h < f; h++) {
      const p = r[h];
      if (p.id === null) break;
      (p.id = null),
        (p.object = null),
        (p.geometry = null),
        (p.material = null),
        (p.group = null);
    }
  }
  return {
    opaque: t,
    transmissive: n,
    transparent: i,
    init: s,
    push: o,
    unshift: l,
    finish: u,
    sort: c,
  };
}
function bb() {
  let r = new WeakMap();
  function e(n, i) {
    const s = r.get(n);
    let a;
    return (
      s === void 0
        ? ((a = new jp()), r.set(n, [a]))
        : i >= s.length
        ? ((a = new jp()), s.push(a))
        : (a = s[i]),
      a
    );
  }
  function t() {
    r = new WeakMap();
  }
  return { get: e, dispose: t };
}
function Tb() {
  const r = {};
  return {
    get: function (e) {
      if (r[e.id] !== void 0) return r[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = { direction: new H(), color: new Ke() };
          break;
        case "SpotLight":
          t = {
            position: new H(),
            direction: new H(),
            color: new Ke(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          t = { position: new H(), color: new Ke(), distance: 0, decay: 0 };
          break;
        case "HemisphereLight":
          t = { direction: new H(), skyColor: new Ke(), groundColor: new Ke() };
          break;
        case "RectAreaLight":
          t = {
            color: new Ke(),
            position: new H(),
            halfWidth: new H(),
            halfHeight: new H(),
          };
          break;
      }
      return (r[e.id] = t), t;
    },
  };
}
function Ab() {
  const r = {};
  return {
    get: function (e) {
      if (r[e.id] !== void 0) return r[e.id];
      let t;
      switch (e.type) {
        case "DirectionalLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new We(),
          };
          break;
        case "SpotLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new We(),
          };
          break;
        case "PointLight":
          t = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new We(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          };
          break;
      }
      return (r[e.id] = t), t;
    },
  };
}
let wb = 0;
function Rb(r, e) {
  return (
    (e.castShadow ? 2 : 0) -
    (r.castShadow ? 2 : 0) +
    (e.map ? 1 : 0) -
    (r.map ? 1 : 0)
  );
}
function Cb(r, e) {
  const t = new Tb(),
    n = Ab(),
    i = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
    };
  for (let u = 0; u < 9; u++) i.probe.push(new H());
  const s = new H(),
    a = new et(),
    o = new et();
  function l(u, h) {
    let f = 0,
      p = 0,
      g = 0;
    for (let D = 0; D < 9; D++) i.probe[D].set(0, 0, 0);
    let m = 0,
      _ = 0,
      d = 0,
      y = 0,
      v = 0,
      S = 0,
      E = 0,
      b = 0,
      M = 0,
      C = 0;
    u.sort(Rb);
    const x = h === !0 ? Math.PI : 1;
    for (let D = 0, N = u.length; D < N; D++) {
      const L = u[D],
        F = L.color,
        I = L.intensity,
        j = L.distance,
        A = L.shadow && L.shadow.map ? L.shadow.map.texture : null;
      if (L.isAmbientLight)
        (f += F.r * I * x), (p += F.g * I * x), (g += F.b * I * x);
      else if (L.isLightProbe)
        for (let k = 0; k < 9; k++)
          i.probe[k].addScaledVector(L.sh.coefficients[k], I);
      else if (L.isDirectionalLight) {
        const k = t.get(L);
        if (
          (k.color.copy(L.color).multiplyScalar(L.intensity * x), L.castShadow)
        ) {
          const G = L.shadow,
            z = n.get(L);
          (z.shadowBias = G.bias),
            (z.shadowNormalBias = G.normalBias),
            (z.shadowRadius = G.radius),
            (z.shadowMapSize = G.mapSize),
            (i.directionalShadow[m] = z),
            (i.directionalShadowMap[m] = A),
            (i.directionalShadowMatrix[m] = L.shadow.matrix),
            S++;
        }
        (i.directional[m] = k), m++;
      } else if (L.isSpotLight) {
        const k = t.get(L);
        k.position.setFromMatrixPosition(L.matrixWorld),
          k.color.copy(F).multiplyScalar(I * x),
          (k.distance = j),
          (k.coneCos = Math.cos(L.angle)),
          (k.penumbraCos = Math.cos(L.angle * (1 - L.penumbra))),
          (k.decay = L.decay),
          (i.spot[d] = k);
        const G = L.shadow;
        if (
          (L.map &&
            ((i.spotLightMap[M] = L.map),
            M++,
            G.updateMatrices(L),
            L.castShadow && C++),
          (i.spotLightMatrix[d] = G.matrix),
          L.castShadow)
        ) {
          const z = n.get(L);
          (z.shadowBias = G.bias),
            (z.shadowNormalBias = G.normalBias),
            (z.shadowRadius = G.radius),
            (z.shadowMapSize = G.mapSize),
            (i.spotShadow[d] = z),
            (i.spotShadowMap[d] = A),
            b++;
        }
        d++;
      } else if (L.isRectAreaLight) {
        const k = t.get(L);
        k.color.copy(F).multiplyScalar(I),
          k.halfWidth.set(L.width * 0.5, 0, 0),
          k.halfHeight.set(0, L.height * 0.5, 0),
          (i.rectArea[y] = k),
          y++;
      } else if (L.isPointLight) {
        const k = t.get(L);
        if (
          (k.color.copy(L.color).multiplyScalar(L.intensity * x),
          (k.distance = L.distance),
          (k.decay = L.decay),
          L.castShadow)
        ) {
          const G = L.shadow,
            z = n.get(L);
          (z.shadowBias = G.bias),
            (z.shadowNormalBias = G.normalBias),
            (z.shadowRadius = G.radius),
            (z.shadowMapSize = G.mapSize),
            (z.shadowCameraNear = G.camera.near),
            (z.shadowCameraFar = G.camera.far),
            (i.pointShadow[_] = z),
            (i.pointShadowMap[_] = A),
            (i.pointShadowMatrix[_] = L.shadow.matrix),
            E++;
        }
        (i.point[_] = k), _++;
      } else if (L.isHemisphereLight) {
        const k = t.get(L);
        k.skyColor.copy(L.color).multiplyScalar(I * x),
          k.groundColor.copy(L.groundColor).multiplyScalar(I * x),
          (i.hemi[v] = k),
          v++;
      }
    }
    y > 0 &&
      (e.isWebGL2 || r.has("OES_texture_float_linear") === !0
        ? ((i.rectAreaLTC1 = Ee.LTC_FLOAT_1), (i.rectAreaLTC2 = Ee.LTC_FLOAT_2))
        : r.has("OES_texture_half_float_linear") === !0
        ? ((i.rectAreaLTC1 = Ee.LTC_HALF_1), (i.rectAreaLTC2 = Ee.LTC_HALF_2))
        : console.error(
            "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
          )),
      (i.ambient[0] = f),
      (i.ambient[1] = p),
      (i.ambient[2] = g);
    const T = i.hash;
    (T.directionalLength !== m ||
      T.pointLength !== _ ||
      T.spotLength !== d ||
      T.rectAreaLength !== y ||
      T.hemiLength !== v ||
      T.numDirectionalShadows !== S ||
      T.numPointShadows !== E ||
      T.numSpotShadows !== b ||
      T.numSpotMaps !== M) &&
      ((i.directional.length = m),
      (i.spot.length = d),
      (i.rectArea.length = y),
      (i.point.length = _),
      (i.hemi.length = v),
      (i.directionalShadow.length = S),
      (i.directionalShadowMap.length = S),
      (i.pointShadow.length = E),
      (i.pointShadowMap.length = E),
      (i.spotShadow.length = b),
      (i.spotShadowMap.length = b),
      (i.directionalShadowMatrix.length = S),
      (i.pointShadowMatrix.length = E),
      (i.spotLightMatrix.length = b + M - C),
      (i.spotLightMap.length = M),
      (i.numSpotLightShadowsWithMaps = C),
      (T.directionalLength = m),
      (T.pointLength = _),
      (T.spotLength = d),
      (T.rectAreaLength = y),
      (T.hemiLength = v),
      (T.numDirectionalShadows = S),
      (T.numPointShadows = E),
      (T.numSpotShadows = b),
      (T.numSpotMaps = M),
      (i.version = wb++));
  }
  function c(u, h) {
    let f = 0,
      p = 0,
      g = 0,
      m = 0,
      _ = 0;
    const d = h.matrixWorldInverse;
    for (let y = 0, v = u.length; y < v; y++) {
      const S = u[y];
      if (S.isDirectionalLight) {
        const E = i.directional[f];
        E.direction.setFromMatrixPosition(S.matrixWorld),
          s.setFromMatrixPosition(S.target.matrixWorld),
          E.direction.sub(s),
          E.direction.transformDirection(d),
          f++;
      } else if (S.isSpotLight) {
        const E = i.spot[g];
        E.position.setFromMatrixPosition(S.matrixWorld),
          E.position.applyMatrix4(d),
          E.direction.setFromMatrixPosition(S.matrixWorld),
          s.setFromMatrixPosition(S.target.matrixWorld),
          E.direction.sub(s),
          E.direction.transformDirection(d),
          g++;
      } else if (S.isRectAreaLight) {
        const E = i.rectArea[m];
        E.position.setFromMatrixPosition(S.matrixWorld),
          E.position.applyMatrix4(d),
          o.identity(),
          a.copy(S.matrixWorld),
          a.premultiply(d),
          o.extractRotation(a),
          E.halfWidth.set(S.width * 0.5, 0, 0),
          E.halfHeight.set(0, S.height * 0.5, 0),
          E.halfWidth.applyMatrix4(o),
          E.halfHeight.applyMatrix4(o),
          m++;
      } else if (S.isPointLight) {
        const E = i.point[p];
        E.position.setFromMatrixPosition(S.matrixWorld),
          E.position.applyMatrix4(d),
          p++;
      } else if (S.isHemisphereLight) {
        const E = i.hemi[_];
        E.direction.setFromMatrixPosition(S.matrixWorld),
          E.direction.transformDirection(d),
          _++;
      }
    }
  }
  return { setup: l, setupView: c, state: i };
}
function Kp(r, e) {
  const t = new Cb(r, e),
    n = [],
    i = [];
  function s() {
    (n.length = 0), (i.length = 0);
  }
  function a(h) {
    n.push(h);
  }
  function o(h) {
    i.push(h);
  }
  function l(h) {
    t.setup(n, h);
  }
  function c(h) {
    t.setupView(n, h);
  }
  return {
    init: s,
    state: { lightsArray: n, shadowsArray: i, lights: t },
    setupLights: l,
    setupLightsView: c,
    pushLight: a,
    pushShadow: o,
  };
}
function Pb(r, e) {
  let t = new WeakMap();
  function n(s, a = 0) {
    const o = t.get(s);
    let l;
    return (
      o === void 0
        ? ((l = new Kp(r, e)), t.set(s, [l]))
        : a >= o.length
        ? ((l = new Kp(r, e)), o.push(l))
        : (l = o[a]),
      l
    );
  }
  function i() {
    t = new WeakMap();
  }
  return { get: n, dispose: i };
}
class Lb extends Pi {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = Rx),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class Db extends Pi {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
const Ib = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
  Nb = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function Ob(r, e, t) {
  let n = new Cf();
  const i = new We(),
    s = new We(),
    a = new mt(),
    o = new Lb({ depthPacking: Cx }),
    l = new Db(),
    c = {},
    u = t.maxTextureSize,
    h = { [or]: bn, [bn]: or, [wi]: wi },
    f = new Ir({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new We() },
        radius: { value: 4 },
      },
      vertexShader: Ib,
      fragmentShader: Nb,
    }),
    p = f.clone();
  p.defines.HORIZONTAL_PASS = 1;
  const g = new xi();
  g.setAttribute(
    "position",
    new xn(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const m = new Vn(g, f),
    _ = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = I_);
  let d = this.type;
  this.render = function (E, b, M) {
    if (
      _.enabled === !1 ||
      (_.autoUpdate === !1 && _.needsUpdate === !1) ||
      E.length === 0
    )
      return;
    const C = r.getRenderTarget(),
      x = r.getActiveCubeFace(),
      T = r.getActiveMipmapLevel(),
      D = r.state;
    D.setBlending(Cr),
      D.buffers.color.setClear(1, 1, 1, 1),
      D.buffers.depth.setTest(!0),
      D.setScissorTest(!1);
    const N = d !== ji && this.type === ji,
      L = d === ji && this.type !== ji;
    for (let F = 0, I = E.length; F < I; F++) {
      const j = E[F],
        A = j.shadow;
      if (A === void 0) {
        console.warn("THREE.WebGLShadowMap:", j, "has no shadow.");
        continue;
      }
      if (A.autoUpdate === !1 && A.needsUpdate === !1) continue;
      i.copy(A.mapSize);
      const k = A.getFrameExtents();
      if (
        (i.multiply(k),
        s.copy(A.mapSize),
        (i.x > u || i.y > u) &&
          (i.x > u &&
            ((s.x = Math.floor(u / k.x)),
            (i.x = s.x * k.x),
            (A.mapSize.x = s.x)),
          i.y > u &&
            ((s.y = Math.floor(u / k.y)),
            (i.y = s.y * k.y),
            (A.mapSize.y = s.y))),
        A.map === null || N === !0 || L === !0)
      ) {
        const z = this.type !== ji ? { minFilter: qt, magFilter: qt } : {};
        A.map !== null && A.map.dispose(),
          (A.map = new bs(i.x, i.y, z)),
          (A.map.texture.name = j.name + ".shadowMap"),
          A.camera.updateProjectionMatrix();
      }
      r.setRenderTarget(A.map), r.clear();
      const G = A.getViewportCount();
      for (let z = 0; z < G; z++) {
        const oe = A.getViewport(z);
        a.set(s.x * oe.x, s.y * oe.y, s.x * oe.z, s.y * oe.w),
          D.viewport(a),
          A.updateMatrices(j, z),
          (n = A.getFrustum()),
          S(b, M, A.camera, j, this.type);
      }
      A.isPointLightShadow !== !0 && this.type === ji && y(A, M),
        (A.needsUpdate = !1);
    }
    (d = this.type), (_.needsUpdate = !1), r.setRenderTarget(C, x, T);
  };
  function y(E, b) {
    const M = e.update(m);
    f.defines.VSM_SAMPLES !== E.blurSamples &&
      ((f.defines.VSM_SAMPLES = E.blurSamples),
      (p.defines.VSM_SAMPLES = E.blurSamples),
      (f.needsUpdate = !0),
      (p.needsUpdate = !0)),
      E.mapPass === null && (E.mapPass = new bs(i.x, i.y)),
      (f.uniforms.shadow_pass.value = E.map.texture),
      (f.uniforms.resolution.value = E.mapSize),
      (f.uniforms.radius.value = E.radius),
      r.setRenderTarget(E.mapPass),
      r.clear(),
      r.renderBufferDirect(b, null, M, f, m, null),
      (p.uniforms.shadow_pass.value = E.mapPass.texture),
      (p.uniforms.resolution.value = E.mapSize),
      (p.uniforms.radius.value = E.radius),
      r.setRenderTarget(E.map),
      r.clear(),
      r.renderBufferDirect(b, null, M, p, m, null);
  }
  function v(E, b, M, C) {
    let x = null;
    const T =
      M.isPointLight === !0 ? E.customDistanceMaterial : E.customDepthMaterial;
    if (T !== void 0) x = T;
    else if (
      ((x = M.isPointLight === !0 ? l : o),
      (r.localClippingEnabled &&
        b.clipShadows === !0 &&
        Array.isArray(b.clippingPlanes) &&
        b.clippingPlanes.length !== 0) ||
        (b.displacementMap && b.displacementScale !== 0) ||
        (b.alphaMap && b.alphaTest > 0) ||
        (b.map && b.alphaTest > 0))
    ) {
      const D = x.uuid,
        N = b.uuid;
      let L = c[D];
      L === void 0 && ((L = {}), (c[D] = L));
      let F = L[N];
      F === void 0 && ((F = x.clone()), (L[N] = F)), (x = F);
    }
    if (
      ((x.visible = b.visible),
      (x.wireframe = b.wireframe),
      C === ji
        ? (x.side = b.shadowSide !== null ? b.shadowSide : b.side)
        : (x.side = b.shadowSide !== null ? b.shadowSide : h[b.side]),
      (x.alphaMap = b.alphaMap),
      (x.alphaTest = b.alphaTest),
      (x.map = b.map),
      (x.clipShadows = b.clipShadows),
      (x.clippingPlanes = b.clippingPlanes),
      (x.clipIntersection = b.clipIntersection),
      (x.displacementMap = b.displacementMap),
      (x.displacementScale = b.displacementScale),
      (x.displacementBias = b.displacementBias),
      (x.wireframeLinewidth = b.wireframeLinewidth),
      (x.linewidth = b.linewidth),
      M.isPointLight === !0 && x.isMeshDistanceMaterial === !0)
    ) {
      const D = r.properties.get(x);
      D.light = M;
    }
    return x;
  }
  function S(E, b, M, C, x) {
    if (E.visible === !1) return;
    if (
      E.layers.test(b.layers) &&
      (E.isMesh || E.isLine || E.isPoints) &&
      (E.castShadow || (E.receiveShadow && x === ji)) &&
      (!E.frustumCulled || n.intersectsObject(E))
    ) {
      E.modelViewMatrix.multiplyMatrices(M.matrixWorldInverse, E.matrixWorld);
      const N = e.update(E),
        L = E.material;
      if (Array.isArray(L)) {
        const F = N.groups;
        for (let I = 0, j = F.length; I < j; I++) {
          const A = F[I],
            k = L[A.materialIndex];
          if (k && k.visible) {
            const G = v(E, k, C, x);
            r.renderBufferDirect(M, null, N, G, E, A);
          }
        }
      } else if (L.visible) {
        const F = v(E, L, C, x);
        r.renderBufferDirect(M, null, N, F, E, null);
      }
    }
    const D = E.children;
    for (let N = 0, L = D.length; N < L; N++) S(D[N], b, M, C, x);
  }
}
function Ub(r, e, t) {
  const n = t.isWebGL2;
  function i() {
    let B = !1;
    const Q = new mt();
    let fe = null;
    const Se = new mt(0, 0, 0, 0);
    return {
      setMask: function (we) {
        fe !== we && !B && (r.colorMask(we, we, we, we), (fe = we));
      },
      setLocked: function (we) {
        B = we;
      },
      setClear: function (we, de, se, pe, Re) {
        Re === !0 && ((we *= pe), (de *= pe), (se *= pe)),
          Q.set(we, de, se, pe),
          Se.equals(Q) === !1 && (r.clearColor(we, de, se, pe), Se.copy(Q));
      },
      reset: function () {
        (B = !1), (fe = null), Se.set(-1, 0, 0, 0);
      },
    };
  }
  function s() {
    let B = !1,
      Q = null,
      fe = null,
      Se = null;
    return {
      setTest: function (we) {
        we ? O(r.DEPTH_TEST) : Me(r.DEPTH_TEST);
      },
      setMask: function (we) {
        Q !== we && !B && (r.depthMask(we), (Q = we));
      },
      setFunc: function (we) {
        if (fe !== we) {
          switch (we) {
            case Zv:
              r.depthFunc(r.NEVER);
              break;
            case Jv:
              r.depthFunc(r.ALWAYS);
              break;
            case Qv:
              r.depthFunc(r.LESS);
              break;
            case Rh:
              r.depthFunc(r.LEQUAL);
              break;
            case ex:
              r.depthFunc(r.EQUAL);
              break;
            case tx:
              r.depthFunc(r.GEQUAL);
              break;
            case nx:
              r.depthFunc(r.GREATER);
              break;
            case ix:
              r.depthFunc(r.NOTEQUAL);
              break;
            default:
              r.depthFunc(r.LEQUAL);
          }
          fe = we;
        }
      },
      setLocked: function (we) {
        B = we;
      },
      setClear: function (we) {
        Se !== we && (r.clearDepth(we), (Se = we));
      },
      reset: function () {
        (B = !1), (Q = null), (fe = null), (Se = null);
      },
    };
  }
  function a() {
    let B = !1,
      Q = null,
      fe = null,
      Se = null,
      we = null,
      de = null,
      se = null,
      pe = null,
      Re = null;
    return {
      setTest: function (Oe) {
        B || (Oe ? O(r.STENCIL_TEST) : Me(r.STENCIL_TEST));
      },
      setMask: function (Oe) {
        Q !== Oe && !B && (r.stencilMask(Oe), (Q = Oe));
      },
      setFunc: function (Oe, Ne, tt) {
        (fe !== Oe || Se !== Ne || we !== tt) &&
          (r.stencilFunc(Oe, Ne, tt), (fe = Oe), (Se = Ne), (we = tt));
      },
      setOp: function (Oe, Ne, tt) {
        (de !== Oe || se !== Ne || pe !== tt) &&
          (r.stencilOp(Oe, Ne, tt), (de = Oe), (se = Ne), (pe = tt));
      },
      setLocked: function (Oe) {
        B = Oe;
      },
      setClear: function (Oe) {
        Re !== Oe && (r.clearStencil(Oe), (Re = Oe));
      },
      reset: function () {
        (B = !1),
          (Q = null),
          (fe = null),
          (Se = null),
          (we = null),
          (de = null),
          (se = null),
          (pe = null),
          (Re = null);
      },
    };
  }
  const o = new i(),
    l = new s(),
    c = new a(),
    u = new WeakMap(),
    h = new WeakMap();
  let f = {},
    p = {},
    g = new WeakMap(),
    m = [],
    _ = null,
    d = !1,
    y = null,
    v = null,
    S = null,
    E = null,
    b = null,
    M = null,
    C = null,
    x = !1,
    T = null,
    D = null,
    N = null,
    L = null,
    F = null;
  const I = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let j = !1,
    A = 0;
  const k = r.getParameter(r.VERSION);
  k.indexOf("WebGL") !== -1
    ? ((A = parseFloat(/^WebGL (\d)/.exec(k)[1])), (j = A >= 1))
    : k.indexOf("OpenGL ES") !== -1 &&
      ((A = parseFloat(/^OpenGL ES (\d)/.exec(k)[1])), (j = A >= 2));
  let G = null,
    z = {};
  const oe = r.getParameter(r.SCISSOR_BOX),
    te = r.getParameter(r.VIEWPORT),
    X = new mt().fromArray(oe),
    Y = new mt().fromArray(te);
  function le(B, Q, fe, Se) {
    const we = new Uint8Array(4),
      de = r.createTexture();
    r.bindTexture(B, de),
      r.texParameteri(B, r.TEXTURE_MIN_FILTER, r.NEAREST),
      r.texParameteri(B, r.TEXTURE_MAG_FILTER, r.NEAREST);
    for (let se = 0; se < fe; se++)
      n && (B === r.TEXTURE_3D || B === r.TEXTURE_2D_ARRAY)
        ? r.texImage3D(Q, 0, r.RGBA, 1, 1, Se, 0, r.RGBA, r.UNSIGNED_BYTE, we)
        : r.texImage2D(Q + se, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, we);
    return de;
  }
  const W = {};
  (W[r.TEXTURE_2D] = le(r.TEXTURE_2D, r.TEXTURE_2D, 1)),
    (W[r.TEXTURE_CUBE_MAP] = le(
      r.TEXTURE_CUBE_MAP,
      r.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    n &&
      ((W[r.TEXTURE_2D_ARRAY] = le(
        r.TEXTURE_2D_ARRAY,
        r.TEXTURE_2D_ARRAY,
        1,
        1
      )),
      (W[r.TEXTURE_3D] = le(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1))),
    o.setClear(0, 0, 0, 1),
    l.setClear(1),
    c.setClear(0),
    O(r.DEPTH_TEST),
    l.setFunc(Rh),
    $e(!1),
    ct(Id),
    O(r.CULL_FACE),
    _e(Cr);
  function O(B) {
    f[B] !== !0 && (r.enable(B), (f[B] = !0));
  }
  function Me(B) {
    f[B] !== !1 && (r.disable(B), (f[B] = !1));
  }
  function ve(B, Q) {
    return p[B] !== Q
      ? (r.bindFramebuffer(B, Q),
        (p[B] = Q),
        n &&
          (B === r.DRAW_FRAMEBUFFER && (p[r.FRAMEBUFFER] = Q),
          B === r.FRAMEBUFFER && (p[r.DRAW_FRAMEBUFFER] = Q)),
        !0)
      : !1;
  }
  function re(B, Q) {
    let fe = m,
      Se = !1;
    if (B)
      if (
        ((fe = g.get(Q)),
        fe === void 0 && ((fe = []), g.set(Q, fe)),
        B.isWebGLMultipleRenderTargets)
      ) {
        const we = B.texture;
        if (fe.length !== we.length || fe[0] !== r.COLOR_ATTACHMENT0) {
          for (let de = 0, se = we.length; de < se; de++)
            fe[de] = r.COLOR_ATTACHMENT0 + de;
          (fe.length = we.length), (Se = !0);
        }
      } else
        fe[0] !== r.COLOR_ATTACHMENT0 &&
          ((fe[0] = r.COLOR_ATTACHMENT0), (Se = !0));
    else fe[0] !== r.BACK && ((fe[0] = r.BACK), (Se = !0));
    Se &&
      (t.isWebGL2
        ? r.drawBuffers(fe)
        : e.get("WEBGL_draw_buffers").drawBuffersWEBGL(fe));
  }
  function be(B) {
    return _ !== B ? (r.useProgram(B), (_ = B), !0) : !1;
  }
  const Fe = {
    [la]: r.FUNC_ADD,
    [zv]: r.FUNC_SUBTRACT,
    [Hv]: r.FUNC_REVERSE_SUBTRACT,
  };
  if (n) (Fe[Fd] = r.MIN), (Fe[Bd] = r.MAX);
  else {
    const B = e.get("EXT_blend_minmax");
    B !== null && ((Fe[Fd] = B.MIN_EXT), (Fe[Bd] = B.MAX_EXT));
  }
  const ae = {
    [Vv]: r.ZERO,
    [Gv]: r.ONE,
    [Wv]: r.SRC_COLOR,
    [N_]: r.SRC_ALPHA,
    [$v]: r.SRC_ALPHA_SATURATE,
    [jv]: r.DST_COLOR,
    [Yv]: r.DST_ALPHA,
    [Xv]: r.ONE_MINUS_SRC_COLOR,
    [O_]: r.ONE_MINUS_SRC_ALPHA,
    [Kv]: r.ONE_MINUS_DST_COLOR,
    [qv]: r.ONE_MINUS_DST_ALPHA,
  };
  function _e(B, Q, fe, Se, we, de, se, pe) {
    if (B === Cr) {
      d === !0 && (Me(r.BLEND), (d = !1));
      return;
    }
    if ((d === !1 && (O(r.BLEND), (d = !0)), B !== kv)) {
      if (B !== y || pe !== x) {
        if (
          ((v !== la || b !== la) &&
            (r.blendEquation(r.FUNC_ADD), (v = la), (b = la)),
          pe)
        )
          switch (B) {
            case Sa:
              r.blendFuncSeparate(
                r.ONE,
                r.ONE_MINUS_SRC_ALPHA,
                r.ONE,
                r.ONE_MINUS_SRC_ALPHA
              );
              break;
            case Nd:
              r.blendFunc(r.ONE, r.ONE);
              break;
            case Od:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case Ud:
              r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", B);
              break;
          }
        else
          switch (B) {
            case Sa:
              r.blendFuncSeparate(
                r.SRC_ALPHA,
                r.ONE_MINUS_SRC_ALPHA,
                r.ONE,
                r.ONE_MINUS_SRC_ALPHA
              );
              break;
            case Nd:
              r.blendFunc(r.SRC_ALPHA, r.ONE);
              break;
            case Od:
              r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
              break;
            case Ud:
              r.blendFunc(r.ZERO, r.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", B);
              break;
          }
        (S = null), (E = null), (M = null), (C = null), (y = B), (x = pe);
      }
      return;
    }
    (we = we || Q),
      (de = de || fe),
      (se = se || Se),
      (Q !== v || we !== b) &&
        (r.blendEquationSeparate(Fe[Q], Fe[we]), (v = Q), (b = we)),
      (fe !== S || Se !== E || de !== M || se !== C) &&
        (r.blendFuncSeparate(ae[fe], ae[Se], ae[de], ae[se]),
        (S = fe),
        (E = Se),
        (M = de),
        (C = se)),
      (y = B),
      (x = !1);
  }
  function K(B, Q) {
    B.side === wi ? Me(r.CULL_FACE) : O(r.CULL_FACE);
    let fe = B.side === bn;
    Q && (fe = !fe),
      $e(fe),
      B.blending === Sa && B.transparent === !1
        ? _e(Cr)
        : _e(
            B.blending,
            B.blendEquation,
            B.blendSrc,
            B.blendDst,
            B.blendEquationAlpha,
            B.blendSrcAlpha,
            B.blendDstAlpha,
            B.premultipliedAlpha
          ),
      l.setFunc(B.depthFunc),
      l.setTest(B.depthTest),
      l.setMask(B.depthWrite),
      o.setMask(B.colorWrite);
    const Se = B.stencilWrite;
    c.setTest(Se),
      Se &&
        (c.setMask(B.stencilWriteMask),
        c.setFunc(B.stencilFunc, B.stencilRef, B.stencilFuncMask),
        c.setOp(B.stencilFail, B.stencilZFail, B.stencilZPass)),
      Xe(B.polygonOffset, B.polygonOffsetFactor, B.polygonOffsetUnits),
      B.alphaToCoverage === !0
        ? O(r.SAMPLE_ALPHA_TO_COVERAGE)
        : Me(r.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function $e(B) {
    T !== B && (B ? r.frontFace(r.CW) : r.frontFace(r.CCW), (T = B));
  }
  function ct(B) {
    B !== Uv
      ? (O(r.CULL_FACE),
        B !== D &&
          (B === Id
            ? r.cullFace(r.BACK)
            : B === Fv
            ? r.cullFace(r.FRONT)
            : r.cullFace(r.FRONT_AND_BACK)))
      : Me(r.CULL_FACE),
      (D = B);
  }
  function Ge(B) {
    B !== N && (j && r.lineWidth(B), (N = B));
  }
  function Xe(B, Q, fe) {
    B
      ? (O(r.POLYGON_OFFSET_FILL),
        (L !== Q || F !== fe) && (r.polygonOffset(Q, fe), (L = Q), (F = fe)))
      : Me(r.POLYGON_OFFSET_FILL);
  }
  function st(B) {
    B ? O(r.SCISSOR_TEST) : Me(r.SCISSOR_TEST);
  }
  function Et(B) {
    B === void 0 && (B = r.TEXTURE0 + I - 1),
      G !== B && (r.activeTexture(B), (G = B));
  }
  function P(B, Q, fe) {
    fe === void 0 && (G === null ? (fe = r.TEXTURE0 + I - 1) : (fe = G));
    let Se = z[fe];
    Se === void 0 && ((Se = { type: void 0, texture: void 0 }), (z[fe] = Se)),
      (Se.type !== B || Se.texture !== Q) &&
        (G !== fe && (r.activeTexture(fe), (G = fe)),
        r.bindTexture(B, Q || W[B]),
        (Se.type = B),
        (Se.texture = Q));
  }
  function w() {
    const B = z[G];
    B !== void 0 &&
      B.type !== void 0 &&
      (r.bindTexture(B.type, null), (B.type = void 0), (B.texture = void 0));
  }
  function $() {
    try {
      r.compressedTexImage2D.apply(r, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function ue() {
    try {
      r.compressedTexImage3D.apply(r, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function he() {
    try {
      r.texSubImage2D.apply(r, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function me() {
    try {
      r.texSubImage3D.apply(r, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function U() {
    try {
      r.compressedTexSubImage2D.apply(r, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function ne() {
    try {
      r.compressedTexSubImage3D.apply(r, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function J() {
    try {
      r.texStorage2D.apply(r, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function ge() {
    try {
      r.texStorage3D.apply(r, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function Te() {
    try {
      r.texImage2D.apply(r, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function Le() {
    try {
      r.texImage3D.apply(r, arguments);
    } catch (B) {
      console.error("THREE.WebGLState:", B);
    }
  }
  function ye(B) {
    X.equals(B) === !1 && (r.scissor(B.x, B.y, B.z, B.w), X.copy(B));
  }
  function Ae(B) {
    Y.equals(B) === !1 && (r.viewport(B.x, B.y, B.z, B.w), Y.copy(B));
  }
  function xe(B, Q) {
    let fe = h.get(Q);
    fe === void 0 && ((fe = new WeakMap()), h.set(Q, fe));
    let Se = fe.get(B);
    Se === void 0 && ((Se = r.getUniformBlockIndex(Q, B.name)), fe.set(B, Se));
  }
  function ze(B, Q) {
    const Se = h.get(Q).get(B);
    u.get(Q) !== Se &&
      (r.uniformBlockBinding(Q, Se, B.__bindingPointIndex), u.set(Q, Se));
  }
  function ot() {
    r.disable(r.BLEND),
      r.disable(r.CULL_FACE),
      r.disable(r.DEPTH_TEST),
      r.disable(r.POLYGON_OFFSET_FILL),
      r.disable(r.SCISSOR_TEST),
      r.disable(r.STENCIL_TEST),
      r.disable(r.SAMPLE_ALPHA_TO_COVERAGE),
      r.blendEquation(r.FUNC_ADD),
      r.blendFunc(r.ONE, r.ZERO),
      r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO),
      r.colorMask(!0, !0, !0, !0),
      r.clearColor(0, 0, 0, 0),
      r.depthMask(!0),
      r.depthFunc(r.LESS),
      r.clearDepth(1),
      r.stencilMask(4294967295),
      r.stencilFunc(r.ALWAYS, 0, 4294967295),
      r.stencilOp(r.KEEP, r.KEEP, r.KEEP),
      r.clearStencil(0),
      r.cullFace(r.BACK),
      r.frontFace(r.CCW),
      r.polygonOffset(0, 0),
      r.activeTexture(r.TEXTURE0),
      r.bindFramebuffer(r.FRAMEBUFFER, null),
      n === !0 &&
        (r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null),
        r.bindFramebuffer(r.READ_FRAMEBUFFER, null)),
      r.useProgram(null),
      r.lineWidth(1),
      r.scissor(0, 0, r.canvas.width, r.canvas.height),
      r.viewport(0, 0, r.canvas.width, r.canvas.height),
      (f = {}),
      (G = null),
      (z = {}),
      (p = {}),
      (g = new WeakMap()),
      (m = []),
      (_ = null),
      (d = !1),
      (y = null),
      (v = null),
      (S = null),
      (E = null),
      (b = null),
      (M = null),
      (C = null),
      (x = !1),
      (T = null),
      (D = null),
      (N = null),
      (L = null),
      (F = null),
      X.set(0, 0, r.canvas.width, r.canvas.height),
      Y.set(0, 0, r.canvas.width, r.canvas.height),
      o.reset(),
      l.reset(),
      c.reset();
  }
  return {
    buffers: { color: o, depth: l, stencil: c },
    enable: O,
    disable: Me,
    bindFramebuffer: ve,
    drawBuffers: re,
    useProgram: be,
    setBlending: _e,
    setMaterial: K,
    setFlipSided: $e,
    setCullFace: ct,
    setLineWidth: Ge,
    setPolygonOffset: Xe,
    setScissorTest: st,
    activeTexture: Et,
    bindTexture: P,
    unbindTexture: w,
    compressedTexImage2D: $,
    compressedTexImage3D: ue,
    texImage2D: Te,
    texImage3D: Le,
    updateUBOMapping: xe,
    uniformBlockBinding: ze,
    texStorage2D: J,
    texStorage3D: ge,
    texSubImage2D: he,
    texSubImage3D: me,
    compressedTexSubImage2D: U,
    compressedTexSubImage3D: ne,
    scissor: ye,
    viewport: Ae,
    reset: ot,
  };
}
function Fb(r, e, t, n, i, s, a) {
  const o = i.isWebGL2,
    l = i.maxTextures,
    c = i.maxCubemapSize,
    u = i.maxTextureSize,
    h = i.maxSamples,
    f = e.has("WEBGL_multisampled_render_to_texture")
      ? e.get("WEBGL_multisampled_render_to_texture")
      : null,
    p =
      typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
    g = new WeakMap();
  let m;
  const _ = new WeakMap();
  let d = !1;
  try {
    d =
      typeof OffscreenCanvas < "u" &&
      new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch {}
  function y(P, w) {
    return d ? new OffscreenCanvas(P, w) : Wo("canvas");
  }
  function v(P, w, $, ue) {
    let he = 1;
    if (
      ((P.width > ue || P.height > ue) &&
        (he = ue / Math.max(P.width, P.height)),
      he < 1 || w === !0)
    )
      if (
        (typeof HTMLImageElement < "u" && P instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement < "u" && P instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap < "u" && P instanceof ImageBitmap)
      ) {
        const me = w ? X_ : Math.floor,
          U = me(he * P.width),
          ne = me(he * P.height);
        m === void 0 && (m = y(U, ne));
        const J = $ ? y(U, ne) : m;
        return (
          (J.width = U),
          (J.height = ne),
          J.getContext("2d").drawImage(P, 0, 0, U, ne),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              P.width +
              "x" +
              P.height +
              ") to (" +
              U +
              "x" +
              ne +
              ")."
          ),
          J
        );
      } else
        return (
          "data" in P &&
            console.warn(
              "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                P.width +
                "x" +
                P.height +
                ")."
            ),
          P
        );
    return P;
  }
  function S(P) {
    return Oh(P.width) && Oh(P.height);
  }
  function E(P) {
    return o
      ? !1
      : P.wrapS !== Jn ||
          P.wrapT !== Jn ||
          (P.minFilter !== qt && P.minFilter !== Sn);
  }
  function b(P, w) {
    return P.generateMipmaps && w && P.minFilter !== qt && P.minFilter !== Sn;
  }
  function M(P) {
    r.generateMipmap(P);
  }
  function C(P, w, $, ue, he = !1) {
    if (o === !1) return w;
    if (P !== null) {
      if (r[P] !== void 0) return r[P];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          P +
          "'"
      );
    }
    let me = w;
    return (
      w === r.RED &&
        ($ === r.FLOAT && (me = r.R32F),
        $ === r.HALF_FLOAT && (me = r.R16F),
        $ === r.UNSIGNED_BYTE && (me = r.R8)),
      w === r.RG &&
        ($ === r.FLOAT && (me = r.RG32F),
        $ === r.HALF_FLOAT && (me = r.RG16F),
        $ === r.UNSIGNED_BYTE && (me = r.RG8)),
      w === r.RGBA &&
        ($ === r.FLOAT && (me = r.RGBA32F),
        $ === r.HALF_FLOAT && (me = r.RGBA16F),
        $ === r.UNSIGNED_BYTE &&
          (me = ue === Ve && he === !1 ? r.SRGB8_ALPHA8 : r.RGBA8),
        $ === r.UNSIGNED_SHORT_4_4_4_4 && (me = r.RGBA4),
        $ === r.UNSIGNED_SHORT_5_5_5_1 && (me = r.RGB5_A1)),
      (me === r.R16F ||
        me === r.R32F ||
        me === r.RG16F ||
        me === r.RG32F ||
        me === r.RGBA16F ||
        me === r.RGBA32F) &&
        e.get("EXT_color_buffer_float"),
      me
    );
  }
  function x(P, w, $) {
    return b(P, $) === !0 ||
      (P.isFramebufferTexture && P.minFilter !== qt && P.minFilter !== Sn)
      ? Math.log2(Math.max(w.width, w.height)) + 1
      : P.mipmaps !== void 0 && P.mipmaps.length > 0
      ? P.mipmaps.length
      : P.isCompressedTexture && Array.isArray(P.image)
      ? w.mipmaps.length
      : 1;
  }
  function T(P) {
    return P === qt || P === Lh || P === pc ? r.NEAREST : r.LINEAR;
  }
  function D(P) {
    const w = P.target;
    w.removeEventListener("dispose", D), L(w), w.isVideoTexture && g.delete(w);
  }
  function N(P) {
    const w = P.target;
    w.removeEventListener("dispose", N), I(w);
  }
  function L(P) {
    const w = n.get(P);
    if (w.__webglInit === void 0) return;
    const $ = P.source,
      ue = _.get($);
    if (ue) {
      const he = ue[w.__cacheKey];
      he.usedTimes--,
        he.usedTimes === 0 && F(P),
        Object.keys(ue).length === 0 && _.delete($);
    }
    n.remove(P);
  }
  function F(P) {
    const w = n.get(P);
    r.deleteTexture(w.__webglTexture);
    const $ = P.source,
      ue = _.get($);
    delete ue[w.__cacheKey], a.memory.textures--;
  }
  function I(P) {
    const w = P.texture,
      $ = n.get(P),
      ue = n.get(w);
    if (
      (ue.__webglTexture !== void 0 &&
        (r.deleteTexture(ue.__webglTexture), a.memory.textures--),
      P.depthTexture && P.depthTexture.dispose(),
      P.isWebGLCubeRenderTarget)
    )
      for (let he = 0; he < 6; he++)
        r.deleteFramebuffer($.__webglFramebuffer[he]),
          $.__webglDepthbuffer &&
            r.deleteRenderbuffer($.__webglDepthbuffer[he]);
    else {
      if (
        (r.deleteFramebuffer($.__webglFramebuffer),
        $.__webglDepthbuffer && r.deleteRenderbuffer($.__webglDepthbuffer),
        $.__webglMultisampledFramebuffer &&
          r.deleteFramebuffer($.__webglMultisampledFramebuffer),
        $.__webglColorRenderbuffer)
      )
        for (let he = 0; he < $.__webglColorRenderbuffer.length; he++)
          $.__webglColorRenderbuffer[he] &&
            r.deleteRenderbuffer($.__webglColorRenderbuffer[he]);
      $.__webglDepthRenderbuffer &&
        r.deleteRenderbuffer($.__webglDepthRenderbuffer);
    }
    if (P.isWebGLMultipleRenderTargets)
      for (let he = 0, me = w.length; he < me; he++) {
        const U = n.get(w[he]);
        U.__webglTexture &&
          (r.deleteTexture(U.__webglTexture), a.memory.textures--),
          n.remove(w[he]);
      }
    n.remove(w), n.remove(P);
  }
  let j = 0;
  function A() {
    j = 0;
  }
  function k() {
    const P = j;
    return (
      P >= l &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            P +
            " texture units while this GPU supports only " +
            l
        ),
      (j += 1),
      P
    );
  }
  function G(P) {
    const w = [];
    return (
      w.push(P.wrapS),
      w.push(P.wrapT),
      w.push(P.wrapR || 0),
      w.push(P.magFilter),
      w.push(P.minFilter),
      w.push(P.anisotropy),
      w.push(P.internalFormat),
      w.push(P.format),
      w.push(P.type),
      w.push(P.generateMipmaps),
      w.push(P.premultiplyAlpha),
      w.push(P.flipY),
      w.push(P.unpackAlignment),
      w.push(P.colorSpace),
      w.join()
    );
  }
  function z(P, w) {
    const $ = n.get(P);
    if (
      (P.isVideoTexture && st(P),
      P.isRenderTargetTexture === !1 &&
        P.version > 0 &&
        $.__version !== P.version)
    ) {
      const ue = P.image;
      if (ue === null)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else if (ue.complete === !1)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      else {
        Me($, P, w);
        return;
      }
    }
    t.bindTexture(r.TEXTURE_2D, $.__webglTexture, r.TEXTURE0 + w);
  }
  function oe(P, w) {
    const $ = n.get(P);
    if (P.version > 0 && $.__version !== P.version) {
      Me($, P, w);
      return;
    }
    t.bindTexture(r.TEXTURE_2D_ARRAY, $.__webglTexture, r.TEXTURE0 + w);
  }
  function te(P, w) {
    const $ = n.get(P);
    if (P.version > 0 && $.__version !== P.version) {
      Me($, P, w);
      return;
    }
    t.bindTexture(r.TEXTURE_3D, $.__webglTexture, r.TEXTURE0 + w);
  }
  function X(P, w) {
    const $ = n.get(P);
    if (P.version > 0 && $.__version !== P.version) {
      ve($, P, w);
      return;
    }
    t.bindTexture(r.TEXTURE_CUBE_MAP, $.__webglTexture, r.TEXTURE0 + w);
  }
  const Y = { [Oa]: r.REPEAT, [Jn]: r.CLAMP_TO_EDGE, [Lc]: r.MIRRORED_REPEAT },
    le = {
      [qt]: r.NEAREST,
      [Lh]: r.NEAREST_MIPMAP_NEAREST,
      [pc]: r.NEAREST_MIPMAP_LINEAR,
      [Sn]: r.LINEAR,
      [B_]: r.LINEAR_MIPMAP_NEAREST,
      [Ss]: r.LINEAR_MIPMAP_LINEAR,
    };
  function W(P, w, $) {
    if (
      ($
        ? (r.texParameteri(P, r.TEXTURE_WRAP_S, Y[w.wrapS]),
          r.texParameteri(P, r.TEXTURE_WRAP_T, Y[w.wrapT]),
          (P === r.TEXTURE_3D || P === r.TEXTURE_2D_ARRAY) &&
            r.texParameteri(P, r.TEXTURE_WRAP_R, Y[w.wrapR]),
          r.texParameteri(P, r.TEXTURE_MAG_FILTER, le[w.magFilter]),
          r.texParameteri(P, r.TEXTURE_MIN_FILTER, le[w.minFilter]))
        : (r.texParameteri(P, r.TEXTURE_WRAP_S, r.CLAMP_TO_EDGE),
          r.texParameteri(P, r.TEXTURE_WRAP_T, r.CLAMP_TO_EDGE),
          (P === r.TEXTURE_3D || P === r.TEXTURE_2D_ARRAY) &&
            r.texParameteri(P, r.TEXTURE_WRAP_R, r.CLAMP_TO_EDGE),
          (w.wrapS !== Jn || w.wrapT !== Jn) &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          r.texParameteri(P, r.TEXTURE_MAG_FILTER, T(w.magFilter)),
          r.texParameteri(P, r.TEXTURE_MIN_FILTER, T(w.minFilter)),
          w.minFilter !== qt &&
            w.minFilter !== Sn &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      e.has("EXT_texture_filter_anisotropic") === !0)
    ) {
      const ue = e.get("EXT_texture_filter_anisotropic");
      if (
        w.magFilter === qt ||
        (w.minFilter !== pc && w.minFilter !== Ss) ||
        (w.type === Er && e.has("OES_texture_float_linear") === !1) ||
        (o === !1 &&
          w.type === Vo &&
          e.has("OES_texture_half_float_linear") === !1)
      )
        return;
      (w.anisotropy > 1 || n.get(w).__currentAnisotropy) &&
        (r.texParameterf(
          P,
          ue.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(w.anisotropy, i.getMaxAnisotropy())
        ),
        (n.get(w).__currentAnisotropy = w.anisotropy));
    }
  }
  function O(P, w) {
    let $ = !1;
    P.__webglInit === void 0 &&
      ((P.__webglInit = !0), w.addEventListener("dispose", D));
    const ue = w.source;
    let he = _.get(ue);
    he === void 0 && ((he = {}), _.set(ue, he));
    const me = G(w);
    if (me !== P.__cacheKey) {
      he[me] === void 0 &&
        ((he[me] = { texture: r.createTexture(), usedTimes: 0 }),
        a.memory.textures++,
        ($ = !0)),
        he[me].usedTimes++;
      const U = he[P.__cacheKey];
      U !== void 0 && (he[P.__cacheKey].usedTimes--, U.usedTimes === 0 && F(w)),
        (P.__cacheKey = me),
        (P.__webglTexture = he[me].texture);
    }
    return $;
  }
  function Me(P, w, $) {
    let ue = r.TEXTURE_2D;
    (w.isDataArrayTexture || w.isCompressedArrayTexture) &&
      (ue = r.TEXTURE_2D_ARRAY),
      w.isData3DTexture && (ue = r.TEXTURE_3D);
    const he = O(P, w),
      me = w.source;
    t.bindTexture(ue, P.__webglTexture, r.TEXTURE0 + $);
    const U = n.get(me);
    if (me.version !== U.__version || he === !0) {
      t.activeTexture(r.TEXTURE0 + $),
        r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, w.flipY),
        r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, w.premultiplyAlpha),
        r.pixelStorei(r.UNPACK_ALIGNMENT, w.unpackAlignment),
        r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, r.NONE);
      const ne = E(w) && S(w.image) === !1;
      let J = v(w.image, ne, !1, u);
      J = Et(w, J);
      const ge = S(J) || o,
        Te = s.convert(w.format, w.colorSpace);
      let Le = s.convert(w.type),
        ye = C(w.internalFormat, Te, Le, w.colorSpace);
      W(ue, w, ge);
      let Ae;
      const xe = w.mipmaps,
        ze = o && w.isVideoTexture !== !0,
        ot = U.__version === void 0 || he === !0,
        B = x(w, J, ge);
      if (w.isDepthTexture)
        (ye = r.DEPTH_COMPONENT),
          o
            ? w.type === Er
              ? (ye = r.DEPTH_COMPONENT32F)
              : w.type === os
              ? (ye = r.DEPTH_COMPONENT24)
              : w.type === Ma
              ? (ye = r.DEPTH24_STENCIL8)
              : (ye = r.DEPTH_COMPONENT16)
            : w.type === Er &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          w.format === hs &&
            ye === r.DEPTH_COMPONENT &&
            w.type !== k_ &&
            w.type !== os &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (w.type = os),
            (Le = s.convert(w.type))),
          w.format === Ua &&
            ye === r.DEPTH_COMPONENT &&
            ((ye = r.DEPTH_STENCIL),
            w.type !== Ma &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (w.type = Ma),
              (Le = s.convert(w.type)))),
          ot &&
            (ze
              ? t.texStorage2D(r.TEXTURE_2D, 1, ye, J.width, J.height)
              : t.texImage2D(
                  r.TEXTURE_2D,
                  0,
                  ye,
                  J.width,
                  J.height,
                  0,
                  Te,
                  Le,
                  null
                ));
      else if (w.isDataTexture)
        if (xe.length > 0 && ge) {
          ze &&
            ot &&
            t.texStorage2D(r.TEXTURE_2D, B, ye, xe[0].width, xe[0].height);
          for (let Q = 0, fe = xe.length; Q < fe; Q++)
            (Ae = xe[Q]),
              ze
                ? t.texSubImage2D(
                    r.TEXTURE_2D,
                    Q,
                    0,
                    0,
                    Ae.width,
                    Ae.height,
                    Te,
                    Le,
                    Ae.data
                  )
                : t.texImage2D(
                    r.TEXTURE_2D,
                    Q,
                    ye,
                    Ae.width,
                    Ae.height,
                    0,
                    Te,
                    Le,
                    Ae.data
                  );
          w.generateMipmaps = !1;
        } else
          ze
            ? (ot && t.texStorage2D(r.TEXTURE_2D, B, ye, J.width, J.height),
              t.texSubImage2D(
                r.TEXTURE_2D,
                0,
                0,
                0,
                J.width,
                J.height,
                Te,
                Le,
                J.data
              ))
            : t.texImage2D(
                r.TEXTURE_2D,
                0,
                ye,
                J.width,
                J.height,
                0,
                Te,
                Le,
                J.data
              );
      else if (w.isCompressedTexture)
        if (w.isCompressedArrayTexture) {
          ze &&
            ot &&
            t.texStorage3D(
              r.TEXTURE_2D_ARRAY,
              B,
              ye,
              xe[0].width,
              xe[0].height,
              J.depth
            );
          for (let Q = 0, fe = xe.length; Q < fe; Q++)
            (Ae = xe[Q]),
              w.format !== Qn
                ? Te !== null
                  ? ze
                    ? t.compressedTexSubImage3D(
                        r.TEXTURE_2D_ARRAY,
                        Q,
                        0,
                        0,
                        0,
                        Ae.width,
                        Ae.height,
                        J.depth,
                        Te,
                        Ae.data,
                        0,
                        0
                      )
                    : t.compressedTexImage3D(
                        r.TEXTURE_2D_ARRAY,
                        Q,
                        ye,
                        Ae.width,
                        Ae.height,
                        J.depth,
                        0,
                        Ae.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : ze
                ? t.texSubImage3D(
                    r.TEXTURE_2D_ARRAY,
                    Q,
                    0,
                    0,
                    0,
                    Ae.width,
                    Ae.height,
                    J.depth,
                    Te,
                    Le,
                    Ae.data
                  )
                : t.texImage3D(
                    r.TEXTURE_2D_ARRAY,
                    Q,
                    ye,
                    Ae.width,
                    Ae.height,
                    J.depth,
                    0,
                    Te,
                    Le,
                    Ae.data
                  );
        } else {
          ze &&
            ot &&
            t.texStorage2D(r.TEXTURE_2D, B, ye, xe[0].width, xe[0].height);
          for (let Q = 0, fe = xe.length; Q < fe; Q++)
            (Ae = xe[Q]),
              w.format !== Qn
                ? Te !== null
                  ? ze
                    ? t.compressedTexSubImage2D(
                        r.TEXTURE_2D,
                        Q,
                        0,
                        0,
                        Ae.width,
                        Ae.height,
                        Te,
                        Ae.data
                      )
                    : t.compressedTexImage2D(
                        r.TEXTURE_2D,
                        Q,
                        ye,
                        Ae.width,
                        Ae.height,
                        0,
                        Ae.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : ze
                ? t.texSubImage2D(
                    r.TEXTURE_2D,
                    Q,
                    0,
                    0,
                    Ae.width,
                    Ae.height,
                    Te,
                    Le,
                    Ae.data
                  )
                : t.texImage2D(
                    r.TEXTURE_2D,
                    Q,
                    ye,
                    Ae.width,
                    Ae.height,
                    0,
                    Te,
                    Le,
                    Ae.data
                  );
        }
      else if (w.isDataArrayTexture)
        ze
          ? (ot &&
              t.texStorage3D(
                r.TEXTURE_2D_ARRAY,
                B,
                ye,
                J.width,
                J.height,
                J.depth
              ),
            t.texSubImage3D(
              r.TEXTURE_2D_ARRAY,
              0,
              0,
              0,
              0,
              J.width,
              J.height,
              J.depth,
              Te,
              Le,
              J.data
            ))
          : t.texImage3D(
              r.TEXTURE_2D_ARRAY,
              0,
              ye,
              J.width,
              J.height,
              J.depth,
              0,
              Te,
              Le,
              J.data
            );
      else if (w.isData3DTexture)
        ze
          ? (ot &&
              t.texStorage3D(r.TEXTURE_3D, B, ye, J.width, J.height, J.depth),
            t.texSubImage3D(
              r.TEXTURE_3D,
              0,
              0,
              0,
              0,
              J.width,
              J.height,
              J.depth,
              Te,
              Le,
              J.data
            ))
          : t.texImage3D(
              r.TEXTURE_3D,
              0,
              ye,
              J.width,
              J.height,
              J.depth,
              0,
              Te,
              Le,
              J.data
            );
      else if (w.isFramebufferTexture) {
        if (ot)
          if (ze) t.texStorage2D(r.TEXTURE_2D, B, ye, J.width, J.height);
          else {
            let Q = J.width,
              fe = J.height;
            for (let Se = 0; Se < B; Se++)
              t.texImage2D(r.TEXTURE_2D, Se, ye, Q, fe, 0, Te, Le, null),
                (Q >>= 1),
                (fe >>= 1);
          }
      } else if (xe.length > 0 && ge) {
        ze &&
          ot &&
          t.texStorage2D(r.TEXTURE_2D, B, ye, xe[0].width, xe[0].height);
        for (let Q = 0, fe = xe.length; Q < fe; Q++)
          (Ae = xe[Q]),
            ze
              ? t.texSubImage2D(r.TEXTURE_2D, Q, 0, 0, Te, Le, Ae)
              : t.texImage2D(r.TEXTURE_2D, Q, ye, Te, Le, Ae);
        w.generateMipmaps = !1;
      } else
        ze
          ? (ot && t.texStorage2D(r.TEXTURE_2D, B, ye, J.width, J.height),
            t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Te, Le, J))
          : t.texImage2D(r.TEXTURE_2D, 0, ye, Te, Le, J);
      b(w, ge) && M(ue),
        (U.__version = me.version),
        w.onUpdate && w.onUpdate(w);
    }
    P.__version = w.version;
  }
  function ve(P, w, $) {
    if (w.image.length !== 6) return;
    const ue = O(P, w),
      he = w.source;
    t.bindTexture(r.TEXTURE_CUBE_MAP, P.__webglTexture, r.TEXTURE0 + $);
    const me = n.get(he);
    if (he.version !== me.__version || ue === !0) {
      t.activeTexture(r.TEXTURE0 + $),
        r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, w.flipY),
        r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, w.premultiplyAlpha),
        r.pixelStorei(r.UNPACK_ALIGNMENT, w.unpackAlignment),
        r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, r.NONE);
      const U = w.isCompressedTexture || w.image[0].isCompressedTexture,
        ne = w.image[0] && w.image[0].isDataTexture,
        J = [];
      for (let Q = 0; Q < 6; Q++)
        !U && !ne
          ? (J[Q] = v(w.image[Q], !1, !0, c))
          : (J[Q] = ne ? w.image[Q].image : w.image[Q]),
          (J[Q] = Et(w, J[Q]));
      const ge = J[0],
        Te = S(ge) || o,
        Le = s.convert(w.format, w.colorSpace),
        ye = s.convert(w.type),
        Ae = C(w.internalFormat, Le, ye, w.colorSpace),
        xe = o && w.isVideoTexture !== !0,
        ze = me.__version === void 0 || ue === !0;
      let ot = x(w, ge, Te);
      W(r.TEXTURE_CUBE_MAP, w, Te);
      let B;
      if (U) {
        xe &&
          ze &&
          t.texStorage2D(r.TEXTURE_CUBE_MAP, ot, Ae, ge.width, ge.height);
        for (let Q = 0; Q < 6; Q++) {
          B = J[Q].mipmaps;
          for (let fe = 0; fe < B.length; fe++) {
            const Se = B[fe];
            w.format !== Qn
              ? Le !== null
                ? xe
                  ? t.compressedTexSubImage2D(
                      r.TEXTURE_CUBE_MAP_POSITIVE_X + Q,
                      fe,
                      0,
                      0,
                      Se.width,
                      Se.height,
                      Le,
                      Se.data
                    )
                  : t.compressedTexImage2D(
                      r.TEXTURE_CUBE_MAP_POSITIVE_X + Q,
                      fe,
                      Ae,
                      Se.width,
                      Se.height,
                      0,
                      Se.data
                    )
                : console.warn(
                    "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                  )
              : xe
              ? t.texSubImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + Q,
                  fe,
                  0,
                  0,
                  Se.width,
                  Se.height,
                  Le,
                  ye,
                  Se.data
                )
              : t.texImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + Q,
                  fe,
                  Ae,
                  Se.width,
                  Se.height,
                  0,
                  Le,
                  ye,
                  Se.data
                );
          }
        }
      } else {
        (B = w.mipmaps),
          xe &&
            ze &&
            (B.length > 0 && ot++,
            t.texStorage2D(
              r.TEXTURE_CUBE_MAP,
              ot,
              Ae,
              J[0].width,
              J[0].height
            ));
        for (let Q = 0; Q < 6; Q++)
          if (ne) {
            xe
              ? t.texSubImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + Q,
                  0,
                  0,
                  0,
                  J[Q].width,
                  J[Q].height,
                  Le,
                  ye,
                  J[Q].data
                )
              : t.texImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + Q,
                  0,
                  Ae,
                  J[Q].width,
                  J[Q].height,
                  0,
                  Le,
                  ye,
                  J[Q].data
                );
            for (let fe = 0; fe < B.length; fe++) {
              const we = B[fe].image[Q].image;
              xe
                ? t.texSubImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + Q,
                    fe + 1,
                    0,
                    0,
                    we.width,
                    we.height,
                    Le,
                    ye,
                    we.data
                  )
                : t.texImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + Q,
                    fe + 1,
                    Ae,
                    we.width,
                    we.height,
                    0,
                    Le,
                    ye,
                    we.data
                  );
            }
          } else {
            xe
              ? t.texSubImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + Q,
                  0,
                  0,
                  0,
                  Le,
                  ye,
                  J[Q]
                )
              : t.texImage2D(
                  r.TEXTURE_CUBE_MAP_POSITIVE_X + Q,
                  0,
                  Ae,
                  Le,
                  ye,
                  J[Q]
                );
            for (let fe = 0; fe < B.length; fe++) {
              const Se = B[fe];
              xe
                ? t.texSubImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + Q,
                    fe + 1,
                    0,
                    0,
                    Le,
                    ye,
                    Se.image[Q]
                  )
                : t.texImage2D(
                    r.TEXTURE_CUBE_MAP_POSITIVE_X + Q,
                    fe + 1,
                    Ae,
                    Le,
                    ye,
                    Se.image[Q]
                  );
            }
          }
      }
      b(w, Te) && M(r.TEXTURE_CUBE_MAP),
        (me.__version = he.version),
        w.onUpdate && w.onUpdate(w);
    }
    P.__version = w.version;
  }
  function re(P, w, $, ue, he) {
    const me = s.convert($.format, $.colorSpace),
      U = s.convert($.type),
      ne = C($.internalFormat, me, U, $.colorSpace);
    n.get(w).__hasExternalTextures ||
      (he === r.TEXTURE_3D || he === r.TEXTURE_2D_ARRAY
        ? t.texImage3D(he, 0, ne, w.width, w.height, w.depth, 0, me, U, null)
        : t.texImage2D(he, 0, ne, w.width, w.height, 0, me, U, null)),
      t.bindFramebuffer(r.FRAMEBUFFER, P),
      Xe(w)
        ? f.framebufferTexture2DMultisampleEXT(
            r.FRAMEBUFFER,
            ue,
            he,
            n.get($).__webglTexture,
            0,
            Ge(w)
          )
        : (he === r.TEXTURE_2D ||
            (he >= r.TEXTURE_CUBE_MAP_POSITIVE_X &&
              he <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          r.framebufferTexture2D(
            r.FRAMEBUFFER,
            ue,
            he,
            n.get($).__webglTexture,
            0
          ),
      t.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function be(P, w, $) {
    if (
      (r.bindRenderbuffer(r.RENDERBUFFER, P), w.depthBuffer && !w.stencilBuffer)
    ) {
      let ue = r.DEPTH_COMPONENT16;
      if ($ || Xe(w)) {
        const he = w.depthTexture;
        he &&
          he.isDepthTexture &&
          (he.type === Er
            ? (ue = r.DEPTH_COMPONENT32F)
            : he.type === os && (ue = r.DEPTH_COMPONENT24));
        const me = Ge(w);
        Xe(w)
          ? f.renderbufferStorageMultisampleEXT(
              r.RENDERBUFFER,
              me,
              ue,
              w.width,
              w.height
            )
          : r.renderbufferStorageMultisample(
              r.RENDERBUFFER,
              me,
              ue,
              w.width,
              w.height
            );
      } else r.renderbufferStorage(r.RENDERBUFFER, ue, w.width, w.height);
      r.framebufferRenderbuffer(
        r.FRAMEBUFFER,
        r.DEPTH_ATTACHMENT,
        r.RENDERBUFFER,
        P
      );
    } else if (w.depthBuffer && w.stencilBuffer) {
      const ue = Ge(w);
      $ && Xe(w) === !1
        ? r.renderbufferStorageMultisample(
            r.RENDERBUFFER,
            ue,
            r.DEPTH24_STENCIL8,
            w.width,
            w.height
          )
        : Xe(w)
        ? f.renderbufferStorageMultisampleEXT(
            r.RENDERBUFFER,
            ue,
            r.DEPTH24_STENCIL8,
            w.width,
            w.height
          )
        : r.renderbufferStorage(
            r.RENDERBUFFER,
            r.DEPTH_STENCIL,
            w.width,
            w.height
          ),
        r.framebufferRenderbuffer(
          r.FRAMEBUFFER,
          r.DEPTH_STENCIL_ATTACHMENT,
          r.RENDERBUFFER,
          P
        );
    } else {
      const ue =
        w.isWebGLMultipleRenderTargets === !0 ? w.texture : [w.texture];
      for (let he = 0; he < ue.length; he++) {
        const me = ue[he],
          U = s.convert(me.format, me.colorSpace),
          ne = s.convert(me.type),
          J = C(me.internalFormat, U, ne, me.colorSpace),
          ge = Ge(w);
        $ && Xe(w) === !1
          ? r.renderbufferStorageMultisample(
              r.RENDERBUFFER,
              ge,
              J,
              w.width,
              w.height
            )
          : Xe(w)
          ? f.renderbufferStorageMultisampleEXT(
              r.RENDERBUFFER,
              ge,
              J,
              w.width,
              w.height
            )
          : r.renderbufferStorage(r.RENDERBUFFER, J, w.width, w.height);
      }
    }
    r.bindRenderbuffer(r.RENDERBUFFER, null);
  }
  function Fe(P, w) {
    if (w && w.isWebGLCubeRenderTarget)
      throw new Error(
        "Depth Texture with cube render targets is not supported"
      );
    if (
      (t.bindFramebuffer(r.FRAMEBUFFER, P),
      !(w.depthTexture && w.depthTexture.isDepthTexture))
    )
      throw new Error(
        "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
      );
    (!n.get(w.depthTexture).__webglTexture ||
      w.depthTexture.image.width !== w.width ||
      w.depthTexture.image.height !== w.height) &&
      ((w.depthTexture.image.width = w.width),
      (w.depthTexture.image.height = w.height),
      (w.depthTexture.needsUpdate = !0)),
      z(w.depthTexture, 0);
    const ue = n.get(w.depthTexture).__webglTexture,
      he = Ge(w);
    if (w.depthTexture.format === hs)
      Xe(w)
        ? f.framebufferTexture2DMultisampleEXT(
            r.FRAMEBUFFER,
            r.DEPTH_ATTACHMENT,
            r.TEXTURE_2D,
            ue,
            0,
            he
          )
        : r.framebufferTexture2D(
            r.FRAMEBUFFER,
            r.DEPTH_ATTACHMENT,
            r.TEXTURE_2D,
            ue,
            0
          );
    else if (w.depthTexture.format === Ua)
      Xe(w)
        ? f.framebufferTexture2DMultisampleEXT(
            r.FRAMEBUFFER,
            r.DEPTH_STENCIL_ATTACHMENT,
            r.TEXTURE_2D,
            ue,
            0,
            he
          )
        : r.framebufferTexture2D(
            r.FRAMEBUFFER,
            r.DEPTH_STENCIL_ATTACHMENT,
            r.TEXTURE_2D,
            ue,
            0
          );
    else throw new Error("Unknown depthTexture format");
  }
  function ae(P) {
    const w = n.get(P),
      $ = P.isWebGLCubeRenderTarget === !0;
    if (P.depthTexture && !w.__autoAllocateDepthBuffer) {
      if ($)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      Fe(w.__webglFramebuffer, P);
    } else if ($) {
      w.__webglDepthbuffer = [];
      for (let ue = 0; ue < 6; ue++)
        t.bindFramebuffer(r.FRAMEBUFFER, w.__webglFramebuffer[ue]),
          (w.__webglDepthbuffer[ue] = r.createRenderbuffer()),
          be(w.__webglDepthbuffer[ue], P, !1);
    } else
      t.bindFramebuffer(r.FRAMEBUFFER, w.__webglFramebuffer),
        (w.__webglDepthbuffer = r.createRenderbuffer()),
        be(w.__webglDepthbuffer, P, !1);
    t.bindFramebuffer(r.FRAMEBUFFER, null);
  }
  function _e(P, w, $) {
    const ue = n.get(P);
    w !== void 0 &&
      re(
        ue.__webglFramebuffer,
        P,
        P.texture,
        r.COLOR_ATTACHMENT0,
        r.TEXTURE_2D
      ),
      $ !== void 0 && ae(P);
  }
  function K(P) {
    const w = P.texture,
      $ = n.get(P),
      ue = n.get(w);
    P.addEventListener("dispose", N),
      P.isWebGLMultipleRenderTargets !== !0 &&
        (ue.__webglTexture === void 0 &&
          (ue.__webglTexture = r.createTexture()),
        (ue.__version = w.version),
        a.memory.textures++);
    const he = P.isWebGLCubeRenderTarget === !0,
      me = P.isWebGLMultipleRenderTargets === !0,
      U = S(P) || o;
    if (he) {
      $.__webglFramebuffer = [];
      for (let ne = 0; ne < 6; ne++)
        $.__webglFramebuffer[ne] = r.createFramebuffer();
    } else {
      if ((($.__webglFramebuffer = r.createFramebuffer()), me))
        if (i.drawBuffers) {
          const ne = P.texture;
          for (let J = 0, ge = ne.length; J < ge; J++) {
            const Te = n.get(ne[J]);
            Te.__webglTexture === void 0 &&
              ((Te.__webglTexture = r.createTexture()), a.memory.textures++);
          }
        } else
          console.warn(
            "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
          );
      if (o && P.samples > 0 && Xe(P) === !1) {
        const ne = me ? w : [w];
        ($.__webglMultisampledFramebuffer = r.createFramebuffer()),
          ($.__webglColorRenderbuffer = []),
          t.bindFramebuffer(r.FRAMEBUFFER, $.__webglMultisampledFramebuffer);
        for (let J = 0; J < ne.length; J++) {
          const ge = ne[J];
          ($.__webglColorRenderbuffer[J] = r.createRenderbuffer()),
            r.bindRenderbuffer(r.RENDERBUFFER, $.__webglColorRenderbuffer[J]);
          const Te = s.convert(ge.format, ge.colorSpace),
            Le = s.convert(ge.type),
            ye = C(
              ge.internalFormat,
              Te,
              Le,
              ge.colorSpace,
              P.isXRRenderTarget === !0
            ),
            Ae = Ge(P);
          r.renderbufferStorageMultisample(
            r.RENDERBUFFER,
            Ae,
            ye,
            P.width,
            P.height
          ),
            r.framebufferRenderbuffer(
              r.FRAMEBUFFER,
              r.COLOR_ATTACHMENT0 + J,
              r.RENDERBUFFER,
              $.__webglColorRenderbuffer[J]
            );
        }
        r.bindRenderbuffer(r.RENDERBUFFER, null),
          P.depthBuffer &&
            (($.__webglDepthRenderbuffer = r.createRenderbuffer()),
            be($.__webglDepthRenderbuffer, P, !0)),
          t.bindFramebuffer(r.FRAMEBUFFER, null);
      }
    }
    if (he) {
      t.bindTexture(r.TEXTURE_CUBE_MAP, ue.__webglTexture),
        W(r.TEXTURE_CUBE_MAP, w, U);
      for (let ne = 0; ne < 6; ne++)
        re(
          $.__webglFramebuffer[ne],
          P,
          w,
          r.COLOR_ATTACHMENT0,
          r.TEXTURE_CUBE_MAP_POSITIVE_X + ne
        );
      b(w, U) && M(r.TEXTURE_CUBE_MAP), t.unbindTexture();
    } else if (me) {
      const ne = P.texture;
      for (let J = 0, ge = ne.length; J < ge; J++) {
        const Te = ne[J],
          Le = n.get(Te);
        t.bindTexture(r.TEXTURE_2D, Le.__webglTexture),
          W(r.TEXTURE_2D, Te, U),
          re(
            $.__webglFramebuffer,
            P,
            Te,
            r.COLOR_ATTACHMENT0 + J,
            r.TEXTURE_2D
          ),
          b(Te, U) && M(r.TEXTURE_2D);
      }
      t.unbindTexture();
    } else {
      let ne = r.TEXTURE_2D;
      (P.isWebGL3DRenderTarget || P.isWebGLArrayRenderTarget) &&
        (o
          ? (ne = P.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY)
          : console.error(
              "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
            )),
        t.bindTexture(ne, ue.__webglTexture),
        W(ne, w, U),
        re($.__webglFramebuffer, P, w, r.COLOR_ATTACHMENT0, ne),
        b(w, U) && M(ne),
        t.unbindTexture();
    }
    P.depthBuffer && ae(P);
  }
  function $e(P) {
    const w = S(P) || o,
      $ = P.isWebGLMultipleRenderTargets === !0 ? P.texture : [P.texture];
    for (let ue = 0, he = $.length; ue < he; ue++) {
      const me = $[ue];
      if (b(me, w)) {
        const U = P.isWebGLCubeRenderTarget ? r.TEXTURE_CUBE_MAP : r.TEXTURE_2D,
          ne = n.get(me).__webglTexture;
        t.bindTexture(U, ne), M(U), t.unbindTexture();
      }
    }
  }
  function ct(P) {
    if (o && P.samples > 0 && Xe(P) === !1) {
      const w = P.isWebGLMultipleRenderTargets ? P.texture : [P.texture],
        $ = P.width,
        ue = P.height;
      let he = r.COLOR_BUFFER_BIT;
      const me = [],
        U = P.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
        ne = n.get(P),
        J = P.isWebGLMultipleRenderTargets === !0;
      if (J)
        for (let ge = 0; ge < w.length; ge++)
          t.bindFramebuffer(r.FRAMEBUFFER, ne.__webglMultisampledFramebuffer),
            r.framebufferRenderbuffer(
              r.FRAMEBUFFER,
              r.COLOR_ATTACHMENT0 + ge,
              r.RENDERBUFFER,
              null
            ),
            t.bindFramebuffer(r.FRAMEBUFFER, ne.__webglFramebuffer),
            r.framebufferTexture2D(
              r.DRAW_FRAMEBUFFER,
              r.COLOR_ATTACHMENT0 + ge,
              r.TEXTURE_2D,
              null,
              0
            );
      t.bindFramebuffer(r.READ_FRAMEBUFFER, ne.__webglMultisampledFramebuffer),
        t.bindFramebuffer(r.DRAW_FRAMEBUFFER, ne.__webglFramebuffer);
      for (let ge = 0; ge < w.length; ge++) {
        me.push(r.COLOR_ATTACHMENT0 + ge), P.depthBuffer && me.push(U);
        const Te =
          ne.__ignoreDepthValues !== void 0 ? ne.__ignoreDepthValues : !1;
        if (
          (Te === !1 &&
            (P.depthBuffer && (he |= r.DEPTH_BUFFER_BIT),
            P.stencilBuffer && (he |= r.STENCIL_BUFFER_BIT)),
          J &&
            r.framebufferRenderbuffer(
              r.READ_FRAMEBUFFER,
              r.COLOR_ATTACHMENT0,
              r.RENDERBUFFER,
              ne.__webglColorRenderbuffer[ge]
            ),
          Te === !0 &&
            (r.invalidateFramebuffer(r.READ_FRAMEBUFFER, [U]),
            r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [U])),
          J)
        ) {
          const Le = n.get(w[ge]).__webglTexture;
          r.framebufferTexture2D(
            r.DRAW_FRAMEBUFFER,
            r.COLOR_ATTACHMENT0,
            r.TEXTURE_2D,
            Le,
            0
          );
        }
        r.blitFramebuffer(0, 0, $, ue, 0, 0, $, ue, he, r.NEAREST),
          p && r.invalidateFramebuffer(r.READ_FRAMEBUFFER, me);
      }
      if (
        (t.bindFramebuffer(r.READ_FRAMEBUFFER, null),
        t.bindFramebuffer(r.DRAW_FRAMEBUFFER, null),
        J)
      )
        for (let ge = 0; ge < w.length; ge++) {
          t.bindFramebuffer(r.FRAMEBUFFER, ne.__webglMultisampledFramebuffer),
            r.framebufferRenderbuffer(
              r.FRAMEBUFFER,
              r.COLOR_ATTACHMENT0 + ge,
              r.RENDERBUFFER,
              ne.__webglColorRenderbuffer[ge]
            );
          const Te = n.get(w[ge]).__webglTexture;
          t.bindFramebuffer(r.FRAMEBUFFER, ne.__webglFramebuffer),
            r.framebufferTexture2D(
              r.DRAW_FRAMEBUFFER,
              r.COLOR_ATTACHMENT0 + ge,
              r.TEXTURE_2D,
              Te,
              0
            );
        }
      t.bindFramebuffer(r.DRAW_FRAMEBUFFER, ne.__webglMultisampledFramebuffer);
    }
  }
  function Ge(P) {
    return Math.min(h, P.samples);
  }
  function Xe(P) {
    const w = n.get(P);
    return (
      o &&
      P.samples > 0 &&
      e.has("WEBGL_multisampled_render_to_texture") === !0 &&
      w.__useRenderToTexture !== !1
    );
  }
  function st(P) {
    const w = a.render.frame;
    g.get(P) !== w && (g.set(P, w), P.update());
  }
  function Et(P, w) {
    const $ = P.colorSpace,
      ue = P.format,
      he = P.type;
    return (
      P.isCompressedTexture === !0 ||
        P.format === Nh ||
        ($ !== Ii &&
          $ !== ds &&
          ($ === Ve
            ? o === !1
              ? e.has("EXT_sRGB") === !0 && ue === Qn
                ? ((P.format = Nh),
                  (P.minFilter = Sn),
                  (P.generateMipmaps = !1))
                : (w = q_.sRGBToLinear(w))
              : (ue !== Qn || he !== Ms) &&
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                $
              ))),
      w
    );
  }
  (this.allocateTextureUnit = k),
    (this.resetTextureUnits = A),
    (this.setTexture2D = z),
    (this.setTexture2DArray = oe),
    (this.setTexture3D = te),
    (this.setTextureCube = X),
    (this.rebindTextures = _e),
    (this.setupRenderTarget = K),
    (this.updateRenderTargetMipmap = $e),
    (this.updateMultisampleRenderTarget = ct),
    (this.setupDepthRenderbuffer = ae),
    (this.setupFrameBufferTexture = re),
    (this.useMultisampledRTT = Xe);
}
function Bb(r, e, t) {
  const n = t.isWebGL2;
  function i(s, a = ds) {
    let o;
    if (s === Ms) return r.UNSIGNED_BYTE;
    if (s === px) return r.UNSIGNED_SHORT_4_4_4_4;
    if (s === mx) return r.UNSIGNED_SHORT_5_5_5_1;
    if (s === hx) return r.BYTE;
    if (s === fx) return r.SHORT;
    if (s === k_) return r.UNSIGNED_SHORT;
    if (s === dx) return r.INT;
    if (s === os) return r.UNSIGNED_INT;
    if (s === Er) return r.FLOAT;
    if (s === Vo)
      return n
        ? r.HALF_FLOAT
        : ((o = e.get("OES_texture_half_float")),
          o !== null ? o.HALF_FLOAT_OES : null);
    if (s === _x) return r.ALPHA;
    if (s === Qn) return r.RGBA;
    if (s === gx) return r.LUMINANCE;
    if (s === vx) return r.LUMINANCE_ALPHA;
    if (s === hs) return r.DEPTH_COMPONENT;
    if (s === Ua) return r.DEPTH_STENCIL;
    if (s === Nh)
      return (o = e.get("EXT_sRGB")), o !== null ? o.SRGB_ALPHA_EXT : null;
    if (s === xx) return r.RED;
    if (s === yx) return r.RED_INTEGER;
    if (s === Ex) return r.RG;
    if (s === Sx) return r.RG_INTEGER;
    if (s === Mx) return r.RGBA_INTEGER;
    if (s === Ru || s === Cu || s === Pu || s === Lu)
      if (a === Ve)
        if (((o = e.get("WEBGL_compressed_texture_s3tc_srgb")), o !== null)) {
          if (s === Ru) return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (s === Cu) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (s === Pu) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (s === Lu) return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else return null;
      else if (((o = e.get("WEBGL_compressed_texture_s3tc")), o !== null)) {
        if (s === Ru) return o.COMPRESSED_RGB_S3TC_DXT1_EXT;
        if (s === Cu) return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;
        if (s === Pu) return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;
        if (s === Lu) return o.COMPRESSED_RGBA_S3TC_DXT5_EXT;
      } else return null;
    if (s === kd || s === zd || s === Hd || s === Vd)
      if (((o = e.get("WEBGL_compressed_texture_pvrtc")), o !== null)) {
        if (s === kd) return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (s === zd) return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (s === Hd) return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (s === Vd) return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else return null;
    if (s === bx)
      return (
        (o = e.get("WEBGL_compressed_texture_etc1")),
        o !== null ? o.COMPRESSED_RGB_ETC1_WEBGL : null
      );
    if (s === Gd || s === Wd)
      if (((o = e.get("WEBGL_compressed_texture_etc")), o !== null)) {
        if (s === Gd)
          return a === Ve ? o.COMPRESSED_SRGB8_ETC2 : o.COMPRESSED_RGB8_ETC2;
        if (s === Wd)
          return a === Ve
            ? o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : o.COMPRESSED_RGBA8_ETC2_EAC;
      } else return null;
    if (
      s === Xd ||
      s === Yd ||
      s === qd ||
      s === jd ||
      s === Kd ||
      s === $d ||
      s === Zd ||
      s === Jd ||
      s === Qd ||
      s === ep ||
      s === tp ||
      s === np ||
      s === ip ||
      s === rp
    )
      if (((o = e.get("WEBGL_compressed_texture_astc")), o !== null)) {
        if (s === Xd)
          return a === Ve
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : o.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (s === Yd)
          return a === Ve
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : o.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (s === qd)
          return a === Ve
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : o.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (s === jd)
          return a === Ve
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : o.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (s === Kd)
          return a === Ve
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : o.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (s === $d)
          return a === Ve
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : o.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (s === Zd)
          return a === Ve
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : o.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (s === Jd)
          return a === Ve
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : o.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (s === Qd)
          return a === Ve
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : o.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (s === ep)
          return a === Ve
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : o.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (s === tp)
          return a === Ve
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : o.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (s === np)
          return a === Ve
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : o.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (s === ip)
          return a === Ve
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : o.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (s === rp)
          return a === Ve
            ? o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : o.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else return null;
    if (s === Du)
      if (((o = e.get("EXT_texture_compression_bptc")), o !== null)) {
        if (s === Du)
          return a === Ve
            ? o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : o.COMPRESSED_RGBA_BPTC_UNORM_EXT;
      } else return null;
    if (s === Tx || s === sp || s === ap || s === op)
      if (((o = e.get("EXT_texture_compression_rgtc")), o !== null)) {
        if (s === Du) return o.COMPRESSED_RED_RGTC1_EXT;
        if (s === sp) return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (s === ap) return o.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (s === op) return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else return null;
    return s === Ma
      ? n
        ? r.UNSIGNED_INT_24_8
        : ((o = e.get("WEBGL_depth_texture")),
          o !== null ? o.UNSIGNED_INT_24_8_WEBGL : null)
      : r[s] !== void 0
      ? r[s]
      : null;
  }
  return { convert: i };
}
class kb extends mn {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class ls extends Tt {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const zb = { type: "move" };
class th {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      this._hand === null &&
        ((this._hand = new ls()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      this._targetRay === null &&
        ((this._targetRay = new ls()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new H()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new H())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      this._grip === null &&
        ((this._grip = new ls()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new H()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new H())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      this._targetRay !== null && this._targetRay.dispatchEvent(e),
      this._grip !== null && this._grip.dispatchEvent(e),
      this._hand !== null && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const n of e.hand.values()) this._getHandJoint(t, n);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      this._targetRay !== null && (this._targetRay.visible = !1),
      this._grip !== null && (this._grip.visible = !1),
      this._hand !== null && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, n) {
    let i = null,
      s = null,
      a = null;
    const o = this._targetRay,
      l = this._grip,
      c = this._hand;
    if (e && t.session.visibilityState !== "visible-blurred") {
      if (c && e.hand) {
        a = !0;
        for (const m of e.hand.values()) {
          const _ = t.getJointPose(m, n),
            d = this._getHandJoint(c, m);
          _ !== null &&
            (d.matrix.fromArray(_.transform.matrix),
            d.matrix.decompose(d.position, d.rotation, d.scale),
            (d.matrixWorldNeedsUpdate = !0),
            (d.jointRadius = _.radius)),
            (d.visible = _ !== null);
        }
        const u = c.joints["index-finger-tip"],
          h = c.joints["thumb-tip"],
          f = u.position.distanceTo(h.position),
          p = 0.02,
          g = 0.005;
        c.inputState.pinching && f > p + g
          ? ((c.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !c.inputState.pinching &&
            f <= p - g &&
            ((c.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        l !== null &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, n)),
          s !== null &&
            (l.matrix.fromArray(s.transform.matrix),
            l.matrix.decompose(l.position, l.rotation, l.scale),
            (l.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((l.hasLinearVelocity = !0),
                l.linearVelocity.copy(s.linearVelocity))
              : (l.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((l.hasAngularVelocity = !0),
                l.angularVelocity.copy(s.angularVelocity))
              : (l.hasAngularVelocity = !1)));
      o !== null &&
        ((i = t.getPose(e.targetRaySpace, n)),
        i === null && s !== null && (i = s),
        i !== null &&
          (o.matrix.fromArray(i.transform.matrix),
          o.matrix.decompose(o.position, o.rotation, o.scale),
          (o.matrixWorldNeedsUpdate = !0),
          i.linearVelocity
            ? ((o.hasLinearVelocity = !0),
              o.linearVelocity.copy(i.linearVelocity))
            : (o.hasLinearVelocity = !1),
          i.angularVelocity
            ? ((o.hasAngularVelocity = !0),
              o.angularVelocity.copy(i.angularVelocity))
            : (o.hasAngularVelocity = !1),
          this.dispatchEvent(zb)));
    }
    return (
      o !== null && (o.visible = i !== null),
      l !== null && (l.visible = s !== null),
      c !== null && (c.visible = a !== null),
      this
    );
  }
  _getHandJoint(e, t) {
    if (e.joints[t.jointName] === void 0) {
      const n = new ls();
      (n.matrixAutoUpdate = !1),
        (n.visible = !1),
        (e.joints[t.jointName] = n),
        e.add(n);
    }
    return e.joints[t.jointName];
  }
}
class Hb extends Qt {
  constructor(e, t, n, i, s, a, o, l, c, u) {
    if (((u = u !== void 0 ? u : hs), u !== hs && u !== Ua))
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    n === void 0 && u === hs && (n = os),
      n === void 0 && u === Ua && (n = Ma),
      super(null, i, s, a, o, l, u, n, c),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = o !== void 0 ? o : qt),
      (this.minFilter = l !== void 0 ? l : qt),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class Vb extends Ds {
  constructor(e, t) {
    super();
    const n = this;
    let i = null,
      s = 1,
      a = null,
      o = "local-floor",
      l = 1,
      c = null,
      u = null,
      h = null,
      f = null,
      p = null,
      g = null;
    const m = t.getContextAttributes();
    let _ = null,
      d = null;
    const y = [],
      v = [],
      S = new Set(),
      E = new Map(),
      b = new mn();
    b.layers.enable(1), (b.viewport = new mt());
    const M = new mn();
    M.layers.enable(2), (M.viewport = new mt());
    const C = [b, M],
      x = new kb();
    x.layers.enable(1), x.layers.enable(2);
    let T = null,
      D = null;
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (X) {
        let Y = y[X];
        return (
          Y === void 0 && ((Y = new th()), (y[X] = Y)), Y.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (X) {
        let Y = y[X];
        return Y === void 0 && ((Y = new th()), (y[X] = Y)), Y.getGripSpace();
      }),
      (this.getHand = function (X) {
        let Y = y[X];
        return Y === void 0 && ((Y = new th()), (y[X] = Y)), Y.getHandSpace();
      });
    function N(X) {
      const Y = v.indexOf(X.inputSource);
      if (Y === -1) return;
      const le = y[Y];
      le !== void 0 &&
        (le.update(X.inputSource, X.frame, c || a),
        le.dispatchEvent({ type: X.type, data: X.inputSource }));
    }
    function L() {
      i.removeEventListener("select", N),
        i.removeEventListener("selectstart", N),
        i.removeEventListener("selectend", N),
        i.removeEventListener("squeeze", N),
        i.removeEventListener("squeezestart", N),
        i.removeEventListener("squeezeend", N),
        i.removeEventListener("end", L),
        i.removeEventListener("inputsourceschange", F);
      for (let X = 0; X < y.length; X++) {
        const Y = v[X];
        Y !== null && ((v[X] = null), y[X].disconnect(Y));
      }
      (T = null),
        (D = null),
        e.setRenderTarget(_),
        (p = null),
        (f = null),
        (h = null),
        (i = null),
        (d = null),
        te.stop(),
        (n.isPresenting = !1),
        n.dispatchEvent({ type: "sessionend" });
    }
    (this.setFramebufferScaleFactor = function (X) {
      (s = X),
        n.isPresenting === !0 &&
          console.warn(
            "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
          );
    }),
      (this.setReferenceSpaceType = function (X) {
        (o = X),
          n.isPresenting === !0 &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return c || a;
      }),
      (this.setReferenceSpace = function (X) {
        c = X;
      }),
      (this.getBaseLayer = function () {
        return f !== null ? f : p;
      }),
      (this.getBinding = function () {
        return h;
      }),
      (this.getFrame = function () {
        return g;
      }),
      (this.getSession = function () {
        return i;
      }),
      (this.setSession = async function (X) {
        if (((i = X), i !== null)) {
          if (
            ((_ = e.getRenderTarget()),
            i.addEventListener("select", N),
            i.addEventListener("selectstart", N),
            i.addEventListener("selectend", N),
            i.addEventListener("squeeze", N),
            i.addEventListener("squeezestart", N),
            i.addEventListener("squeezeend", N),
            i.addEventListener("end", L),
            i.addEventListener("inputsourceschange", F),
            m.xrCompatible !== !0 && (await t.makeXRCompatible()),
            i.renderState.layers === void 0 || e.capabilities.isWebGL2 === !1)
          ) {
            const Y = {
              antialias: i.renderState.layers === void 0 ? m.antialias : !0,
              alpha: !0,
              depth: m.depth,
              stencil: m.stencil,
              framebufferScaleFactor: s,
            };
            (p = new XRWebGLLayer(i, t, Y)),
              i.updateRenderState({ baseLayer: p }),
              (d = new bs(p.framebufferWidth, p.framebufferHeight, {
                format: Qn,
                type: Ms,
                colorSpace: e.outputColorSpace,
                stencilBuffer: m.stencil,
              }));
          } else {
            let Y = null,
              le = null,
              W = null;
            m.depth &&
              ((W = m.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (Y = m.stencil ? Ua : hs),
              (le = m.stencil ? Ma : os));
            const O = { colorFormat: t.RGBA8, depthFormat: W, scaleFactor: s };
            (h = new XRWebGLBinding(i, t)),
              (f = h.createProjectionLayer(O)),
              i.updateRenderState({ layers: [f] }),
              (d = new bs(f.textureWidth, f.textureHeight, {
                format: Qn,
                type: Ms,
                depthTexture: new Hb(
                  f.textureWidth,
                  f.textureHeight,
                  le,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  Y
                ),
                stencilBuffer: m.stencil,
                colorSpace: e.outputColorSpace,
                samples: m.antialias ? 4 : 0,
              }));
            const Me = e.properties.get(d);
            Me.__ignoreDepthValues = f.ignoreDepthValues;
          }
          (d.isXRRenderTarget = !0),
            this.setFoveation(l),
            (c = null),
            (a = await i.requestReferenceSpace(o)),
            te.setContext(i),
            te.start(),
            (n.isPresenting = !0),
            n.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (i !== null) return i.environmentBlendMode;
      });
    function F(X) {
      for (let Y = 0; Y < X.removed.length; Y++) {
        const le = X.removed[Y],
          W = v.indexOf(le);
        W >= 0 && ((v[W] = null), y[W].disconnect(le));
      }
      for (let Y = 0; Y < X.added.length; Y++) {
        const le = X.added[Y];
        let W = v.indexOf(le);
        if (W === -1) {
          for (let Me = 0; Me < y.length; Me++)
            if (Me >= v.length) {
              v.push(le), (W = Me);
              break;
            } else if (v[Me] === null) {
              (v[Me] = le), (W = Me);
              break;
            }
          if (W === -1) break;
        }
        const O = y[W];
        O && O.connect(le);
      }
    }
    const I = new H(),
      j = new H();
    function A(X, Y, le) {
      I.setFromMatrixPosition(Y.matrixWorld),
        j.setFromMatrixPosition(le.matrixWorld);
      const W = I.distanceTo(j),
        O = Y.projectionMatrix.elements,
        Me = le.projectionMatrix.elements,
        ve = O[14] / (O[10] - 1),
        re = O[14] / (O[10] + 1),
        be = (O[9] + 1) / O[5],
        Fe = (O[9] - 1) / O[5],
        ae = (O[8] - 1) / O[0],
        _e = (Me[8] + 1) / Me[0],
        K = ve * ae,
        $e = ve * _e,
        ct = W / (-ae + _e),
        Ge = ct * -ae;
      Y.matrixWorld.decompose(X.position, X.quaternion, X.scale),
        X.translateX(Ge),
        X.translateZ(ct),
        X.matrixWorld.compose(X.position, X.quaternion, X.scale),
        X.matrixWorldInverse.copy(X.matrixWorld).invert();
      const Xe = ve + ct,
        st = re + ct,
        Et = K - Ge,
        P = $e + (W - Ge),
        w = ((be * re) / st) * Xe,
        $ = ((Fe * re) / st) * Xe;
      X.projectionMatrix.makePerspective(Et, P, w, $, Xe, st),
        X.projectionMatrixInverse.copy(X.projectionMatrix).invert();
    }
    function k(X, Y) {
      Y === null
        ? X.matrixWorld.copy(X.matrix)
        : X.matrixWorld.multiplyMatrices(Y.matrixWorld, X.matrix),
        X.matrixWorldInverse.copy(X.matrixWorld).invert();
    }
    this.updateCamera = function (X) {
      if (i === null) return;
      (x.near = M.near = b.near = X.near),
        (x.far = M.far = b.far = X.far),
        (T !== x.near || D !== x.far) &&
          (i.updateRenderState({ depthNear: x.near, depthFar: x.far }),
          (T = x.near),
          (D = x.far));
      const Y = X.parent,
        le = x.cameras;
      k(x, Y);
      for (let W = 0; W < le.length; W++) k(le[W], Y);
      le.length === 2
        ? A(x, b, M)
        : x.projectionMatrix.copy(b.projectionMatrix),
        G(X, x, Y);
    };
    function G(X, Y, le) {
      le === null
        ? X.matrix.copy(Y.matrixWorld)
        : (X.matrix.copy(le.matrixWorld),
          X.matrix.invert(),
          X.matrix.multiply(Y.matrixWorld)),
        X.matrix.decompose(X.position, X.quaternion, X.scale),
        X.updateMatrixWorld(!0);
      const W = X.children;
      for (let O = 0, Me = W.length; O < Me; O++) W[O].updateMatrixWorld(!0);
      X.projectionMatrix.copy(Y.projectionMatrix),
        X.projectionMatrixInverse.copy(Y.projectionMatrixInverse),
        X.isPerspectiveCamera &&
          ((X.fov = Ba * 2 * Math.atan(1 / X.projectionMatrix.elements[5])),
          (X.zoom = 1));
    }
    (this.getCamera = function () {
      return x;
    }),
      (this.getFoveation = function () {
        if (!(f === null && p === null)) return l;
      }),
      (this.setFoveation = function (X) {
        (l = X),
          f !== null && (f.fixedFoveation = X),
          p !== null && p.fixedFoveation !== void 0 && (p.fixedFoveation = X);
      }),
      (this.getPlanes = function () {
        return S;
      });
    let z = null;
    function oe(X, Y) {
      if (((u = Y.getViewerPose(c || a)), (g = Y), u !== null)) {
        const le = u.views;
        p !== null &&
          (e.setRenderTargetFramebuffer(d, p.framebuffer),
          e.setRenderTarget(d));
        let W = !1;
        le.length !== x.cameras.length && ((x.cameras.length = 0), (W = !0));
        for (let O = 0; O < le.length; O++) {
          const Me = le[O];
          let ve = null;
          if (p !== null) ve = p.getViewport(Me);
          else {
            const be = h.getViewSubImage(f, Me);
            (ve = be.viewport),
              O === 0 &&
                (e.setRenderTargetTextures(
                  d,
                  be.colorTexture,
                  f.ignoreDepthValues ? void 0 : be.depthStencilTexture
                ),
                e.setRenderTarget(d));
          }
          let re = C[O];
          re === void 0 &&
            ((re = new mn()),
            re.layers.enable(O),
            (re.viewport = new mt()),
            (C[O] = re)),
            re.matrix.fromArray(Me.transform.matrix),
            re.matrix.decompose(re.position, re.quaternion, re.scale),
            re.projectionMatrix.fromArray(Me.projectionMatrix),
            re.projectionMatrixInverse.copy(re.projectionMatrix).invert(),
            re.viewport.set(ve.x, ve.y, ve.width, ve.height),
            O === 0 &&
              (x.matrix.copy(re.matrix),
              x.matrix.decompose(x.position, x.quaternion, x.scale)),
            W === !0 && x.cameras.push(re);
        }
      }
      for (let le = 0; le < y.length; le++) {
        const W = v[le],
          O = y[le];
        W !== null && O !== void 0 && O.update(W, Y, c || a);
      }
      if ((z && z(X, Y), Y.detectedPlanes)) {
        n.dispatchEvent({ type: "planesdetected", data: Y.detectedPlanes });
        let le = null;
        for (const W of S)
          Y.detectedPlanes.has(W) || (le === null && (le = []), le.push(W));
        if (le !== null)
          for (const W of le)
            S.delete(W),
              E.delete(W),
              n.dispatchEvent({ type: "planeremoved", data: W });
        for (const W of Y.detectedPlanes)
          if (!S.has(W))
            S.add(W),
              E.set(W, Y.lastChangedTime),
              n.dispatchEvent({ type: "planeadded", data: W });
          else {
            const O = E.get(W);
            W.lastChangedTime > O &&
              (E.set(W, W.lastChangedTime),
              n.dispatchEvent({ type: "planechanged", data: W }));
          }
      }
      g = null;
    }
    const te = new ng();
    te.setAnimationLoop(oe),
      (this.setAnimationLoop = function (X) {
        z = X;
      }),
      (this.dispose = function () {});
  }
}
function Gb(r, e) {
  function t(_, d) {
    _.matrixAutoUpdate === !0 && _.updateMatrix(), d.value.copy(_.matrix);
  }
  function n(_, d) {
    d.color.getRGB(_.fogColor.value, Q_(r)),
      d.isFog
        ? ((_.fogNear.value = d.near), (_.fogFar.value = d.far))
        : d.isFogExp2 && (_.fogDensity.value = d.density);
  }
  function i(_, d, y, v, S) {
    d.isMeshBasicMaterial || d.isMeshLambertMaterial
      ? s(_, d)
      : d.isMeshToonMaterial
      ? (s(_, d), h(_, d))
      : d.isMeshPhongMaterial
      ? (s(_, d), u(_, d))
      : d.isMeshStandardMaterial
      ? (s(_, d), f(_, d), d.isMeshPhysicalMaterial && p(_, d, S))
      : d.isMeshMatcapMaterial
      ? (s(_, d), g(_, d))
      : d.isMeshDepthMaterial
      ? s(_, d)
      : d.isMeshDistanceMaterial
      ? (s(_, d), m(_, d))
      : d.isMeshNormalMaterial
      ? s(_, d)
      : d.isLineBasicMaterial
      ? (a(_, d), d.isLineDashedMaterial && o(_, d))
      : d.isPointsMaterial
      ? l(_, d, y, v)
      : d.isSpriteMaterial
      ? c(_, d)
      : d.isShadowMaterial
      ? (_.color.value.copy(d.color), (_.opacity.value = d.opacity))
      : d.isShaderMaterial && (d.uniformsNeedUpdate = !1);
  }
  function s(_, d) {
    (_.opacity.value = d.opacity),
      d.color && _.diffuse.value.copy(d.color),
      d.emissive &&
        _.emissive.value.copy(d.emissive).multiplyScalar(d.emissiveIntensity),
      d.map && ((_.map.value = d.map), t(d.map, _.mapTransform)),
      d.alphaMap &&
        ((_.alphaMap.value = d.alphaMap), t(d.alphaMap, _.alphaMapTransform)),
      d.bumpMap &&
        ((_.bumpMap.value = d.bumpMap),
        t(d.bumpMap, _.bumpMapTransform),
        (_.bumpScale.value = d.bumpScale),
        d.side === bn && (_.bumpScale.value *= -1)),
      d.normalMap &&
        ((_.normalMap.value = d.normalMap),
        t(d.normalMap, _.normalMapTransform),
        _.normalScale.value.copy(d.normalScale),
        d.side === bn && _.normalScale.value.negate()),
      d.displacementMap &&
        ((_.displacementMap.value = d.displacementMap),
        t(d.displacementMap, _.displacementMapTransform),
        (_.displacementScale.value = d.displacementScale),
        (_.displacementBias.value = d.displacementBias)),
      d.emissiveMap &&
        ((_.emissiveMap.value = d.emissiveMap),
        t(d.emissiveMap, _.emissiveMapTransform)),
      d.specularMap &&
        ((_.specularMap.value = d.specularMap),
        t(d.specularMap, _.specularMapTransform)),
      d.alphaTest > 0 && (_.alphaTest.value = d.alphaTest);
    const y = e.get(d).envMap;
    if (
      (y &&
        ((_.envMap.value = y),
        (_.flipEnvMap.value =
          y.isCubeTexture && y.isRenderTargetTexture === !1 ? -1 : 1),
        (_.reflectivity.value = d.reflectivity),
        (_.ior.value = d.ior),
        (_.refractionRatio.value = d.refractionRatio)),
      d.lightMap)
    ) {
      _.lightMap.value = d.lightMap;
      const v = r.useLegacyLights === !0 ? Math.PI : 1;
      (_.lightMapIntensity.value = d.lightMapIntensity * v),
        t(d.lightMap, _.lightMapTransform);
    }
    d.aoMap &&
      ((_.aoMap.value = d.aoMap),
      (_.aoMapIntensity.value = d.aoMapIntensity),
      t(d.aoMap, _.aoMapTransform));
  }
  function a(_, d) {
    _.diffuse.value.copy(d.color),
      (_.opacity.value = d.opacity),
      d.map && ((_.map.value = d.map), t(d.map, _.mapTransform));
  }
  function o(_, d) {
    (_.dashSize.value = d.dashSize),
      (_.totalSize.value = d.dashSize + d.gapSize),
      (_.scale.value = d.scale);
  }
  function l(_, d, y, v) {
    _.diffuse.value.copy(d.color),
      (_.opacity.value = d.opacity),
      (_.size.value = d.size * y),
      (_.scale.value = v * 0.5),
      d.map && ((_.map.value = d.map), t(d.map, _.uvTransform)),
      d.alphaMap && (_.alphaMap.value = d.alphaMap),
      d.alphaTest > 0 && (_.alphaTest.value = d.alphaTest);
  }
  function c(_, d) {
    _.diffuse.value.copy(d.color),
      (_.opacity.value = d.opacity),
      (_.rotation.value = d.rotation),
      d.map && ((_.map.value = d.map), t(d.map, _.mapTransform)),
      d.alphaMap && (_.alphaMap.value = d.alphaMap),
      d.alphaTest > 0 && (_.alphaTest.value = d.alphaTest);
  }
  function u(_, d) {
    _.specular.value.copy(d.specular),
      (_.shininess.value = Math.max(d.shininess, 1e-4));
  }
  function h(_, d) {
    d.gradientMap && (_.gradientMap.value = d.gradientMap);
  }
  function f(_, d) {
    (_.metalness.value = d.metalness),
      d.metalnessMap &&
        ((_.metalnessMap.value = d.metalnessMap),
        t(d.metalnessMap, _.metalnessMapTransform)),
      (_.roughness.value = d.roughness),
      d.roughnessMap &&
        ((_.roughnessMap.value = d.roughnessMap),
        t(d.roughnessMap, _.roughnessMapTransform)),
      e.get(d).envMap && (_.envMapIntensity.value = d.envMapIntensity);
  }
  function p(_, d, y) {
    (_.ior.value = d.ior),
      d.sheen > 0 &&
        (_.sheenColor.value.copy(d.sheenColor).multiplyScalar(d.sheen),
        (_.sheenRoughness.value = d.sheenRoughness),
        d.sheenColorMap &&
          ((_.sheenColorMap.value = d.sheenColorMap),
          t(d.sheenColorMap, _.sheenColorMapTransform)),
        d.sheenRoughnessMap &&
          ((_.sheenRoughnessMap.value = d.sheenRoughnessMap),
          t(d.sheenRoughnessMap, _.sheenRoughnessMapTransform))),
      d.clearcoat > 0 &&
        ((_.clearcoat.value = d.clearcoat),
        (_.clearcoatRoughness.value = d.clearcoatRoughness),
        d.clearcoatMap &&
          ((_.clearcoatMap.value = d.clearcoatMap),
          t(d.clearcoatMap, _.clearcoatMapTransform)),
        d.clearcoatRoughnessMap &&
          ((_.clearcoatRoughnessMap.value = d.clearcoatRoughnessMap),
          t(d.clearcoatRoughnessMap, _.clearcoatRoughnessMapTransform)),
        d.clearcoatNormalMap &&
          ((_.clearcoatNormalMap.value = d.clearcoatNormalMap),
          t(d.clearcoatNormalMap, _.clearcoatNormalMapTransform),
          _.clearcoatNormalScale.value.copy(d.clearcoatNormalScale),
          d.side === bn && _.clearcoatNormalScale.value.negate())),
      d.iridescence > 0 &&
        ((_.iridescence.value = d.iridescence),
        (_.iridescenceIOR.value = d.iridescenceIOR),
        (_.iridescenceThicknessMinimum.value = d.iridescenceThicknessRange[0]),
        (_.iridescenceThicknessMaximum.value = d.iridescenceThicknessRange[1]),
        d.iridescenceMap &&
          ((_.iridescenceMap.value = d.iridescenceMap),
          t(d.iridescenceMap, _.iridescenceMapTransform)),
        d.iridescenceThicknessMap &&
          ((_.iridescenceThicknessMap.value = d.iridescenceThicknessMap),
          t(d.iridescenceThicknessMap, _.iridescenceThicknessMapTransform))),
      d.transmission > 0 &&
        ((_.transmission.value = d.transmission),
        (_.transmissionSamplerMap.value = y.texture),
        _.transmissionSamplerSize.value.set(y.width, y.height),
        d.transmissionMap &&
          ((_.transmissionMap.value = d.transmissionMap),
          t(d.transmissionMap, _.transmissionMapTransform)),
        (_.thickness.value = d.thickness),
        d.thicknessMap &&
          ((_.thicknessMap.value = d.thicknessMap),
          t(d.thicknessMap, _.thicknessMapTransform)),
        (_.attenuationDistance.value = d.attenuationDistance),
        _.attenuationColor.value.copy(d.attenuationColor)),
      (_.specularIntensity.value = d.specularIntensity),
      _.specularColor.value.copy(d.specularColor),
      d.specularColorMap &&
        ((_.specularColorMap.value = d.specularColorMap),
        t(d.specularColorMap, _.specularColorMapTransform)),
      d.specularIntensityMap &&
        ((_.specularIntensityMap.value = d.specularIntensityMap),
        t(d.specularIntensityMap, _.specularIntensityMapTransform));
  }
  function g(_, d) {
    d.matcap && (_.matcap.value = d.matcap);
  }
  function m(_, d) {
    const y = e.get(d).light;
    _.referencePosition.value.setFromMatrixPosition(y.matrixWorld),
      (_.nearDistance.value = y.shadow.camera.near),
      (_.farDistance.value = y.shadow.camera.far);
  }
  return { refreshFogUniforms: n, refreshMaterialUniforms: i };
}
function Wb(r, e, t, n) {
  let i = {},
    s = {},
    a = [];
  const o = t.isWebGL2 ? r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function l(y, v) {
    const S = v.program;
    n.uniformBlockBinding(y, S);
  }
  function c(y, v) {
    let S = i[y.id];
    S === void 0 &&
      (g(y), (S = u(y)), (i[y.id] = S), y.addEventListener("dispose", _));
    const E = v.program;
    n.updateUBOMapping(y, E);
    const b = e.render.frame;
    s[y.id] !== b && (f(y), (s[y.id] = b));
  }
  function u(y) {
    const v = h();
    y.__bindingPointIndex = v;
    const S = r.createBuffer(),
      E = y.__size,
      b = y.usage;
    return (
      r.bindBuffer(r.UNIFORM_BUFFER, S),
      r.bufferData(r.UNIFORM_BUFFER, E, b),
      r.bindBuffer(r.UNIFORM_BUFFER, null),
      r.bindBufferBase(r.UNIFORM_BUFFER, v, S),
      S
    );
  }
  function h() {
    for (let y = 0; y < o; y++) if (a.indexOf(y) === -1) return a.push(y), y;
    return (
      console.error(
        "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
      ),
      0
    );
  }
  function f(y) {
    const v = i[y.id],
      S = y.uniforms,
      E = y.__cache;
    r.bindBuffer(r.UNIFORM_BUFFER, v);
    for (let b = 0, M = S.length; b < M; b++) {
      const C = S[b];
      if (p(C, b, E) === !0) {
        const x = C.__offset,
          T = Array.isArray(C.value) ? C.value : [C.value];
        let D = 0;
        for (let N = 0; N < T.length; N++) {
          const L = T[N],
            F = m(L);
          typeof L == "number"
            ? ((C.__data[0] = L),
              r.bufferSubData(r.UNIFORM_BUFFER, x + D, C.__data))
            : L.isMatrix3
            ? ((C.__data[0] = L.elements[0]),
              (C.__data[1] = L.elements[1]),
              (C.__data[2] = L.elements[2]),
              (C.__data[3] = L.elements[0]),
              (C.__data[4] = L.elements[3]),
              (C.__data[5] = L.elements[4]),
              (C.__data[6] = L.elements[5]),
              (C.__data[7] = L.elements[0]),
              (C.__data[8] = L.elements[6]),
              (C.__data[9] = L.elements[7]),
              (C.__data[10] = L.elements[8]),
              (C.__data[11] = L.elements[0]))
            : (L.toArray(C.__data, D),
              (D += F.storage / Float32Array.BYTES_PER_ELEMENT));
        }
        r.bufferSubData(r.UNIFORM_BUFFER, x, C.__data);
      }
    }
    r.bindBuffer(r.UNIFORM_BUFFER, null);
  }
  function p(y, v, S) {
    const E = y.value;
    if (S[v] === void 0) {
      if (typeof E == "number") S[v] = E;
      else {
        const b = Array.isArray(E) ? E : [E],
          M = [];
        for (let C = 0; C < b.length; C++) M.push(b[C].clone());
        S[v] = M;
      }
      return !0;
    } else if (typeof E == "number") {
      if (S[v] !== E) return (S[v] = E), !0;
    } else {
      const b = Array.isArray(S[v]) ? S[v] : [S[v]],
        M = Array.isArray(E) ? E : [E];
      for (let C = 0; C < b.length; C++) {
        const x = b[C];
        if (x.equals(M[C]) === !1) return x.copy(M[C]), !0;
      }
    }
    return !1;
  }
  function g(y) {
    const v = y.uniforms;
    let S = 0;
    const E = 16;
    let b = 0;
    for (let M = 0, C = v.length; M < C; M++) {
      const x = v[M],
        T = { boundary: 0, storage: 0 },
        D = Array.isArray(x.value) ? x.value : [x.value];
      for (let N = 0, L = D.length; N < L; N++) {
        const F = D[N],
          I = m(F);
        (T.boundary += I.boundary), (T.storage += I.storage);
      }
      if (
        ((x.__data = new Float32Array(
          T.storage / Float32Array.BYTES_PER_ELEMENT
        )),
        (x.__offset = S),
        M > 0)
      ) {
        b = S % E;
        const N = E - b;
        b !== 0 && N - T.boundary < 0 && ((S += E - b), (x.__offset = S));
      }
      S += T.storage;
    }
    return (
      (b = S % E), b > 0 && (S += E - b), (y.__size = S), (y.__cache = {}), this
    );
  }
  function m(y) {
    const v = { boundary: 0, storage: 0 };
    return (
      typeof y == "number"
        ? ((v.boundary = 4), (v.storage = 4))
        : y.isVector2
        ? ((v.boundary = 8), (v.storage = 8))
        : y.isVector3 || y.isColor
        ? ((v.boundary = 16), (v.storage = 12))
        : y.isVector4
        ? ((v.boundary = 16), (v.storage = 16))
        : y.isMatrix3
        ? ((v.boundary = 48), (v.storage = 48))
        : y.isMatrix4
        ? ((v.boundary = 64), (v.storage = 64))
        : y.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            y
          ),
      v
    );
  }
  function _(y) {
    const v = y.target;
    v.removeEventListener("dispose", _);
    const S = a.indexOf(v.__bindingPointIndex);
    a.splice(S, 1), r.deleteBuffer(i[v.id]), delete i[v.id], delete s[v.id];
  }
  function d() {
    for (const y in i) r.deleteBuffer(i[y]);
    (a = []), (i = {}), (s = {});
  }
  return { bind: l, update: c, dispose: d };
}
function Xb() {
  const r = Wo("canvas");
  return (r.style.display = "block"), r;
}
class og {
  constructor(e = {}) {
    const {
      canvas: t = Xb(),
      context: n = null,
      depth: i = !0,
      stencil: s = !0,
      alpha: a = !1,
      antialias: o = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: c = !1,
      powerPreference: u = "default",
      failIfMajorPerformanceCaveat: h = !1,
    } = e;
    this.isWebGLRenderer = !0;
    let f;
    n !== null ? (f = n.getContextAttributes().alpha) : (f = a);
    let p = null,
      g = null;
    const m = [],
      _ = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.outputColorSpace = Ve),
      (this.useLegacyLights = !0),
      (this.toneMapping = rr),
      (this.toneMappingExposure = 1);
    const d = this;
    let y = !1,
      v = 0,
      S = 0,
      E = null,
      b = -1,
      M = null;
    const C = new mt(),
      x = new mt();
    let T = null,
      D = t.width,
      N = t.height,
      L = 1,
      F = null,
      I = null;
    const j = new mt(0, 0, D, N),
      A = new mt(0, 0, D, N);
    let k = !1;
    const G = new Cf();
    let z = !1,
      oe = !1,
      te = null;
    const X = new et(),
      Y = new H(),
      le = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function W() {
      return E === null ? L : 1;
    }
    let O = n;
    function Me(R, q) {
      for (let ie = 0; ie < R.length; ie++) {
        const V = R[ie],
          ee = t.getContext(V, q);
        if (ee !== null) return ee;
      }
      return null;
    }
    try {
      const R = {
        alpha: !0,
        depth: i,
        stencil: s,
        antialias: o,
        premultipliedAlpha: l,
        preserveDrawingBuffer: c,
        powerPreference: u,
        failIfMajorPerformanceCaveat: h,
      };
      if (
        ("setAttribute" in t &&
          t.setAttribute("data-engine", `three.js r${Af}`),
        t.addEventListener("webglcontextlost", Ae, !1),
        t.addEventListener("webglcontextrestored", xe, !1),
        t.addEventListener("webglcontextcreationerror", ze, !1),
        O === null)
      ) {
        const q = ["webgl2", "webgl", "experimental-webgl"];
        if (
          (d.isWebGL1Renderer === !0 && q.shift(), (O = Me(q, R)), O === null)
        )
          throw Me(q)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
      O.getShaderPrecisionFormat === void 0 &&
        (O.getShaderPrecisionFormat = function () {
          return { rangeMin: 1, rangeMax: 1, precision: 1 };
        });
    } catch (R) {
      throw (console.error("THREE.WebGLRenderer: " + R.message), R);
    }
    let ve,
      re,
      be,
      Fe,
      ae,
      _e,
      K,
      $e,
      ct,
      Ge,
      Xe,
      st,
      Et,
      P,
      w,
      $,
      ue,
      he,
      me,
      U,
      ne,
      J,
      ge,
      Te;
    function Le() {
      (ve = new nM(O)),
        (re = new $S(O, ve, e)),
        ve.init(re),
        (J = new Bb(O, ve, re)),
        (be = new Ub(O, ve, re)),
        (Fe = new sM(O)),
        (ae = new Sb()),
        (_e = new Fb(O, ve, be, ae, re, J, Fe)),
        (K = new JS(d)),
        ($e = new tM(d)),
        (ct = new gy(O, re)),
        (ge = new jS(O, ve, ct, re)),
        (Ge = new iM(O, ct, Fe, ge)),
        (Xe = new cM(O, Ge, ct, Fe)),
        (me = new lM(O, re, _e)),
        ($ = new ZS(ae)),
        (st = new Eb(d, K, $e, ve, re, ge, $)),
        (Et = new Gb(d, ae)),
        (P = new bb()),
        (w = new Pb(ve, re)),
        (he = new qS(d, K, $e, be, Xe, f, l)),
        (ue = new Ob(d, Xe, re)),
        (Te = new Wb(O, Fe, re, be)),
        (U = new KS(O, ve, Fe, re)),
        (ne = new rM(O, ve, Fe, re)),
        (Fe.programs = st.programs),
        (d.capabilities = re),
        (d.extensions = ve),
        (d.properties = ae),
        (d.renderLists = P),
        (d.shadowMap = ue),
        (d.state = be),
        (d.info = Fe);
    }
    Le();
    const ye = new Vb(d, O);
    (this.xr = ye),
      (this.getContext = function () {
        return O;
      }),
      (this.getContextAttributes = function () {
        return O.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const R = ve.get("WEBGL_lose_context");
        R && R.loseContext();
      }),
      (this.forceContextRestore = function () {
        const R = ve.get("WEBGL_lose_context");
        R && R.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return L;
      }),
      (this.setPixelRatio = function (R) {
        R !== void 0 && ((L = R), this.setSize(D, N, !1));
      }),
      (this.getSize = function (R) {
        return R.set(D, N);
      }),
      (this.setSize = function (R, q, ie = !0) {
        if (ye.isPresenting) {
          console.warn(
            "THREE.WebGLRenderer: Can't change size while VR device is presenting."
          );
          return;
        }
        (D = R),
          (N = q),
          (t.width = Math.floor(R * L)),
          (t.height = Math.floor(q * L)),
          ie === !0 &&
            ((t.style.width = R + "px"), (t.style.height = q + "px")),
          this.setViewport(0, 0, R, q);
      }),
      (this.getDrawingBufferSize = function (R) {
        return R.set(D * L, N * L).floor();
      }),
      (this.setDrawingBufferSize = function (R, q, ie) {
        (D = R),
          (N = q),
          (L = ie),
          (t.width = Math.floor(R * ie)),
          (t.height = Math.floor(q * ie)),
          this.setViewport(0, 0, R, q);
      }),
      (this.getCurrentViewport = function (R) {
        return R.copy(C);
      }),
      (this.getViewport = function (R) {
        return R.copy(j);
      }),
      (this.setViewport = function (R, q, ie, V) {
        R.isVector4 ? j.set(R.x, R.y, R.z, R.w) : j.set(R, q, ie, V),
          be.viewport(C.copy(j).multiplyScalar(L).floor());
      }),
      (this.getScissor = function (R) {
        return R.copy(A);
      }),
      (this.setScissor = function (R, q, ie, V) {
        R.isVector4 ? A.set(R.x, R.y, R.z, R.w) : A.set(R, q, ie, V),
          be.scissor(x.copy(A).multiplyScalar(L).floor());
      }),
      (this.getScissorTest = function () {
        return k;
      }),
      (this.setScissorTest = function (R) {
        be.setScissorTest((k = R));
      }),
      (this.setOpaqueSort = function (R) {
        F = R;
      }),
      (this.setTransparentSort = function (R) {
        I = R;
      }),
      (this.getClearColor = function (R) {
        return R.copy(he.getClearColor());
      }),
      (this.setClearColor = function () {
        he.setClearColor.apply(he, arguments);
      }),
      (this.getClearAlpha = function () {
        return he.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        he.setClearAlpha.apply(he, arguments);
      }),
      (this.clear = function (R = !0, q = !0, ie = !0) {
        let V = 0;
        R && (V |= O.COLOR_BUFFER_BIT),
          q && (V |= O.DEPTH_BUFFER_BIT),
          ie && (V |= O.STENCIL_BUFFER_BIT),
          O.clear(V);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", Ae, !1),
          t.removeEventListener("webglcontextrestored", xe, !1),
          t.removeEventListener("webglcontextcreationerror", ze, !1),
          P.dispose(),
          w.dispose(),
          ae.dispose(),
          K.dispose(),
          $e.dispose(),
          Xe.dispose(),
          ge.dispose(),
          Te.dispose(),
          st.dispose(),
          ye.dispose(),
          ye.removeEventListener("sessionstart", we),
          ye.removeEventListener("sessionend", de),
          te && (te.dispose(), (te = null)),
          se.stop();
      });
    function Ae(R) {
      R.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (y = !0);
    }
    function xe() {
      console.log("THREE.WebGLRenderer: Context Restored."), (y = !1);
      const R = Fe.autoReset,
        q = ue.enabled,
        ie = ue.autoUpdate,
        V = ue.needsUpdate,
        ee = ue.type;
      Le(),
        (Fe.autoReset = R),
        (ue.enabled = q),
        (ue.autoUpdate = ie),
        (ue.needsUpdate = V),
        (ue.type = ee);
    }
    function ze(R) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        R.statusMessage
      );
    }
    function ot(R) {
      const q = R.target;
      q.removeEventListener("dispose", ot), B(q);
    }
    function B(R) {
      Q(R), ae.remove(R);
    }
    function Q(R) {
      const q = ae.get(R).programs;
      q !== void 0 &&
        (q.forEach(function (ie) {
          st.releaseProgram(ie);
        }),
        R.isShaderMaterial && st.releaseShaderCache(R));
    }
    (this.renderBufferDirect = function (R, q, ie, V, ee, Ce) {
      q === null && (q = le);
      const Ue = ee.isMesh && ee.matrixWorld.determinant() < 0,
        Be = vt(R, q, ie, V, ee);
      be.setMaterial(V, Ue);
      let Ie = ie.index,
        De = 1;
      V.wireframe === !0 && ((Ie = Ge.getWireframeAttribute(ie)), (De = 2));
      const ke = ie.drawRange,
        qe = ie.attributes.position;
      let lt = ke.start * De,
        Pt = (ke.start + ke.count) * De;
      Ce !== null &&
        ((lt = Math.max(lt, Ce.start * De)),
        (Pt = Math.min(Pt, (Ce.start + Ce.count) * De))),
        Ie !== null
          ? ((lt = Math.max(lt, 0)), (Pt = Math.min(Pt, Ie.count)))
          : qe != null &&
            ((lt = Math.max(lt, 0)), (Pt = Math.min(Pt, qe.count)));
      const wt = Pt - lt;
      if (wt < 0 || wt === 1 / 0) return;
      ge.setup(ee, V, Be, ie, Ie);
      let Ln,
        xt = U;
      if (
        (Ie !== null && ((Ln = ct.get(Ie)), (xt = ne), xt.setIndex(Ln)),
        ee.isMesh)
      )
        V.wireframe === !0
          ? (be.setLineWidth(V.wireframeLinewidth * W()), xt.setMode(O.LINES))
          : xt.setMode(O.TRIANGLES);
      else if (ee.isLine) {
        let je = V.linewidth;
        je === void 0 && (je = 1),
          be.setLineWidth(je * W()),
          ee.isLineSegments
            ? xt.setMode(O.LINES)
            : ee.isLineLoop
            ? xt.setMode(O.LINE_LOOP)
            : xt.setMode(O.LINE_STRIP);
      } else
        ee.isPoints
          ? xt.setMode(O.POINTS)
          : ee.isSprite && xt.setMode(O.TRIANGLES);
      if (ee.isInstancedMesh) xt.renderInstances(lt, wt, ee.count);
      else if (ie.isInstancedBufferGeometry) {
        const je =
            ie._maxInstanceCount !== void 0 ? ie._maxInstanceCount : 1 / 0,
          bu = Math.min(ie.instanceCount, je);
        xt.renderInstances(lt, wt, bu);
      } else xt.render(lt, wt);
    }),
      (this.compile = function (R, q) {
        function ie(V, ee, Ce) {
          V.transparent === !0 && V.side === wi && V.forceSinglePass === !1
            ? ((V.side = bn),
              (V.needsUpdate = !0),
              Dt(V, ee, Ce),
              (V.side = or),
              (V.needsUpdate = !0),
              Dt(V, ee, Ce),
              (V.side = wi))
            : Dt(V, ee, Ce);
        }
        (g = w.get(R)),
          g.init(),
          _.push(g),
          R.traverseVisible(function (V) {
            V.isLight &&
              V.layers.test(q.layers) &&
              (g.pushLight(V), V.castShadow && g.pushShadow(V));
          }),
          g.setupLights(d.useLegacyLights),
          R.traverse(function (V) {
            const ee = V.material;
            if (ee)
              if (Array.isArray(ee))
                for (let Ce = 0; Ce < ee.length; Ce++) {
                  const Ue = ee[Ce];
                  ie(Ue, R, V);
                }
              else ie(ee, R, V);
          }),
          _.pop(),
          (g = null);
      });
    let fe = null;
    function Se(R) {
      fe && fe(R);
    }
    function we() {
      se.stop();
    }
    function de() {
      se.start();
    }
    const se = new ng();
    se.setAnimationLoop(Se),
      typeof self < "u" && se.setContext(self),
      (this.setAnimationLoop = function (R) {
        (fe = R), ye.setAnimationLoop(R), R === null ? se.stop() : se.start();
      }),
      ye.addEventListener("sessionstart", we),
      ye.addEventListener("sessionend", de),
      (this.render = function (R, q) {
        if (q !== void 0 && q.isCamera !== !0) {
          console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
          return;
        }
        if (y === !0) return;
        R.matrixWorldAutoUpdate === !0 && R.updateMatrixWorld(),
          q.parent === null &&
            q.matrixWorldAutoUpdate === !0 &&
            q.updateMatrixWorld(),
          ye.enabled === !0 &&
            ye.isPresenting === !0 &&
            (ye.cameraAutoUpdate === !0 && ye.updateCamera(q),
            (q = ye.getCamera())),
          R.isScene === !0 && R.onBeforeRender(d, R, q, E),
          (g = w.get(R, _.length)),
          g.init(),
          _.push(g),
          X.multiplyMatrices(q.projectionMatrix, q.matrixWorldInverse),
          G.setFromProjectionMatrix(X),
          (oe = this.localClippingEnabled),
          (z = $.init(this.clippingPlanes, oe)),
          (p = P.get(R, m.length)),
          p.init(),
          m.push(p),
          pe(R, q, 0, d.sortObjects),
          p.finish(),
          d.sortObjects === !0 && p.sort(F, I),
          z === !0 && $.beginShadows();
        const ie = g.state.shadowsArray;
        if (
          (ue.render(ie, R, q),
          z === !0 && $.endShadows(),
          this.info.autoReset === !0 && this.info.reset(),
          he.render(p, R),
          g.setupLights(d.useLegacyLights),
          q.isArrayCamera)
        ) {
          const V = q.cameras;
          for (let ee = 0, Ce = V.length; ee < Ce; ee++) {
            const Ue = V[ee];
            Re(p, R, Ue, Ue.viewport);
          }
        } else Re(p, R, q);
        E !== null &&
          (_e.updateMultisampleRenderTarget(E), _e.updateRenderTargetMipmap(E)),
          R.isScene === !0 && R.onAfterRender(d, R, q),
          ge.resetDefaultState(),
          (b = -1),
          (M = null),
          _.pop(),
          _.length > 0 ? (g = _[_.length - 1]) : (g = null),
          m.pop(),
          m.length > 0 ? (p = m[m.length - 1]) : (p = null);
      });
    function pe(R, q, ie, V) {
      if (R.visible === !1) return;
      if (R.layers.test(q.layers)) {
        if (R.isGroup) ie = R.renderOrder;
        else if (R.isLOD) R.autoUpdate === !0 && R.update(q);
        else if (R.isLight) g.pushLight(R), R.castShadow && g.pushShadow(R);
        else if (R.isSprite) {
          if (!R.frustumCulled || G.intersectsSprite(R)) {
            V && Y.setFromMatrixPosition(R.matrixWorld).applyMatrix4(X);
            const Ue = Xe.update(R),
              Be = R.material;
            Be.visible && p.push(R, Ue, Be, ie, Y.z, null);
          }
        } else if (
          (R.isMesh || R.isLine || R.isPoints) &&
          (!R.frustumCulled || G.intersectsObject(R))
        ) {
          R.isSkinnedMesh &&
            R.skeleton.frame !== Fe.render.frame &&
            (R.skeleton.update(), (R.skeleton.frame = Fe.render.frame));
          const Ue = Xe.update(R),
            Be = R.material;
          if (
            (V &&
              (Ue.boundingSphere === null && Ue.computeBoundingSphere(),
              Y.copy(Ue.boundingSphere.center)
                .applyMatrix4(R.matrixWorld)
                .applyMatrix4(X)),
            Array.isArray(Be))
          ) {
            const Ie = Ue.groups;
            for (let De = 0, ke = Ie.length; De < ke; De++) {
              const qe = Ie[De],
                lt = Be[qe.materialIndex];
              lt && lt.visible && p.push(R, Ue, lt, ie, Y.z, qe);
            }
          } else Be.visible && p.push(R, Ue, Be, ie, Y.z, null);
        }
      }
      const Ce = R.children;
      for (let Ue = 0, Be = Ce.length; Ue < Be; Ue++) pe(Ce[Ue], q, ie, V);
    }
    function Re(R, q, ie, V) {
      const ee = R.opaque,
        Ce = R.transmissive,
        Ue = R.transparent;
      g.setupLightsView(ie),
        z === !0 && $.setGlobalState(d.clippingPlanes, ie),
        Ce.length > 0 && Oe(ee, Ce, q, ie),
        V && be.viewport(C.copy(V)),
        ee.length > 0 && Ne(ee, q, ie),
        Ce.length > 0 && Ne(Ce, q, ie),
        Ue.length > 0 && Ne(Ue, q, ie),
        be.buffers.depth.setTest(!0),
        be.buffers.depth.setMask(!0),
        be.buffers.color.setMask(!0),
        be.setPolygonOffset(!1);
    }
    function Oe(R, q, ie, V) {
      if (te === null) {
        const Be = re.isWebGL2;
        te = new bs(1024, 1024, {
          generateMipmaps: !0,
          type: ve.has("EXT_color_buffer_half_float") ? Vo : Ms,
          minFilter: Ss,
          samples: Be && o === !0 ? 4 : 0,
        });
      }
      const ee = d.getRenderTarget();
      d.setRenderTarget(te), d.clear();
      const Ce = d.toneMapping;
      (d.toneMapping = rr),
        Ne(R, ie, V),
        _e.updateMultisampleRenderTarget(te),
        _e.updateRenderTargetMipmap(te);
      let Ue = !1;
      for (let Be = 0, Ie = q.length; Be < Ie; Be++) {
        const De = q[Be],
          ke = De.object,
          qe = De.geometry,
          lt = De.material,
          Pt = De.group;
        if (lt.side === wi && ke.layers.test(V.layers)) {
          const wt = lt.side;
          (lt.side = bn),
            (lt.needsUpdate = !0),
            tt(ke, ie, V, qe, lt, Pt),
            (lt.side = wt),
            (lt.needsUpdate = !0),
            (Ue = !0);
        }
      }
      Ue === !0 &&
        (_e.updateMultisampleRenderTarget(te), _e.updateRenderTargetMipmap(te)),
        d.setRenderTarget(ee),
        (d.toneMapping = Ce);
    }
    function Ne(R, q, ie) {
      const V = q.isScene === !0 ? q.overrideMaterial : null;
      for (let ee = 0, Ce = R.length; ee < Ce; ee++) {
        const Ue = R[ee],
          Be = Ue.object,
          Ie = Ue.geometry,
          De = V === null ? Ue.material : V,
          ke = Ue.group;
        Be.layers.test(ie.layers) && tt(Be, q, ie, Ie, De, ke);
      }
    }
    function tt(R, q, ie, V, ee, Ce) {
      R.onBeforeRender(d, q, ie, V, ee, Ce),
        R.modelViewMatrix.multiplyMatrices(
          ie.matrixWorldInverse,
          R.matrixWorld
        ),
        R.normalMatrix.getNormalMatrix(R.modelViewMatrix),
        ee.onBeforeRender(d, q, ie, V, R, Ce),
        ee.transparent === !0 && ee.side === wi && ee.forceSinglePass === !1
          ? ((ee.side = bn),
            (ee.needsUpdate = !0),
            d.renderBufferDirect(ie, q, V, ee, R, Ce),
            (ee.side = or),
            (ee.needsUpdate = !0),
            d.renderBufferDirect(ie, q, V, ee, R, Ce),
            (ee.side = wi))
          : d.renderBufferDirect(ie, q, V, ee, R, Ce),
        R.onAfterRender(d, q, ie, V, ee, Ce);
    }
    function Dt(R, q, ie) {
      q.isScene !== !0 && (q = le);
      const V = ae.get(R),
        ee = g.state.lights,
        Ce = g.state.shadowsArray,
        Ue = ee.state.version,
        Be = st.getParameters(R, ee.state, Ce, q, ie),
        Ie = st.getProgramCacheKey(Be);
      let De = V.programs;
      (V.environment = R.isMeshStandardMaterial ? q.environment : null),
        (V.fog = q.fog),
        (V.envMap = (R.isMeshStandardMaterial ? $e : K).get(
          R.envMap || V.environment
        )),
        De === void 0 &&
          (R.addEventListener("dispose", ot),
          (De = new Map()),
          (V.programs = De));
      let ke = De.get(Ie);
      if (ke !== void 0) {
        if (V.currentProgram === ke && V.lightsStateVersion === Ue)
          return It(R, Be), ke;
      } else
        (Be.uniforms = st.getUniforms(R)),
          R.onBuild(ie, Be, d),
          R.onBeforeCompile(Be, d),
          (ke = st.acquireProgram(Be, Ie)),
          De.set(Ie, ke),
          (V.uniforms = Be.uniforms);
      const qe = V.uniforms;
      ((!R.isShaderMaterial && !R.isRawShaderMaterial) || R.clipping === !0) &&
        (qe.clippingPlanes = $.uniform),
        It(R, Be),
        (V.needsLights = Pn(R)),
        (V.lightsStateVersion = Ue),
        V.needsLights &&
          ((qe.ambientLightColor.value = ee.state.ambient),
          (qe.lightProbe.value = ee.state.probe),
          (qe.directionalLights.value = ee.state.directional),
          (qe.directionalLightShadows.value = ee.state.directionalShadow),
          (qe.spotLights.value = ee.state.spot),
          (qe.spotLightShadows.value = ee.state.spotShadow),
          (qe.rectAreaLights.value = ee.state.rectArea),
          (qe.ltc_1.value = ee.state.rectAreaLTC1),
          (qe.ltc_2.value = ee.state.rectAreaLTC2),
          (qe.pointLights.value = ee.state.point),
          (qe.pointLightShadows.value = ee.state.pointShadow),
          (qe.hemisphereLights.value = ee.state.hemi),
          (qe.directionalShadowMap.value = ee.state.directionalShadowMap),
          (qe.directionalShadowMatrix.value = ee.state.directionalShadowMatrix),
          (qe.spotShadowMap.value = ee.state.spotShadowMap),
          (qe.spotLightMatrix.value = ee.state.spotLightMatrix),
          (qe.spotLightMap.value = ee.state.spotLightMap),
          (qe.pointShadowMap.value = ee.state.pointShadowMap),
          (qe.pointShadowMatrix.value = ee.state.pointShadowMatrix));
      const lt = ke.getUniforms(),
        Pt = mc.seqWithValue(lt.seq, qe);
      return (V.currentProgram = ke), (V.uniformsList = Pt), ke;
    }
    function It(R, q) {
      const ie = ae.get(R);
      (ie.outputColorSpace = q.outputColorSpace),
        (ie.instancing = q.instancing),
        (ie.skinning = q.skinning),
        (ie.morphTargets = q.morphTargets),
        (ie.morphNormals = q.morphNormals),
        (ie.morphColors = q.morphColors),
        (ie.morphTargetsCount = q.morphTargetsCount),
        (ie.numClippingPlanes = q.numClippingPlanes),
        (ie.numIntersection = q.numClipIntersection),
        (ie.vertexAlphas = q.vertexAlphas),
        (ie.vertexTangents = q.vertexTangents),
        (ie.toneMapping = q.toneMapping);
    }
    function vt(R, q, ie, V, ee) {
      q.isScene !== !0 && (q = le), _e.resetTextureUnits();
      const Ce = q.fog,
        Ue = V.isMeshStandardMaterial ? q.environment : null,
        Be =
          E === null
            ? d.outputColorSpace
            : E.isXRRenderTarget === !0
            ? E.texture.colorSpace
            : Ii,
        Ie = (V.isMeshStandardMaterial ? $e : K).get(V.envMap || Ue),
        De =
          V.vertexColors === !0 &&
          !!ie.attributes.color &&
          ie.attributes.color.itemSize === 4,
        ke = !!V.normalMap && !!ie.attributes.tangent,
        qe = !!ie.morphAttributes.position,
        lt = !!ie.morphAttributes.normal,
        Pt = !!ie.morphAttributes.color,
        wt = V.toneMapped ? d.toneMapping : rr,
        Ln =
          ie.morphAttributes.position ||
          ie.morphAttributes.normal ||
          ie.morphAttributes.color,
        xt = Ln !== void 0 ? Ln.length : 0,
        je = ae.get(V),
        bu = g.state.lights;
      if (z === !0 && (oe === !0 || R !== M)) {
        const Dn = R === M && V.id === b;
        $.setState(V, R, Dn);
      }
      let Gt = !1;
      V.version === je.__version
        ? ((je.needsLights && je.lightsStateVersion !== bu.state.version) ||
            je.outputColorSpace !== Be ||
            (ee.isInstancedMesh && je.instancing === !1) ||
            (!ee.isInstancedMesh && je.instancing === !0) ||
            (ee.isSkinnedMesh && je.skinning === !1) ||
            (!ee.isSkinnedMesh && je.skinning === !0) ||
            je.envMap !== Ie ||
            (V.fog === !0 && je.fog !== Ce) ||
            (je.numClippingPlanes !== void 0 &&
              (je.numClippingPlanes !== $.numPlanes ||
                je.numIntersection !== $.numIntersection)) ||
            je.vertexAlphas !== De ||
            je.vertexTangents !== ke ||
            je.morphTargets !== qe ||
            je.morphNormals !== lt ||
            je.morphColors !== Pt ||
            je.toneMapping !== wt ||
            (re.isWebGL2 === !0 && je.morphTargetsCount !== xt)) &&
          (Gt = !0)
        : ((Gt = !0), (je.__version = V.version));
      let qr = je.currentProgram;
      Gt === !0 && (qr = Dt(V, q, ee));
      let Ld = !1,
        to = !1,
        Tu = !1;
      const ln = qr.getUniforms(),
        jr = je.uniforms;
      if (
        (be.useProgram(qr.program) && ((Ld = !0), (to = !0), (Tu = !0)),
        V.id !== b && ((b = V.id), (to = !0)),
        Ld || M !== R)
      ) {
        if (
          (ln.setValue(O, "projectionMatrix", R.projectionMatrix),
          re.logarithmicDepthBuffer &&
            ln.setValue(
              O,
              "logDepthBufFC",
              2 / (Math.log(R.far + 1) / Math.LN2)
            ),
          M !== R && ((M = R), (to = !0), (Tu = !0)),
          V.isShaderMaterial ||
            V.isMeshPhongMaterial ||
            V.isMeshToonMaterial ||
            V.isMeshStandardMaterial ||
            V.envMap)
        ) {
          const Dn = ln.map.cameraPosition;
          Dn !== void 0 &&
            Dn.setValue(O, Y.setFromMatrixPosition(R.matrixWorld));
        }
        (V.isMeshPhongMaterial ||
          V.isMeshToonMaterial ||
          V.isMeshLambertMaterial ||
          V.isMeshBasicMaterial ||
          V.isMeshStandardMaterial ||
          V.isShaderMaterial) &&
          ln.setValue(O, "isOrthographic", R.isOrthographicCamera === !0),
          (V.isMeshPhongMaterial ||
            V.isMeshToonMaterial ||
            V.isMeshLambertMaterial ||
            V.isMeshBasicMaterial ||
            V.isMeshStandardMaterial ||
            V.isShaderMaterial ||
            V.isShadowMaterial ||
            ee.isSkinnedMesh) &&
            ln.setValue(O, "viewMatrix", R.matrixWorldInverse);
      }
      if (ee.isSkinnedMesh) {
        ln.setOptional(O, ee, "bindMatrix"),
          ln.setOptional(O, ee, "bindMatrixInverse");
        const Dn = ee.skeleton;
        Dn &&
          (re.floatVertexTextures
            ? (Dn.boneTexture === null && Dn.computeBoneTexture(),
              ln.setValue(O, "boneTexture", Dn.boneTexture, _e),
              ln.setValue(O, "boneTextureSize", Dn.boneTextureSize))
            : console.warn(
                "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
              ));
      }
      const Au = ie.morphAttributes;
      if (
        ((Au.position !== void 0 ||
          Au.normal !== void 0 ||
          (Au.color !== void 0 && re.isWebGL2 === !0)) &&
          me.update(ee, ie, qr),
        (to || je.receiveShadow !== ee.receiveShadow) &&
          ((je.receiveShadow = ee.receiveShadow),
          ln.setValue(O, "receiveShadow", ee.receiveShadow)),
        V.isMeshGouraudMaterial &&
          V.envMap !== null &&
          ((jr.envMap.value = Ie),
          (jr.flipEnvMap.value =
            Ie.isCubeTexture && Ie.isRenderTargetTexture === !1 ? -1 : 1)),
        to &&
          (ln.setValue(O, "toneMappingExposure", d.toneMappingExposure),
          je.needsLights && ht(jr, Tu),
          Ce && V.fog === !0 && Et.refreshFogUniforms(jr, Ce),
          Et.refreshMaterialUniforms(jr, V, L, N, te),
          mc.upload(O, je.uniformsList, jr, _e)),
        V.isShaderMaterial &&
          V.uniformsNeedUpdate === !0 &&
          (mc.upload(O, je.uniformsList, jr, _e), (V.uniformsNeedUpdate = !1)),
        V.isSpriteMaterial && ln.setValue(O, "center", ee.center),
        ln.setValue(O, "modelViewMatrix", ee.modelViewMatrix),
        ln.setValue(O, "normalMatrix", ee.normalMatrix),
        ln.setValue(O, "modelMatrix", ee.matrixWorld),
        V.isShaderMaterial || V.isRawShaderMaterial)
      ) {
        const Dn = V.uniformsGroups;
        for (let wu = 0, Dv = Dn.length; wu < Dv; wu++)
          if (re.isWebGL2) {
            const Dd = Dn[wu];
            Te.update(Dd, qr), Te.bind(Dd, qr);
          } else
            console.warn(
              "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
            );
      }
      return qr;
    }
    function ht(R, q) {
      (R.ambientLightColor.needsUpdate = q),
        (R.lightProbe.needsUpdate = q),
        (R.directionalLights.needsUpdate = q),
        (R.directionalLightShadows.needsUpdate = q),
        (R.pointLights.needsUpdate = q),
        (R.pointLightShadows.needsUpdate = q),
        (R.spotLights.needsUpdate = q),
        (R.spotLightShadows.needsUpdate = q),
        (R.rectAreaLights.needsUpdate = q),
        (R.hemisphereLights.needsUpdate = q);
    }
    function Pn(R) {
      return (
        R.isMeshLambertMaterial ||
        R.isMeshToonMaterial ||
        R.isMeshPhongMaterial ||
        R.isMeshStandardMaterial ||
        R.isShadowMaterial ||
        (R.isShaderMaterial && R.lights === !0)
      );
    }
    (this.getActiveCubeFace = function () {
      return v;
    }),
      (this.getActiveMipmapLevel = function () {
        return S;
      }),
      (this.getRenderTarget = function () {
        return E;
      }),
      (this.setRenderTargetTextures = function (R, q, ie) {
        (ae.get(R.texture).__webglTexture = q),
          (ae.get(R.depthTexture).__webglTexture = ie);
        const V = ae.get(R);
        (V.__hasExternalTextures = !0),
          V.__hasExternalTextures &&
            ((V.__autoAllocateDepthBuffer = ie === void 0),
            V.__autoAllocateDepthBuffer ||
              (ve.has("WEBGL_multisampled_render_to_texture") === !0 &&
                (console.warn(
                  "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                ),
                (V.__useRenderToTexture = !1))));
      }),
      (this.setRenderTargetFramebuffer = function (R, q) {
        const ie = ae.get(R);
        (ie.__webglFramebuffer = q),
          (ie.__useDefaultFramebuffer = q === void 0);
      }),
      (this.setRenderTarget = function (R, q = 0, ie = 0) {
        (E = R), (v = q), (S = ie);
        let V = !0,
          ee = null,
          Ce = !1,
          Ue = !1;
        if (R) {
          const Ie = ae.get(R);
          Ie.__useDefaultFramebuffer !== void 0
            ? (be.bindFramebuffer(O.FRAMEBUFFER, null), (V = !1))
            : Ie.__webglFramebuffer === void 0
            ? _e.setupRenderTarget(R)
            : Ie.__hasExternalTextures &&
              _e.rebindTextures(
                R,
                ae.get(R.texture).__webglTexture,
                ae.get(R.depthTexture).__webglTexture
              );
          const De = R.texture;
          (De.isData3DTexture ||
            De.isDataArrayTexture ||
            De.isCompressedArrayTexture) &&
            (Ue = !0);
          const ke = ae.get(R).__webglFramebuffer;
          R.isWebGLCubeRenderTarget
            ? ((ee = ke[q]), (Ce = !0))
            : re.isWebGL2 && R.samples > 0 && _e.useMultisampledRTT(R) === !1
            ? (ee = ae.get(R).__webglMultisampledFramebuffer)
            : (ee = ke),
            C.copy(R.viewport),
            x.copy(R.scissor),
            (T = R.scissorTest);
        } else
          C.copy(j).multiplyScalar(L).floor(),
            x.copy(A).multiplyScalar(L).floor(),
            (T = k);
        if (
          (be.bindFramebuffer(O.FRAMEBUFFER, ee) &&
            re.drawBuffers &&
            V &&
            be.drawBuffers(R, ee),
          be.viewport(C),
          be.scissor(x),
          be.setScissorTest(T),
          Ce)
        ) {
          const Ie = ae.get(R.texture);
          O.framebufferTexture2D(
            O.FRAMEBUFFER,
            O.COLOR_ATTACHMENT0,
            O.TEXTURE_CUBE_MAP_POSITIVE_X + q,
            Ie.__webglTexture,
            ie
          );
        } else if (Ue) {
          const Ie = ae.get(R.texture),
            De = q || 0;
          O.framebufferTextureLayer(
            O.FRAMEBUFFER,
            O.COLOR_ATTACHMENT0,
            Ie.__webglTexture,
            ie || 0,
            De
          );
        }
        b = -1;
      }),
      (this.readRenderTargetPixels = function (R, q, ie, V, ee, Ce, Ue) {
        if (!(R && R.isWebGLRenderTarget)) {
          console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
          return;
        }
        let Be = ae.get(R).__webglFramebuffer;
        if ((R.isWebGLCubeRenderTarget && Ue !== void 0 && (Be = Be[Ue]), Be)) {
          be.bindFramebuffer(O.FRAMEBUFFER, Be);
          try {
            const Ie = R.texture,
              De = Ie.format,
              ke = Ie.type;
            if (
              De !== Qn &&
              J.convert(De) !==
                O.getParameter(O.IMPLEMENTATION_COLOR_READ_FORMAT)
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
              return;
            }
            const qe =
              ke === Vo &&
              (ve.has("EXT_color_buffer_half_float") ||
                (re.isWebGL2 && ve.has("EXT_color_buffer_float")));
            if (
              ke !== Ms &&
              J.convert(ke) !==
                O.getParameter(O.IMPLEMENTATION_COLOR_READ_TYPE) &&
              !(
                ke === Er &&
                (re.isWebGL2 ||
                  ve.has("OES_texture_float") ||
                  ve.has("WEBGL_color_buffer_float"))
              ) &&
              !qe
            ) {
              console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
              return;
            }
            q >= 0 &&
              q <= R.width - V &&
              ie >= 0 &&
              ie <= R.height - ee &&
              O.readPixels(q, ie, V, ee, J.convert(De), J.convert(ke), Ce);
          } finally {
            const Ie = E !== null ? ae.get(E).__webglFramebuffer : null;
            be.bindFramebuffer(O.FRAMEBUFFER, Ie);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (R, q, ie = 0) {
        const V = Math.pow(2, -ie),
          ee = Math.floor(q.image.width * V),
          Ce = Math.floor(q.image.height * V);
        _e.setTexture2D(q, 0),
          O.copyTexSubImage2D(O.TEXTURE_2D, ie, 0, 0, R.x, R.y, ee, Ce),
          be.unbindTexture();
      }),
      (this.copyTextureToTexture = function (R, q, ie, V = 0) {
        const ee = q.image.width,
          Ce = q.image.height,
          Ue = J.convert(ie.format),
          Be = J.convert(ie.type);
        _e.setTexture2D(ie, 0),
          O.pixelStorei(O.UNPACK_FLIP_Y_WEBGL, ie.flipY),
          O.pixelStorei(O.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ie.premultiplyAlpha),
          O.pixelStorei(O.UNPACK_ALIGNMENT, ie.unpackAlignment),
          q.isDataTexture
            ? O.texSubImage2D(
                O.TEXTURE_2D,
                V,
                R.x,
                R.y,
                ee,
                Ce,
                Ue,
                Be,
                q.image.data
              )
            : q.isCompressedTexture
            ? O.compressedTexSubImage2D(
                O.TEXTURE_2D,
                V,
                R.x,
                R.y,
                q.mipmaps[0].width,
                q.mipmaps[0].height,
                Ue,
                q.mipmaps[0].data
              )
            : O.texSubImage2D(O.TEXTURE_2D, V, R.x, R.y, Ue, Be, q.image),
          V === 0 && ie.generateMipmaps && O.generateMipmap(O.TEXTURE_2D),
          be.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (R, q, ie, V, ee = 0) {
        if (d.isWebGL1Renderer) {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
          );
          return;
        }
        const Ce = R.max.x - R.min.x + 1,
          Ue = R.max.y - R.min.y + 1,
          Be = R.max.z - R.min.z + 1,
          Ie = J.convert(V.format),
          De = J.convert(V.type);
        let ke;
        if (V.isData3DTexture) _e.setTexture3D(V, 0), (ke = O.TEXTURE_3D);
        else if (V.isDataArrayTexture)
          _e.setTexture2DArray(V, 0), (ke = O.TEXTURE_2D_ARRAY);
        else {
          console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
          );
          return;
        }
        O.pixelStorei(O.UNPACK_FLIP_Y_WEBGL, V.flipY),
          O.pixelStorei(O.UNPACK_PREMULTIPLY_ALPHA_WEBGL, V.premultiplyAlpha),
          O.pixelStorei(O.UNPACK_ALIGNMENT, V.unpackAlignment);
        const qe = O.getParameter(O.UNPACK_ROW_LENGTH),
          lt = O.getParameter(O.UNPACK_IMAGE_HEIGHT),
          Pt = O.getParameter(O.UNPACK_SKIP_PIXELS),
          wt = O.getParameter(O.UNPACK_SKIP_ROWS),
          Ln = O.getParameter(O.UNPACK_SKIP_IMAGES),
          xt = ie.isCompressedTexture ? ie.mipmaps[0] : ie.image;
        O.pixelStorei(O.UNPACK_ROW_LENGTH, xt.width),
          O.pixelStorei(O.UNPACK_IMAGE_HEIGHT, xt.height),
          O.pixelStorei(O.UNPACK_SKIP_PIXELS, R.min.x),
          O.pixelStorei(O.UNPACK_SKIP_ROWS, R.min.y),
          O.pixelStorei(O.UNPACK_SKIP_IMAGES, R.min.z),
          ie.isDataTexture || ie.isData3DTexture
            ? O.texSubImage3D(
                ke,
                ee,
                q.x,
                q.y,
                q.z,
                Ce,
                Ue,
                Be,
                Ie,
                De,
                xt.data
              )
            : ie.isCompressedArrayTexture
            ? (console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
              ),
              O.compressedTexSubImage3D(
                ke,
                ee,
                q.x,
                q.y,
                q.z,
                Ce,
                Ue,
                Be,
                Ie,
                xt.data
              ))
            : O.texSubImage3D(ke, ee, q.x, q.y, q.z, Ce, Ue, Be, Ie, De, xt),
          O.pixelStorei(O.UNPACK_ROW_LENGTH, qe),
          O.pixelStorei(O.UNPACK_IMAGE_HEIGHT, lt),
          O.pixelStorei(O.UNPACK_SKIP_PIXELS, Pt),
          O.pixelStorei(O.UNPACK_SKIP_ROWS, wt),
          O.pixelStorei(O.UNPACK_SKIP_IMAGES, Ln),
          ee === 0 && V.generateMipmaps && O.generateMipmap(ke),
          be.unbindTexture();
      }),
      (this.initTexture = function (R) {
        R.isCubeTexture
          ? _e.setTextureCube(R, 0)
          : R.isData3DTexture
          ? _e.setTexture3D(R, 0)
          : R.isDataArrayTexture || R.isCompressedArrayTexture
          ? _e.setTexture2DArray(R, 0)
          : _e.setTexture2D(R, 0),
          be.unbindTexture();
      }),
      (this.resetState = function () {
        (v = 0), (S = 0), (E = null), be.reset(), ge.reset();
      }),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get physicallyCorrectLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
      ),
      !this.useLegacyLights
    );
  }
  set physicallyCorrectLights(e) {
    console.warn(
      "THREE.WebGLRenderer: the property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
    ),
      (this.useLegacyLights = !e);
  }
  get outputEncoding() {
    return (
      console.warn(
        "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
      ),
      this.outputColorSpace === Ve ? fs : H_
    );
  }
  set outputEncoding(e) {
    console.warn(
      "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
    ),
      (this.outputColorSpace = e === fs ? Ve : Ii);
  }
}
class Yb extends og {}
Yb.prototype.isWebGL1Renderer = !0;
class qb extends Tt {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.overrideMaterial = null),
      typeof __THREE_DEVTOOLS__ < "u" &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      e.background !== null && (this.background = e.background.clone()),
      e.environment !== null && (this.environment = e.environment.clone()),
      e.fog !== null && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      e.overrideMaterial !== null &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      this.fog !== null && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      this.backgroundIntensity !== 1 &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      t
    );
  }
  get autoUpdate() {
    return (
      console.warn(
        "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."
      ),
      this.matrixWorldAutoUpdate
    );
  }
  set autoUpdate(e) {
    console.warn(
      "THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144."
    ),
      (this.matrixWorldAutoUpdate = e);
  }
}
class jb {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = e !== void 0 ? e.length / t : 0),
      (this.usage = Ih),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0),
      (this.uuid = gi());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    e === !0 && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, n) {
    (e *= this.stride), (n *= t.stride);
    for (let i = 0, s = this.stride; i < s; i++)
      this.array[e + i] = t.array[n + i];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = gi()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      n = new this.constructor(t, this.stride);
    return n.setUsage(this.usage), n;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
      this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = gi()),
      e.arrayBuffers[this.array.buffer._uuid] === void 0 &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const cn = new H();
class Df {
  constructor(e, t, n, i = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = n),
      (this.normalized = i);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, n = this.data.count; t < n; t++)
      cn.fromBufferAttribute(this, t),
        cn.applyMatrix4(e),
        this.setXYZ(t, cn.x, cn.y, cn.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, n = this.count; t < n; t++)
      cn.fromBufferAttribute(this, t),
        cn.applyNormalMatrix(e),
        this.setXYZ(t, cn.x, cn.y, cn.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, n = this.count; t < n; t++)
      cn.fromBufferAttribute(this, t),
        cn.transformDirection(e),
        this.setXYZ(t, cn.x, cn.y, cn.z);
    return this;
  }
  setX(e, t) {
    return (
      this.normalized && (t = dt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = dt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = dt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = dt(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Qi(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Qi(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Qi(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Qi(t, this.array)), t;
  }
  setXY(e, t, n) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = dt(t, this.array)), (n = dt(n, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      this
    );
  }
  setXYZ(e, t, n, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = dt(t, this.array)),
        (n = dt(n, this.array)),
        (i = dt(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = i),
      this
    );
  }
  setXYZW(e, t, n, i, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = dt(t, this.array)),
        (n = dt(n, this.array)),
        (i = dt(i, this.array)),
        (s = dt(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = n),
      (this.data.array[e + 2] = i),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[i + s]);
      }
      return new xn(
        new this.array.constructor(t),
        this.itemSize,
        this.normalized
      );
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
        new Df(
          e.interleavedBuffers[this.data.uuid],
          this.itemSize,
          this.offset,
          this.normalized
        )
      );
  }
  toJSON(e) {
    if (e === void 0) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const t = [];
      for (let n = 0; n < this.count; n++) {
        const i = n * this.data.stride + this.offset;
        for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[i + s]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: t,
        normalized: this.normalized,
      };
    } else
      return (
        e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
        e.interleavedBuffers[this.data.uuid] === void 0 &&
          (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
        {
          isInterleavedBufferAttribute: !0,
          itemSize: this.itemSize,
          data: this.data.uuid,
          offset: this.offset,
          normalized: this.normalized,
        }
      );
  }
}
const $p = new H(),
  Zp = new mt(),
  Jp = new mt(),
  Kb = new H(),
  Qp = new et(),
  na = new H();
class $b extends Vn {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = "attached"),
      (this.bindMatrix = new et()),
      (this.bindMatrixInverse = new et()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    this.boundingBox === null && (this.boundingBox = new hr()),
      this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      na.fromBufferAttribute(t, n),
        this.applyBoneTransform(n, na),
        this.boundingBox.expandByPoint(na);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    this.boundingSphere === null && (this.boundingSphere = new fr()),
      this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let n = 0; n < t.count; n++)
      na.fromBufferAttribute(t, n),
        this.applyBoneTransform(n, na),
        this.boundingSphere.expandByPoint(na);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      this
    );
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    (this.skeleton = e),
      t === void 0 &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new mt(),
      t = this.geometry.attributes.skinWeight;
    for (let n = 0, i = t.count; n < i; n++) {
      e.fromBufferAttribute(t, n);
      const s = 1 / e.manhattanLength();
      s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0),
        t.setXYZW(n, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.bindMode === "attached"
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : this.bindMode === "detached"
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, t) {
    const n = this.skeleton,
      i = this.geometry;
    Zp.fromBufferAttribute(i.attributes.skinIndex, e),
      Jp.fromBufferAttribute(i.attributes.skinWeight, e),
      $p.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const a = Jp.getComponent(s);
      if (a !== 0) {
        const o = Zp.getComponent(s);
        Qp.multiplyMatrices(n.bones[o].matrixWorld, n.boneInverses[o]),
          t.addScaledVector(Kb.copy($p).applyMatrix4(Qp), a);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e, t) {
    return (
      console.warn(
        "THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."
      ),
      this.applyBoneTransform(e, t)
    );
  }
}
class lg extends Tt {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class Zb extends Qt {
  constructor(e = null, t = 1, n = 1, i, s, a, o, l, c = qt, u = qt, h, f) {
    super(null, a, o, l, c, u, i, s, h, f),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: n }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const em = new et(),
  Jb = new et();
class If {
  constructor(e = [], t = []) {
    (this.uuid = gi()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      (this.boneTextureSize = 0),
      (this.frame = -1),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(e.length * 16)), t.length === 0))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let n = 0, i = this.bones.length; n < i; n++)
        this.boneInverses.push(new et());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = new et();
      this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(n);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n && n.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const n = this.bones[e];
      n &&
        (n.parent && n.parent.isBone
          ? (n.matrix.copy(n.parent.matrixWorld).invert(),
            n.matrix.multiply(n.matrixWorld))
          : n.matrix.copy(n.matrixWorld),
        n.matrix.decompose(n.position, n.quaternion, n.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      n = this.boneMatrices,
      i = this.boneTexture;
    for (let s = 0, a = e.length; s < a; s++) {
      const o = e[s] ? e[s].matrixWorld : Jb;
      em.multiplyMatrices(o, t[s]), em.toArray(n, s * 16);
    }
    i !== null && (i.needsUpdate = !0);
  }
  clone() {
    return new If(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(this.bones.length * 4);
    (e = W_(e)), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const n = new Zb(t, e, e, Qn, Er);
    return (
      (n.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = n),
      (this.boneTextureSize = e),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, n = this.bones.length; t < n; t++) {
      const i = this.bones[t];
      if (i.name === e) return i;
    }
  }
  dispose() {
    this.boneTexture !== null &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let n = 0, i = e.bones.length; n < i; n++) {
      const s = e.bones[n];
      let a = t[s];
      a === void 0 &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", s),
        (a = new lg())),
        this.bones.push(a),
        this.boneInverses.push(new et().fromArray(e.boneInverses[n]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.5,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      n = this.boneInverses;
    for (let i = 0, s = t.length; i < s; i++) {
      const a = t[i];
      e.bones.push(a.uuid);
      const o = n[i];
      e.boneInverses.push(o.toArray());
    }
    return e;
  }
}
class tm extends xn {
  constructor(e, t, n, i = 1) {
    super(e, t, n),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const ia = new et(),
  nm = new et(),
  ql = [],
  im = new hr(),
  Qb = new et(),
  ao = new Vn(),
  oo = new fr();
class eT extends Vn {
  constructor(e, t, n) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new tm(new Float32Array(n * 16), 16)),
      (this.instanceColor = null),
      (this.count = n),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let i = 0; i < n; i++) this.setMatrixAt(i, Qb);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    this.boundingBox === null && (this.boundingBox = new hr()),
      e.boundingBox === null && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, ia),
        im.copy(e.boundingBox).applyMatrix4(ia),
        this.boundingBox.union(im);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    this.boundingSphere === null && (this.boundingSphere = new fr()),
      e.boundingSphere === null && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let n = 0; n < t; n++)
      this.getMatrixAt(n, ia),
        oo.copy(e.boundingSphere).applyMatrix4(ia),
        this.boundingSphere.union(oo);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      e.instanceColor !== null &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, e * 3);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, e * 16);
  }
  raycast(e, t) {
    const n = this.matrixWorld,
      i = this.count;
    if (
      ((ao.geometry = this.geometry),
      (ao.material = this.material),
      ao.material !== void 0 &&
        (this.boundingSphere === null && this.computeBoundingSphere(),
        oo.copy(this.boundingSphere),
        oo.applyMatrix4(n),
        e.ray.intersectsSphere(oo) !== !1))
    )
      for (let s = 0; s < i; s++) {
        this.getMatrixAt(s, ia),
          nm.multiplyMatrices(n, ia),
          (ao.matrixWorld = nm),
          ao.raycast(e, ql);
        for (let a = 0, o = ql.length; a < o; a++) {
          const l = ql[a];
          (l.instanceId = s), (l.object = this), t.push(l);
        }
        ql.length = 0;
      }
  }
  setColorAt(e, t) {
    this.instanceColor === null &&
      (this.instanceColor = new tm(
        new Float32Array(this.instanceMatrix.count * 3),
        3
      )),
      t.toArray(this.instanceColor.array, e * 3);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, e * 16);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class cg extends Pi {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new Ke(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const rm = new H(),
  sm = new H(),
  am = new et(),
  nh = new au(),
  jl = new fr();
class Nf extends Tt {
  constructor(e = new xi(), t = new cg()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        n = [0];
      for (let i = 1, s = t.count; i < s; i++)
        rm.fromBufferAttribute(t, i - 1),
          sm.fromBufferAttribute(t, i),
          (n[i] = n[i - 1]),
          (n[i] += rm.distanceTo(sm));
      e.setAttribute("lineDistance", new rn(n, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.matrixWorld,
      s = e.params.Line.threshold,
      a = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      jl.copy(n.boundingSphere),
      jl.applyMatrix4(i),
      (jl.radius += s),
      e.ray.intersectsSphere(jl) === !1)
    )
      return;
    am.copy(i).invert(), nh.copy(e.ray).applyMatrix4(am);
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = o * o,
      c = new H(),
      u = new H(),
      h = new H(),
      f = new H(),
      p = this.isLineSegments ? 2 : 1,
      g = n.index,
      _ = n.attributes.position;
    if (g !== null) {
      const d = Math.max(0, a.start),
        y = Math.min(g.count, a.start + a.count);
      for (let v = d, S = y - 1; v < S; v += p) {
        const E = g.getX(v),
          b = g.getX(v + 1);
        if (
          (c.fromBufferAttribute(_, E),
          u.fromBufferAttribute(_, b),
          nh.distanceSqToSegment(c, u, f, h) > l)
        )
          continue;
        f.applyMatrix4(this.matrixWorld);
        const C = e.ray.origin.distanceTo(f);
        C < e.near ||
          C > e.far ||
          t.push({
            distance: C,
            point: h.clone().applyMatrix4(this.matrixWorld),
            index: v,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    } else {
      const d = Math.max(0, a.start),
        y = Math.min(_.count, a.start + a.count);
      for (let v = d, S = y - 1; v < S; v += p) {
        if (
          (c.fromBufferAttribute(_, v),
          u.fromBufferAttribute(_, v + 1),
          nh.distanceSqToSegment(c, u, f, h) > l)
        )
          continue;
        f.applyMatrix4(this.matrixWorld);
        const b = e.ray.origin.distanceTo(f);
        b < e.near ||
          b > e.far ||
          t.push({
            distance: b,
            point: h.clone().applyMatrix4(this.matrixWorld),
            index: v,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, a = i.length; s < a; s++) {
          const o = i[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = s);
        }
      }
    }
  }
}
const om = new H(),
  lm = new H();
class tT extends Nf {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (e.index === null) {
      const t = e.attributes.position,
        n = [];
      for (let i = 0, s = t.count; i < s; i += 2)
        om.fromBufferAttribute(t, i),
          lm.fromBufferAttribute(t, i + 1),
          (n[i] = i === 0 ? 0 : n[i - 1]),
          (n[i + 1] = n[i] + om.distanceTo(lm));
      e.setAttribute("lineDistance", new rn(n, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class nT extends Nf {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class ug extends Pi {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new Ke(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const cm = new et(),
  Fh = new au(),
  Kl = new fr(),
  $l = new H();
class hg extends Tt {
  constructor(e = new xi(), t = new ug()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const n = this.geometry,
      i = this.matrixWorld,
      s = e.params.Points.threshold,
      a = n.drawRange;
    if (
      (n.boundingSphere === null && n.computeBoundingSphere(),
      Kl.copy(n.boundingSphere),
      Kl.applyMatrix4(i),
      (Kl.radius += s),
      e.ray.intersectsSphere(Kl) === !1)
    )
      return;
    cm.copy(i).invert(), Fh.copy(e.ray).applyMatrix4(cm);
    const o = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = o * o,
      c = n.index,
      h = n.attributes.position;
    if (c !== null) {
      const f = Math.max(0, a.start),
        p = Math.min(c.count, a.start + a.count);
      for (let g = f, m = p; g < m; g++) {
        const _ = c.getX(g);
        $l.fromBufferAttribute(h, _), um($l, _, l, i, e, t, this);
      }
    } else {
      const f = Math.max(0, a.start),
        p = Math.min(h.count, a.start + a.count);
      for (let g = f, m = p; g < m; g++)
        $l.fromBufferAttribute(h, g), um($l, g, l, i, e, t, this);
    }
  }
  updateMorphTargets() {
    const t = this.geometry.morphAttributes,
      n = Object.keys(t);
    if (n.length > 0) {
      const i = t[n[0]];
      if (i !== void 0) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let s = 0, a = i.length; s < a; s++) {
          const o = i[s].name || String(s);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[o] = s);
        }
      }
    }
  }
}
function um(r, e, t, n, i, s, a) {
  const o = Fh.distanceSqToPoint(r);
  if (o < t) {
    const l = new H();
    Fh.closestPointToPoint(r, l), l.applyMatrix4(n);
    const c = i.ray.origin.distanceTo(l);
    if (c < i.near || c > i.far) return;
    s.push({
      distance: c,
      distanceToRay: Math.sqrt(o),
      point: l,
      index: e,
      face: null,
      object: a,
    });
  }
}
class Of extends Pi {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new Ke(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Ke(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = V_),
      (this.normalScale = new We(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class Is extends Of {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new We(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return $t((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (t) {
          this.ior = (1 + 0.4 * t) / (1 - 0.4 * t);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new Ke(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new Ke(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new Ke(1, 1, 1)),
      (this.specularColorMap = null),
      (this._sheen = 0),
      (this._clearcoat = 0),
      (this._iridescence = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
function gr(r, e, t) {
  return fg(r)
    ? new r.constructor(r.subarray(e, t !== void 0 ? t : r.length))
    : r.slice(e, t);
}
function Zl(r, e, t) {
  return !r || (!t && r.constructor === e)
    ? r
    : typeof e.BYTES_PER_ELEMENT == "number"
    ? new e(r)
    : Array.prototype.slice.call(r);
}
function fg(r) {
  return ArrayBuffer.isView(r) && !(r instanceof DataView);
}
function iT(r) {
  function e(i, s) {
    return r[i] - r[s];
  }
  const t = r.length,
    n = new Array(t);
  for (let i = 0; i !== t; ++i) n[i] = i;
  return n.sort(e), n;
}
function hm(r, e, t) {
  const n = r.length,
    i = new r.constructor(n);
  for (let s = 0, a = 0; a !== n; ++s) {
    const o = t[s] * e;
    for (let l = 0; l !== e; ++l) i[a++] = r[o + l];
  }
  return i;
}
function dg(r, e, t, n) {
  let i = 1,
    s = r[0];
  for (; s !== void 0 && s[n] === void 0; ) s = r[i++];
  if (s === void 0) return;
  let a = s[n];
  if (a !== void 0)
    if (Array.isArray(a))
      do
        (a = s[n]),
          a !== void 0 && (e.push(s.time), t.push.apply(t, a)),
          (s = r[i++]);
      while (s !== void 0);
    else if (a.toArray !== void 0)
      do
        (a = s[n]),
          a !== void 0 && (e.push(s.time), a.toArray(t, t.length)),
          (s = r[i++]);
      while (s !== void 0);
    else
      do (a = s[n]), a !== void 0 && (e.push(s.time), t.push(a)), (s = r[i++]);
      while (s !== void 0);
}
class dl {
  constructor(e, t, n, i) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = i !== void 0 ? i : new t.constructor(n)),
      (this.sampleValues = t),
      (this.valueSize = n),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let n = this._cachedIndex,
      i = t[n],
      s = t[n - 1];
    n: {
      e: {
        let a;
        t: {
          i: if (!(e < i)) {
            for (let o = n + 2; ; ) {
              if (i === void 0) {
                if (e < s) break i;
                return (
                  (n = t.length),
                  (this._cachedIndex = n),
                  this.copySampleValue_(n - 1)
                );
              }
              if (n === o) break;
              if (((s = i), (i = t[++n]), e < i)) break e;
            }
            a = t.length;
            break t;
          }
          if (!(e >= s)) {
            const o = t[1];
            e < o && ((n = 2), (s = o));
            for (let l = n - 2; ; ) {
              if (s === void 0)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (n === l) break;
              if (((i = s), (s = t[--n - 1]), e >= s)) break e;
            }
            (a = n), (n = 0);
            break t;
          }
          break n;
        }
        for (; n < a; ) {
          const o = (n + a) >>> 1;
          e < t[o] ? (a = o) : (n = o + 1);
        }
        if (((i = t[n]), (s = t[n - 1]), s === void 0))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (i === void 0)
          return (
            (n = t.length),
            (this._cachedIndex = n),
            this.copySampleValue_(n - 1)
          );
      }
      (this._cachedIndex = n), this.intervalChanged_(n, s, i);
    }
    return this.interpolate_(n, s, e, i);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      s = e * i;
    for (let a = 0; a !== i; ++a) t[a] = n[s + a];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class rT extends dl {
  constructor(e, t, n, i) {
    super(e, t, n, i),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: lp, endingEnd: lp });
  }
  intervalChanged_(e, t, n) {
    const i = this.parameterPositions;
    let s = e - 2,
      a = e + 1,
      o = i[s],
      l = i[a];
    if (o === void 0)
      switch (this.getSettings_().endingStart) {
        case cp:
          (s = e), (o = 2 * t - n);
          break;
        case up:
          (s = i.length - 2), (o = t + i[s] - i[s + 1]);
          break;
        default:
          (s = e), (o = n);
      }
    if (l === void 0)
      switch (this.getSettings_().endingEnd) {
        case cp:
          (a = e), (l = 2 * n - t);
          break;
        case up:
          (a = 1), (l = n + i[1] - i[0]);
          break;
        default:
          (a = e - 1), (l = t);
      }
    const c = (n - t) * 0.5,
      u = this.valueSize;
    (this._weightPrev = c / (t - o)),
      (this._weightNext = c / (l - n)),
      (this._offsetPrev = s * u),
      (this._offsetNext = a * u);
  }
  interpolate_(e, t, n, i) {
    const s = this.resultBuffer,
      a = this.sampleValues,
      o = this.valueSize,
      l = e * o,
      c = l - o,
      u = this._offsetPrev,
      h = this._offsetNext,
      f = this._weightPrev,
      p = this._weightNext,
      g = (n - t) / (i - t),
      m = g * g,
      _ = m * g,
      d = -f * _ + 2 * f * m - f * g,
      y = (1 + f) * _ + (-1.5 - 2 * f) * m + (-0.5 + f) * g + 1,
      v = (-1 - p) * _ + (1.5 + p) * m + 0.5 * g,
      S = p * _ - p * m;
    for (let E = 0; E !== o; ++E)
      s[E] = d * a[u + E] + y * a[c + E] + v * a[l + E] + S * a[h + E];
    return s;
  }
}
class sT extends dl {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const s = this.resultBuffer,
      a = this.sampleValues,
      o = this.valueSize,
      l = e * o,
      c = l - o,
      u = (n - t) / (i - t),
      h = 1 - u;
    for (let f = 0; f !== o; ++f) s[f] = a[c + f] * h + a[l + f] * u;
    return s;
  }
}
class aT extends dl {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class ki {
  constructor(e, t, n, i) {
    if (e === void 0)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (t === void 0 || t.length === 0)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = Zl(t, this.TimeBufferType)),
      (this.values = Zl(n, this.ValueBufferType)),
      this.setInterpolation(i || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let n;
    if (t.toJSON !== this.toJSON) n = t.toJSON(e);
    else {
      n = {
        name: e.name,
        times: Zl(e.times, Array),
        values: Zl(e.values, Array),
      };
      const i = e.getInterpolation();
      i !== e.DefaultInterpolation && (n.interpolation = i);
    }
    return (n.type = e.ValueTypeName), n;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new aT(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new sT(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new rT(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case Go:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case Fa:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case Iu:
        t = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (t === void 0) {
      const n =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (this.createInterpolant === void 0)
        if (e !== this.DefaultInterpolation)
          this.setInterpolation(this.DefaultInterpolation);
        else throw new Error(n);
      return console.warn("THREE.KeyframeTrack:", n), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return Go;
      case this.InterpolantFactoryMethodLinear:
        return Fa;
      case this.InterpolantFactoryMethodSmooth:
        return Iu;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (e !== 0) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
    }
    return this;
  }
  scale(e) {
    if (e !== 1) {
      const t = this.times;
      for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
    }
    return this;
  }
  trim(e, t) {
    const n = this.times,
      i = n.length;
    let s = 0,
      a = i - 1;
    for (; s !== i && n[s] < e; ) ++s;
    for (; a !== -1 && n[a] > t; ) --a;
    if ((++a, s !== 0 || a !== i)) {
      s >= a && ((a = Math.max(a, 1)), (s = a - 1));
      const o = this.getValueSize();
      (this.times = gr(n, s, a)), (this.values = gr(this.values, s * o, a * o));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) !== 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const n = this.times,
      i = this.values,
      s = n.length;
    s === 0 &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let a = null;
    for (let o = 0; o !== s; o++) {
      const l = n[o];
      if (typeof l == "number" && isNaN(l)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          o,
          l
        ),
          (e = !1);
        break;
      }
      if (a !== null && a > l) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, o, l, a),
          (e = !1);
        break;
      }
      a = l;
    }
    if (i !== void 0 && fg(i))
      for (let o = 0, l = i.length; o !== l; ++o) {
        const c = i[o];
        if (isNaN(c)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            o,
            c
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = gr(this.times),
      t = gr(this.values),
      n = this.getValueSize(),
      i = this.getInterpolation() === Iu,
      s = e.length - 1;
    let a = 1;
    for (let o = 1; o < s; ++o) {
      let l = !1;
      const c = e[o],
        u = e[o + 1];
      if (c !== u && (o !== 1 || c !== e[0]))
        if (i) l = !0;
        else {
          const h = o * n,
            f = h - n,
            p = h + n;
          for (let g = 0; g !== n; ++g) {
            const m = t[h + g];
            if (m !== t[f + g] || m !== t[p + g]) {
              l = !0;
              break;
            }
          }
        }
      if (l) {
        if (o !== a) {
          e[a] = e[o];
          const h = o * n,
            f = a * n;
          for (let p = 0; p !== n; ++p) t[f + p] = t[h + p];
        }
        ++a;
      }
    }
    if (s > 0) {
      e[a] = e[s];
      for (let o = s * n, l = a * n, c = 0; c !== n; ++c) t[l + c] = t[o + c];
      ++a;
    }
    return (
      a !== e.length
        ? ((this.times = gr(e, 0, a)), (this.values = gr(t, 0, a * n)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = gr(this.times, 0),
      t = gr(this.values, 0),
      n = this.constructor,
      i = new n(this.name, e, t);
    return (i.createInterpolant = this.createInterpolant), i;
  }
}
ki.prototype.TimeBufferType = Float32Array;
ki.prototype.ValueBufferType = Float32Array;
ki.prototype.DefaultInterpolation = Fa;
class $a extends ki {}
$a.prototype.ValueTypeName = "bool";
$a.prototype.ValueBufferType = Array;
$a.prototype.DefaultInterpolation = Go;
$a.prototype.InterpolantFactoryMethodLinear = void 0;
$a.prototype.InterpolantFactoryMethodSmooth = void 0;
class pg extends ki {}
pg.prototype.ValueTypeName = "color";
class Xo extends ki {}
Xo.prototype.ValueTypeName = "number";
class oT extends dl {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  interpolate_(e, t, n, i) {
    const s = this.resultBuffer,
      a = this.sampleValues,
      o = this.valueSize,
      l = (n - t) / (i - t);
    let c = e * o;
    for (let u = c + o; c !== u; c += 4) Ni.slerpFlat(s, 0, a, c - o, a, c, l);
    return s;
  }
}
class Ts extends ki {
  InterpolantFactoryMethodLinear(e) {
    return new oT(this.times, this.values, this.getValueSize(), e);
  }
}
Ts.prototype.ValueTypeName = "quaternion";
Ts.prototype.DefaultInterpolation = Fa;
Ts.prototype.InterpolantFactoryMethodSmooth = void 0;
class Za extends ki {}
Za.prototype.ValueTypeName = "string";
Za.prototype.ValueBufferType = Array;
Za.prototype.DefaultInterpolation = Go;
Za.prototype.InterpolantFactoryMethodLinear = void 0;
Za.prototype.InterpolantFactoryMethodSmooth = void 0;
class Yo extends ki {}
Yo.prototype.ValueTypeName = "vector";
class lT {
  constructor(e, t = -1, n, i = Ax) {
    (this.name = e),
      (this.tracks = n),
      (this.duration = t),
      (this.blendMode = i),
      (this.uuid = gi()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      n = e.tracks,
      i = 1 / (e.fps || 1);
    for (let a = 0, o = n.length; a !== o; ++a) t.push(uT(n[a]).scale(i));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return (s.uuid = e.uuid), s;
  }
  static toJSON(e) {
    const t = [],
      n = e.tracks,
      i = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let s = 0, a = n.length; s !== a; ++s) t.push(ki.toJSON(n[s]));
    return i;
  }
  static CreateFromMorphTargetSequence(e, t, n, i) {
    const s = t.length,
      a = [];
    for (let o = 0; o < s; o++) {
      let l = [],
        c = [];
      l.push((o + s - 1) % s, o, (o + 1) % s), c.push(0, 1, 0);
      const u = iT(l);
      (l = hm(l, 1, u)),
        (c = hm(c, 1, u)),
        !i && l[0] === 0 && (l.push(s), c.push(c[0])),
        a.push(
          new Xo(".morphTargetInfluences[" + t[o].name + "]", l, c).scale(1 / n)
        );
    }
    return new this(e, -1, a);
  }
  static findByName(e, t) {
    let n = e;
    if (!Array.isArray(e)) {
      const i = e;
      n = (i.geometry && i.geometry.animations) || i.animations;
    }
    for (let i = 0; i < n.length; i++) if (n[i].name === t) return n[i];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, n) {
    const i = {},
      s = /^([\w-]*?)([\d]+)$/;
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o],
        u = c.name.match(s);
      if (u && u.length > 1) {
        const h = u[1];
        let f = i[h];
        f || (i[h] = f = []), f.push(c);
      }
    }
    const a = [];
    for (const o in i)
      a.push(this.CreateFromMorphTargetSequence(o, i[o], t, n));
    return a;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const n = function (h, f, p, g, m) {
        if (p.length !== 0) {
          const _ = [],
            d = [];
          dg(p, _, d, g), _.length !== 0 && m.push(new h(f, _, d));
        }
      },
      i = [],
      s = e.name || "default",
      a = e.fps || 30,
      o = e.blendMode;
    let l = e.length || -1;
    const c = e.hierarchy || [];
    for (let h = 0; h < c.length; h++) {
      const f = c[h].keys;
      if (!(!f || f.length === 0))
        if (f[0].morphTargets) {
          const p = {};
          let g;
          for (g = 0; g < f.length; g++)
            if (f[g].morphTargets)
              for (let m = 0; m < f[g].morphTargets.length; m++)
                p[f[g].morphTargets[m]] = -1;
          for (const m in p) {
            const _ = [],
              d = [];
            for (let y = 0; y !== f[g].morphTargets.length; ++y) {
              const v = f[g];
              _.push(v.time), d.push(v.morphTarget === m ? 1 : 0);
            }
            i.push(new Xo(".morphTargetInfluence[" + m + "]", _, d));
          }
          l = p.length * a;
        } else {
          const p = ".bones[" + t[h].name + "]";
          n(Yo, p + ".position", f, "pos", i),
            n(Ts, p + ".quaternion", f, "rot", i),
            n(Yo, p + ".scale", f, "scl", i);
        }
    }
    return i.length === 0 ? null : new this(s, l, i, o);
  }
  resetDuration() {
    const e = this.tracks;
    let t = 0;
    for (let n = 0, i = e.length; n !== i; ++n) {
      const s = this.tracks[n];
      t = Math.max(t, s.times[s.times.length - 1]);
    }
    return (this.duration = t), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function cT(r) {
  switch (r.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return Xo;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return Yo;
    case "color":
      return pg;
    case "quaternion":
      return Ts;
    case "bool":
    case "boolean":
      return $a;
    case "string":
      return Za;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r);
}
function uT(r) {
  if (r.type === void 0)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const e = cT(r.type);
  if (r.times === void 0) {
    const t = [],
      n = [];
    dg(r.keys, t, n, "value"), (r.times = t), (r.values = n);
  }
  return e.parse !== void 0
    ? e.parse(r)
    : new e(r.name, r.times, r.values, r.interpolation);
}
const za = {
  enabled: !1,
  files: {},
  add: function (r, e) {
    this.enabled !== !1 && (this.files[r] = e);
  },
  get: function (r) {
    if (this.enabled !== !1) return this.files[r];
  },
  remove: function (r) {
    delete this.files[r];
  },
  clear: function () {
    this.files = {};
  },
};
class hT {
  constructor(e, t, n) {
    const i = this;
    let s = !1,
      a = 0,
      o = 0,
      l;
    const c = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = n),
      (this.itemStart = function (u) {
        o++, s === !1 && i.onStart !== void 0 && i.onStart(u, a, o), (s = !0);
      }),
      (this.itemEnd = function (u) {
        a++,
          i.onProgress !== void 0 && i.onProgress(u, a, o),
          a === o && ((s = !1), i.onLoad !== void 0 && i.onLoad());
      }),
      (this.itemError = function (u) {
        i.onError !== void 0 && i.onError(u);
      }),
      (this.resolveURL = function (u) {
        return l ? l(u) : u;
      }),
      (this.setURLModifier = function (u) {
        return (l = u), this;
      }),
      (this.addHandler = function (u, h) {
        return c.push(u, h), this;
      }),
      (this.removeHandler = function (u) {
        const h = c.indexOf(u);
        return h !== -1 && c.splice(h, 2), this;
      }),
      (this.getHandler = function (u) {
        for (let h = 0, f = c.length; h < f; h += 2) {
          const p = c[h],
            g = c[h + 1];
          if ((p.global && (p.lastIndex = 0), p.test(u))) return g;
        }
        return null;
      });
  }
}
const fT = new hT();
class pl {
  constructor(e) {
    (this.manager = e !== void 0 ? e : fT),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const n = this;
    return new Promise(function (i, s) {
      n.load(e, i, t, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
const qi = {};
class dT extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class mg extends pl {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = za.get(e);
    if (s !== void 0)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(s), this.manager.itemEnd(e);
        }, 0),
        s
      );
    if (qi[e] !== void 0) {
      qi[e].push({ onLoad: t, onProgress: n, onError: i });
      return;
    }
    (qi[e] = []), qi[e].push({ onLoad: t, onProgress: n, onError: i });
    const a = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      o = this.mimeType,
      l = this.responseType;
    fetch(a)
      .then((c) => {
        if (c.status === 200 || c.status === 0) {
          if (
            (c.status === 0 &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            typeof ReadableStream > "u" ||
              c.body === void 0 ||
              c.body.getReader === void 0)
          )
            return c;
          const u = qi[e],
            h = c.body.getReader(),
            f = c.headers.get("Content-Length") || c.headers.get("X-File-Size"),
            p = f ? parseInt(f) : 0,
            g = p !== 0;
          let m = 0;
          const _ = new ReadableStream({
            start(d) {
              y();
              function y() {
                h.read().then(({ done: v, value: S }) => {
                  if (v) d.close();
                  else {
                    m += S.byteLength;
                    const E = new ProgressEvent("progress", {
                      lengthComputable: g,
                      loaded: m,
                      total: p,
                    });
                    for (let b = 0, M = u.length; b < M; b++) {
                      const C = u[b];
                      C.onProgress && C.onProgress(E);
                    }
                    d.enqueue(S), y();
                  }
                });
              }
            },
          });
          return new Response(_);
        } else
          throw new dT(
            `fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,
            c
          );
      })
      .then((c) => {
        switch (l) {
          case "arraybuffer":
            return c.arrayBuffer();
          case "blob":
            return c.blob();
          case "document":
            return c.text().then((u) => new DOMParser().parseFromString(u, o));
          case "json":
            return c.json();
          default:
            if (o === void 0) return c.text();
            {
              const h = /charset="?([^;"\s]*)"?/i.exec(o),
                f = h && h[1] ? h[1].toLowerCase() : void 0,
                p = new TextDecoder(f);
              return c.arrayBuffer().then((g) => p.decode(g));
            }
        }
      })
      .then((c) => {
        za.add(e, c);
        const u = qi[e];
        delete qi[e];
        for (let h = 0, f = u.length; h < f; h++) {
          const p = u[h];
          p.onLoad && p.onLoad(c);
        }
      })
      .catch((c) => {
        const u = qi[e];
        if (u === void 0) throw (this.manager.itemError(e), c);
        delete qi[e];
        for (let h = 0, f = u.length; h < f; h++) {
          const p = u[h];
          p.onError && p.onError(c);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class pT extends pl {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      a = za.get(e);
    if (a !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(a), s.manager.itemEnd(e);
        }, 0),
        a
      );
    const o = Wo("img");
    function l() {
      u(), za.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function c(h) {
      u(), i && i(h), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function u() {
      o.removeEventListener("load", l, !1),
        o.removeEventListener("error", c, !1);
    }
    return (
      o.addEventListener("load", l, !1),
      o.addEventListener("error", c, !1),
      e.slice(0, 5) !== "data:" &&
        this.crossOrigin !== void 0 &&
        (o.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (o.src = e),
      o
    );
  }
}
class _g extends pl {
  constructor(e) {
    super(e);
  }
  load(e, t, n, i) {
    const s = new Qt(),
      a = new pT(this.manager);
    return (
      a.setCrossOrigin(this.crossOrigin),
      a.setPath(this.path),
      a.load(
        e,
        function (o) {
          (s.image = o), (s.needsUpdate = !0), t !== void 0 && t(s);
        },
        n,
        i
      ),
      s
    );
  }
}
class Uf extends Tt {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new Ke(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      this.groundColor !== void 0 &&
        (t.object.groundColor = this.groundColor.getHex()),
      this.distance !== void 0 && (t.object.distance = this.distance),
      this.angle !== void 0 && (t.object.angle = this.angle),
      this.decay !== void 0 && (t.object.decay = this.decay),
      this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
      this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
      t
    );
  }
}
const ih = new et(),
  fm = new H(),
  dm = new H();
class Ff {
  constructor(e) {
    (this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new We(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new et()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Cf()),
      (this._frameExtents = new We(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new mt(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      n = this.matrix;
    fm.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(fm),
      dm.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(dm),
      t.updateMatrixWorld(),
      ih.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(ih),
      n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      n.multiply(ih);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      this.bias !== 0 && (e.bias = this.bias),
      this.normalBias !== 0 && (e.normalBias = this.normalBias),
      this.radius !== 1 && (e.radius = this.radius),
      (this.mapSize.x !== 512 || this.mapSize.y !== 512) &&
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class mT extends Ff {
  constructor() {
    super(new mn(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      n = Ba * 2 * e.angle * this.focus,
      i = this.mapSize.width / this.mapSize.height,
      s = e.distance || t.far;
    (n !== t.fov || i !== t.aspect || s !== t.far) &&
      ((t.fov = n), (t.aspect = i), (t.far = s), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class _T extends Uf {
  constructor(e, t, n = 0, i = Math.PI / 3, s = 0, a = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(Tt.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Tt()),
      (this.distance = n),
      (this.angle = i),
      (this.penumbra = s),
      (this.decay = a),
      (this.map = null),
      (this.shadow = new mT());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const pm = new et(),
  lo = new H(),
  rh = new H();
class gT extends Ff {
  constructor() {
    super(new mn(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new We(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new mt(2, 1, 1, 1),
        new mt(0, 1, 1, 1),
        new mt(3, 1, 1, 1),
        new mt(1, 1, 1, 1),
        new mt(3, 0, 1, 1),
        new mt(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new H(1, 0, 0),
        new H(-1, 0, 0),
        new H(0, 0, 1),
        new H(0, 0, -1),
        new H(0, 1, 0),
        new H(0, -1, 0),
      ]),
      (this._cubeUps = [
        new H(0, 1, 0),
        new H(0, 1, 0),
        new H(0, 1, 0),
        new H(0, 1, 0),
        new H(0, 0, 1),
        new H(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const n = this.camera,
      i = this.matrix,
      s = e.distance || n.far;
    s !== n.far && ((n.far = s), n.updateProjectionMatrix()),
      lo.setFromMatrixPosition(e.matrixWorld),
      n.position.copy(lo),
      rh.copy(n.position),
      rh.add(this._cubeDirections[t]),
      n.up.copy(this._cubeUps[t]),
      n.lookAt(rh),
      n.updateMatrixWorld(),
      i.makeTranslation(-lo.x, -lo.y, -lo.z),
      pm.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(pm);
  }
}
class vT extends Uf {
  constructor(e, t, n = 0, i = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = n),
      (this.decay = i),
      (this.shadow = new gT());
  }
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class xT extends Ff {
  constructor() {
    super(new Pf(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class yT extends Uf {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Tt.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Tt()),
      (this.shadow = new xT());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class Bh {
  static decodeText(e) {
    if (typeof TextDecoder < "u") return new TextDecoder().decode(e);
    let t = "";
    for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
    try {
      return decodeURIComponent(escape(t));
    } catch {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return t === -1 ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return typeof e != "string" || e === ""
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class ET extends pl {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      typeof createImageBitmap > "u" &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      typeof fetch > "u" &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, n, i) {
    e === void 0 && (e = ""),
      this.path !== void 0 && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      a = za.get(e);
    if (a !== void 0)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(a), s.manager.itemEnd(e);
        }, 0),
        a
      );
    const o = {};
    (o.credentials =
      this.crossOrigin === "anonymous" ? "same-origin" : "include"),
      (o.headers = this.requestHeader),
      fetch(e, o)
        .then(function (l) {
          return l.blob();
        })
        .then(function (l) {
          return createImageBitmap(
            l,
            Object.assign(s.options, { colorSpaceConversion: "none" })
          );
        })
        .then(function (l) {
          za.add(e, l), t && t(l), s.manager.itemEnd(e);
        })
        .catch(function (l) {
          i && i(l), s.manager.itemError(e), s.manager.itemEnd(e);
        }),
      s.manager.itemStart(e);
  }
}
class ST {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = mm()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = mm();
      (e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function mm() {
  return (typeof performance > "u" ? Date : performance).now();
}
const Bf = "\\[\\]\\.:\\/",
  MT = new RegExp("[" + Bf + "]", "g"),
  kf = "[^" + Bf + "]",
  bT = "[^" + Bf.replace("\\.", "") + "]",
  TT = /((?:WC+[\/:])*)/.source.replace("WC", kf),
  AT = /(WCOD+)?/.source.replace("WCOD", bT),
  wT = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", kf),
  RT = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", kf),
  CT = new RegExp("^" + TT + AT + wT + RT + "$"),
  PT = ["material", "materials", "bones", "map"];
class LT {
  constructor(e, t, n) {
    const i = n || ut.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
  }
  getValue(e, t) {
    this.bind();
    const n = this._targetGroup.nCachedObjects_,
      i = this._bindings[n];
    i !== void 0 && i.getValue(e, t);
  }
  setValue(e, t) {
    const n = this._bindings;
    for (let i = this._targetGroup.nCachedObjects_, s = n.length; i !== s; ++i)
      n[i].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
      e[t].unbind();
  }
}
class ut {
  constructor(e, t, n) {
    (this.path = t),
      (this.parsedPath = n || ut.parseTrackName(t)),
      (this.node = ut.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, n) {
    return e && e.isAnimationObjectGroup
      ? new ut.Composite(e, t, n)
      : new ut(e, t, n);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(MT, "");
  }
  static parseTrackName(e) {
    const t = CT.exec(e);
    if (t === null)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const n = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      i = n.nodeName && n.nodeName.lastIndexOf(".");
    if (i !== void 0 && i !== -1) {
      const s = n.nodeName.substring(i + 1);
      PT.indexOf(s) !== -1 &&
        ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = s));
    }
    if (n.propertyName === null || n.propertyName.length === 0)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return n;
  }
  static findNode(e, t) {
    if (
      t === void 0 ||
      t === "" ||
      t === "." ||
      t === -1 ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const n = e.skeleton.getBoneByName(t);
      if (n !== void 0) return n;
    }
    if (e.children) {
      const n = function (s) {
          for (let a = 0; a < s.length; a++) {
            const o = s[a];
            if (o.name === t || o.uuid === t) return o;
            const l = n(o.children);
            if (l) return l;
          }
          return null;
        },
        i = n(e.children);
      if (i) return i;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, s = n.length; i !== s; ++i) e[t++] = n[i];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const n = this.resolvedProperty;
    for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      n = t.objectName,
      i = t.propertyName;
    let s = t.propertyIndex;
    if (
      (e || ((e = ut.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    ) {
      console.error(
        "THREE.PropertyBinding: Trying to update node for track: " +
          this.path +
          " but it wasn't found."
      );
      return;
    }
    if (n) {
      let c = t.objectIndex;
      switch (n) {
        case "materials":
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.materials) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
            return;
          }
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton) {
            console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
            return;
          }
          e = e.skeleton.bones;
          for (let u = 0; u < e.length; u++)
            if (e[u].name === c) {
              c = u;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
            return;
          }
          if (!e.material.map) {
            console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
            return;
          }
          e = e.material.map;
          break;
        default:
          if (e[n] === void 0) {
            console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
            return;
          }
          e = e[n];
      }
      if (c !== void 0) {
        if (e[c] === void 0) {
          console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
          return;
        }
        e = e[c];
      }
    }
    const a = e[i];
    if (a === void 0) {
      const c = t.nodeName;
      console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          c +
          "." +
          i +
          " but it wasn't found.",
        e
      );
      return;
    }
    let o = this.Versioning.None;
    (this.targetObject = e),
      e.needsUpdate !== void 0
        ? (o = this.Versioning.NeedsUpdate)
        : e.matrixWorldNeedsUpdate !== void 0 &&
          (o = this.Versioning.MatrixWorldNeedsUpdate);
    let l = this.BindingType.Direct;
    if (s !== void 0) {
      if (i === "morphTargetInfluences") {
        if (!e.geometry) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
          return;
        }
        if (!e.geometry.morphAttributes) {
          console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
          return;
        }
        e.morphTargetDictionary[s] !== void 0 &&
          (s = e.morphTargetDictionary[s]);
      }
      (l = this.BindingType.ArrayElement),
        (this.resolvedProperty = a),
        (this.propertyIndex = s);
    } else
      a.fromArray !== void 0 && a.toArray !== void 0
        ? ((l = this.BindingType.HasFromToArray), (this.resolvedProperty = a))
        : Array.isArray(a)
        ? ((l = this.BindingType.EntireArray), (this.resolvedProperty = a))
        : (this.propertyName = i);
    (this.getValue = this.GetterByBindingType[l]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[l][o]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
ut.Composite = LT;
ut.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
};
ut.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
};
ut.prototype.GetterByBindingType = [
  ut.prototype._getValue_direct,
  ut.prototype._getValue_array,
  ut.prototype._getValue_arrayElement,
  ut.prototype._getValue_toArray,
];
ut.prototype.SetterByBindingTypeAndVersioning = [
  [
    ut.prototype._setValue_direct,
    ut.prototype._setValue_direct_setNeedsUpdate,
    ut.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    ut.prototype._setValue_array,
    ut.prototype._setValue_array_setNeedsUpdate,
    ut.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    ut.prototype._setValue_arrayElement,
    ut.prototype._setValue_arrayElement_setNeedsUpdate,
    ut.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    ut.prototype._setValue_fromArray,
    ut.prototype._setValue_fromArray_setNeedsUpdate,
    ut.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
];
class DT {
  constructor(e, t, n = 0, i = 1 / 0) {
    (this.ray = new au(e, t)),
      (this.near = n),
      (this.far = i),
      (this.camera = null),
      (this.layers = new Rf()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
          .unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        (this.camera = t))
      : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, n = []) {
    return kh(e, this, n, t), n.sort(_m), n;
  }
  intersectObjects(e, t = !0, n = []) {
    for (let i = 0, s = e.length; i < s; i++) kh(e[i], this, n, t);
    return n.sort(_m), n;
  }
}
function _m(r, e) {
  return r.distance - e.distance;
}
function kh(r, e, t, n) {
  if ((r.layers.test(e.layers) && r.raycast(e, t), n === !0)) {
    const i = r.children;
    for (let s = 0, a = i.length; s < a; s++) kh(i[s], e, t, !0);
  }
}
class gm {
  constructor(e = 1, t = 0, n = 0) {
    return (this.radius = e), (this.phi = t), (this.theta = n), this;
  }
  set(e, t, n) {
    return (this.radius = e), (this.phi = t), (this.theta = n), this;
  }
  copy(e) {
    return (
      (this.radius = e.radius), (this.phi = e.phi), (this.theta = e.theta), this
    );
  }
  makeSafe() {
    return (
      (this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))), this
    );
  }
  setFromVector3(e) {
    return this.setFromCartesianCoords(e.x, e.y, e.z);
  }
  setFromCartesianCoords(e, t, n) {
    return (
      (this.radius = Math.sqrt(e * e + t * t + n * n)),
      this.radius === 0
        ? ((this.theta = 0), (this.phi = 0))
        : ((this.theta = Math.atan2(e, n)),
          (this.phi = Math.acos($t(t / this.radius, -1, 1)))),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
typeof __THREE_DEVTOOLS__ < "u" &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: Af } })
  );
typeof window < "u" &&
  (window.__THREE__
    ? console.warn("WARNING: Multiple instances of Three.js being imported.")
    : (window.__THREE__ = Af));
const ml = {
    maxPixelRatio: 2,
    sizes: {
      rendererWidth: window.innerWidth,
      rendererHeight: window.innerHeight,
      get width() {
        return this.rendererWidth;
      },
      set width(r) {
        this.rendererWidth = r;
      },
      get height() {
        return this.rendererHeight;
      },
      set height(r) {
        this.rendererHeight = r;
      },
    },
  },
  { width: IT, height: NT } = ml.sizes,
  ei = new mn(50, IT / NT, 1e-4, 5e3);
ei.position.setZ(700);
function OT(r, e) {
  (ei.aspect = r / e), ei.updateProjectionMatrix();
}
const { width: UT, height: FT } = ml.sizes,
  Oi = new og({ canvas: document.querySelector("canvas") });
Oi.setClearColor(16711935);
Oi.setClearAlpha(0);
Oi.setSize(UT, FT);
Oi.setPixelRatio(Math.min(window.devicePixelRatio, ml.maxPixelRatio));
function BT(r, e) {
  Oi.setSize(r, e),
    Oi.setPixelRatio(Math.min(window.devicePixelRatio, ml.maxPixelRatio));
}
function zh() {
  return document.body.clientWidth <= 768;
}
const _l = new qb(),
  vm = { type: "change" },
  sh = { type: "start" },
  xm = { type: "end" };
class kT extends Ds {
  constructor(e, t) {
    super(),
      (this.object = e),
      (this.domElement = t),
      (this.domElement.style.touchAction = "none"),
      (this.enabled = !0),
      (this.target = new H()),
      (this.minDistance = 0),
      (this.maxDistance = 1 / 0),
      (this.minZoom = 0),
      (this.maxZoom = 1 / 0),
      (this.minPolarAngle = 0),
      (this.maxPolarAngle = Math.PI),
      (this.minAzimuthAngle = -1 / 0),
      (this.maxAzimuthAngle = 1 / 0),
      (this.enableDamping = !1),
      (this.dampingFactor = 0.05),
      (this.enableZoom = !0),
      (this.zoomSpeed = 1),
      (this.enableRotate = !0),
      (this.rotateSpeed = 1),
      (this.enablePan = !0),
      (this.panSpeed = 1),
      (this.screenSpacePanning = !0),
      (this.keyPanSpeed = 7),
      (this.autoRotate = !1),
      (this.autoRotateSpeed = 2),
      (this.keys = {
        LEFT: "ArrowLeft",
        UP: "ArrowUp",
        RIGHT: "ArrowRight",
        BOTTOM: "ArrowDown",
      }),
      (this.mouseButtons = {
        LEFT: Bs.ROTATE,
        MIDDLE: Bs.DOLLY,
        RIGHT: Bs.PAN,
      }),
      (this.touches = { ONE: ks.ROTATE, TWO: ks.DOLLY_PAN }),
      (this.target0 = this.target.clone()),
      (this.position0 = this.object.position.clone()),
      (this.zoom0 = this.object.zoom),
      (this._domElementKeyEvents = null),
      (this.getPolarAngle = function () {
        return o.phi;
      }),
      (this.getAzimuthalAngle = function () {
        return o.theta;
      }),
      (this.getDistance = function () {
        return this.object.position.distanceTo(this.target);
      }),
      (this.listenToKeyEvents = function (U) {
        U.addEventListener("keydown", st), (this._domElementKeyEvents = U);
      }),
      (this.stopListenToKeyEvents = function () {
        this._domElementKeyEvents.removeEventListener("keydown", st),
          (this._domElementKeyEvents = null);
      }),
      (this.saveState = function () {
        n.target0.copy(n.target),
          n.position0.copy(n.object.position),
          (n.zoom0 = n.object.zoom);
      }),
      (this.reset = function () {
        n.target.copy(n.target0),
          n.object.position.copy(n.position0),
          (n.object.zoom = n.zoom0),
          n.object.updateProjectionMatrix(),
          n.dispatchEvent(vm),
          n.update(),
          (s = i.NONE);
      }),
      (this.update = (function () {
        const U = new H(),
          ne = new Ni().setFromUnitVectors(e.up, new H(0, 1, 0)),
          J = ne.clone().invert(),
          ge = new H(),
          Te = new Ni(),
          Le = 2 * Math.PI;
        return function () {
          const Ae = n.object.position;
          U.copy(Ae).sub(n.target),
            U.applyQuaternion(ne),
            o.setFromVector3(U),
            n.autoRotate && s === i.NONE && x(M()),
            n.enableDamping
              ? ((o.theta += l.theta * n.dampingFactor),
                (o.phi += l.phi * n.dampingFactor))
              : ((o.theta += l.theta), (o.phi += l.phi));
          let xe = n.minAzimuthAngle,
            ze = n.maxAzimuthAngle;
          return (
            isFinite(xe) &&
              isFinite(ze) &&
              (xe < -Math.PI ? (xe += Le) : xe > Math.PI && (xe -= Le),
              ze < -Math.PI ? (ze += Le) : ze > Math.PI && (ze -= Le),
              xe <= ze
                ? (o.theta = Math.max(xe, Math.min(ze, o.theta)))
                : (o.theta =
                    o.theta > (xe + ze) / 2
                      ? Math.max(xe, o.theta)
                      : Math.min(ze, o.theta))),
            (o.phi = Math.max(
              n.minPolarAngle,
              Math.min(n.maxPolarAngle, o.phi)
            )),
            o.makeSafe(),
            (o.radius *= c),
            (o.radius = Math.max(
              n.minDistance,
              Math.min(n.maxDistance, o.radius)
            )),
            n.enableDamping === !0
              ? n.target.addScaledVector(u, n.dampingFactor)
              : n.target.add(u),
            U.setFromSpherical(o),
            U.applyQuaternion(J),
            Ae.copy(n.target).add(U),
            n.object.lookAt(n.target),
            n.enableDamping === !0
              ? ((l.theta *= 1 - n.dampingFactor),
                (l.phi *= 1 - n.dampingFactor),
                u.multiplyScalar(1 - n.dampingFactor))
              : (l.set(0, 0, 0), u.set(0, 0, 0)),
            (c = 1),
            h ||
            ge.distanceToSquared(n.object.position) > a ||
            8 * (1 - Te.dot(n.object.quaternion)) > a
              ? (n.dispatchEvent(vm),
                ge.copy(n.object.position),
                Te.copy(n.object.quaternion),
                (h = !1),
                !0)
              : !1
          );
        };
      })()),
      (this.dispose = function () {
        n.domElement.removeEventListener("contextmenu", w),
          n.domElement.removeEventListener("pointerdown", _e),
          n.domElement.removeEventListener("pointercancel", $e),
          n.domElement.removeEventListener("wheel", Xe),
          n.domElement.removeEventListener("pointermove", K),
          n.domElement.removeEventListener("pointerup", $e),
          n._domElementKeyEvents !== null &&
            (n._domElementKeyEvents.removeEventListener("keydown", st),
            (n._domElementKeyEvents = null));
      });
    const n = this,
      i = {
        NONE: -1,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2,
        TOUCH_ROTATE: 3,
        TOUCH_PAN: 4,
        TOUCH_DOLLY_PAN: 5,
        TOUCH_DOLLY_ROTATE: 6,
      };
    let s = i.NONE;
    const a = 1e-6,
      o = new gm(),
      l = new gm();
    let c = 1;
    const u = new H();
    let h = !1;
    const f = new We(),
      p = new We(),
      g = new We(),
      m = new We(),
      _ = new We(),
      d = new We(),
      y = new We(),
      v = new We(),
      S = new We(),
      E = [],
      b = {};
    function M() {
      return ((2 * Math.PI) / 60 / 60) * n.autoRotateSpeed;
    }
    function C() {
      return Math.pow(0.95, n.zoomSpeed);
    }
    function x(U) {
      l.theta -= U;
    }
    function T(U) {
      l.phi -= U;
    }
    const D = (function () {
        const U = new H();
        return function (J, ge) {
          U.setFromMatrixColumn(ge, 0), U.multiplyScalar(-J), u.add(U);
        };
      })(),
      N = (function () {
        const U = new H();
        return function (J, ge) {
          n.screenSpacePanning === !0
            ? U.setFromMatrixColumn(ge, 1)
            : (U.setFromMatrixColumn(ge, 0), U.crossVectors(n.object.up, U)),
            U.multiplyScalar(J),
            u.add(U);
        };
      })(),
      L = (function () {
        const U = new H();
        return function (J, ge) {
          const Te = n.domElement;
          if (n.object.isPerspectiveCamera) {
            const Le = n.object.position;
            U.copy(Le).sub(n.target);
            let ye = U.length();
            (ye *= Math.tan(((n.object.fov / 2) * Math.PI) / 180)),
              D((2 * J * ye) / Te.clientHeight, n.object.matrix),
              N((2 * ge * ye) / Te.clientHeight, n.object.matrix);
          } else
            n.object.isOrthographicCamera
              ? (D(
                  (J * (n.object.right - n.object.left)) /
                    n.object.zoom /
                    Te.clientWidth,
                  n.object.matrix
                ),
                N(
                  (ge * (n.object.top - n.object.bottom)) /
                    n.object.zoom /
                    Te.clientHeight,
                  n.object.matrix
                ))
              : (console.warn(
                  "WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."
                ),
                (n.enablePan = !1));
        };
      })();
    function F(U) {
      n.object.isPerspectiveCamera
        ? (c /= U)
        : n.object.isOrthographicCamera
        ? ((n.object.zoom = Math.max(
            n.minZoom,
            Math.min(n.maxZoom, n.object.zoom * U)
          )),
          n.object.updateProjectionMatrix(),
          (h = !0))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (n.enableZoom = !1));
    }
    function I(U) {
      n.object.isPerspectiveCamera
        ? (c *= U)
        : n.object.isOrthographicCamera
        ? ((n.object.zoom = Math.max(
            n.minZoom,
            Math.min(n.maxZoom, n.object.zoom / U)
          )),
          n.object.updateProjectionMatrix(),
          (h = !0))
        : (console.warn(
            "WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."
          ),
          (n.enableZoom = !1));
    }
    function j(U) {
      f.set(U.clientX, U.clientY);
    }
    function A(U) {
      y.set(U.clientX, U.clientY);
    }
    function k(U) {
      m.set(U.clientX, U.clientY);
    }
    function G(U) {
      p.set(U.clientX, U.clientY),
        g.subVectors(p, f).multiplyScalar(n.rotateSpeed);
      const ne = n.domElement;
      x((2 * Math.PI * g.x) / ne.clientHeight),
        T((2 * Math.PI * g.y) / ne.clientHeight),
        f.copy(p),
        n.update();
    }
    function z(U) {
      v.set(U.clientX, U.clientY),
        S.subVectors(v, y),
        S.y > 0 ? F(C()) : S.y < 0 && I(C()),
        y.copy(v),
        n.update();
    }
    function oe(U) {
      _.set(U.clientX, U.clientY),
        d.subVectors(_, m).multiplyScalar(n.panSpeed),
        L(d.x, d.y),
        m.copy(_),
        n.update();
    }
    function te(U) {
      U.deltaY < 0 ? I(C()) : U.deltaY > 0 && F(C()), n.update();
    }
    function X(U) {
      let ne = !1;
      switch (U.code) {
        case n.keys.UP:
          U.ctrlKey || U.metaKey || U.shiftKey
            ? T((2 * Math.PI * n.rotateSpeed) / n.domElement.clientHeight)
            : L(0, n.keyPanSpeed),
            (ne = !0);
          break;
        case n.keys.BOTTOM:
          U.ctrlKey || U.metaKey || U.shiftKey
            ? T((-2 * Math.PI * n.rotateSpeed) / n.domElement.clientHeight)
            : L(0, -n.keyPanSpeed),
            (ne = !0);
          break;
        case n.keys.LEFT:
          U.ctrlKey || U.metaKey || U.shiftKey
            ? x((2 * Math.PI * n.rotateSpeed) / n.domElement.clientHeight)
            : L(n.keyPanSpeed, 0),
            (ne = !0);
          break;
        case n.keys.RIGHT:
          U.ctrlKey || U.metaKey || U.shiftKey
            ? x((-2 * Math.PI * n.rotateSpeed) / n.domElement.clientHeight)
            : L(-n.keyPanSpeed, 0),
            (ne = !0);
          break;
      }
      ne && (U.preventDefault(), n.update());
    }
    function Y() {
      if (E.length === 1) f.set(E[0].pageX, E[0].pageY);
      else {
        const U = 0.5 * (E[0].pageX + E[1].pageX),
          ne = 0.5 * (E[0].pageY + E[1].pageY);
        f.set(U, ne);
      }
    }
    function le() {
      if (E.length === 1) m.set(E[0].pageX, E[0].pageY);
      else {
        const U = 0.5 * (E[0].pageX + E[1].pageX),
          ne = 0.5 * (E[0].pageY + E[1].pageY);
        m.set(U, ne);
      }
    }
    function W() {
      const U = E[0].pageX - E[1].pageX,
        ne = E[0].pageY - E[1].pageY,
        J = Math.sqrt(U * U + ne * ne);
      y.set(0, J);
    }
    function O() {
      n.enableZoom && W(), n.enablePan && le();
    }
    function Me() {
      n.enableZoom && W(), n.enableRotate && Y();
    }
    function ve(U) {
      if (E.length == 1) p.set(U.pageX, U.pageY);
      else {
        const J = me(U),
          ge = 0.5 * (U.pageX + J.x),
          Te = 0.5 * (U.pageY + J.y);
        p.set(ge, Te);
      }
      g.subVectors(p, f).multiplyScalar(n.rotateSpeed);
      const ne = n.domElement;
      x((2 * Math.PI * g.x) / ne.clientHeight),
        T((2 * Math.PI * g.y) / ne.clientHeight),
        f.copy(p);
    }
    function re(U) {
      if (E.length === 1) _.set(U.pageX, U.pageY);
      else {
        const ne = me(U),
          J = 0.5 * (U.pageX + ne.x),
          ge = 0.5 * (U.pageY + ne.y);
        _.set(J, ge);
      }
      d.subVectors(_, m).multiplyScalar(n.panSpeed), L(d.x, d.y), m.copy(_);
    }
    function be(U) {
      const ne = me(U),
        J = U.pageX - ne.x,
        ge = U.pageY - ne.y,
        Te = Math.sqrt(J * J + ge * ge);
      v.set(0, Te),
        S.set(0, Math.pow(v.y / y.y, n.zoomSpeed)),
        F(S.y),
        y.copy(v);
    }
    function Fe(U) {
      n.enableZoom && be(U), n.enablePan && re(U);
    }
    function ae(U) {
      n.enableZoom && be(U), n.enableRotate && ve(U);
    }
    function _e(U) {
      n.enabled !== !1 &&
        (E.length === 0 &&
          (n.domElement.setPointerCapture(U.pointerId),
          n.domElement.addEventListener("pointermove", K),
          n.domElement.addEventListener("pointerup", $e)),
        $(U),
        U.pointerType === "touch" ? Et(U) : ct(U));
    }
    function K(U) {
      n.enabled !== !1 && (U.pointerType === "touch" ? P(U) : Ge(U));
    }
    function $e(U) {
      ue(U),
        E.length === 0 &&
          (n.domElement.releasePointerCapture(U.pointerId),
          n.domElement.removeEventListener("pointermove", K),
          n.domElement.removeEventListener("pointerup", $e)),
        n.dispatchEvent(xm),
        (s = i.NONE);
    }
    function ct(U) {
      let ne;
      switch (U.button) {
        case 0:
          ne = n.mouseButtons.LEFT;
          break;
        case 1:
          ne = n.mouseButtons.MIDDLE;
          break;
        case 2:
          ne = n.mouseButtons.RIGHT;
          break;
        default:
          ne = -1;
      }
      switch (ne) {
        case Bs.DOLLY:
          if (n.enableZoom === !1) return;
          A(U), (s = i.DOLLY);
          break;
        case Bs.ROTATE:
          if (U.ctrlKey || U.metaKey || U.shiftKey) {
            if (n.enablePan === !1) return;
            k(U), (s = i.PAN);
          } else {
            if (n.enableRotate === !1) return;
            j(U), (s = i.ROTATE);
          }
          break;
        case Bs.PAN:
          if (U.ctrlKey || U.metaKey || U.shiftKey) {
            if (n.enableRotate === !1) return;
            j(U), (s = i.ROTATE);
          } else {
            if (n.enablePan === !1) return;
            k(U), (s = i.PAN);
          }
          break;
        default:
          s = i.NONE;
      }
      s !== i.NONE && n.dispatchEvent(sh);
    }
    function Ge(U) {
      switch (s) {
        case i.ROTATE:
          if (n.enableRotate === !1) return;
          G(U);
          break;
        case i.DOLLY:
          if (n.enableZoom === !1) return;
          z(U);
          break;
        case i.PAN:
          if (n.enablePan === !1) return;
          oe(U);
          break;
      }
    }
    function Xe(U) {
      n.enabled === !1 ||
        n.enableZoom === !1 ||
        s !== i.NONE ||
        (U.preventDefault(), n.dispatchEvent(sh), te(U), n.dispatchEvent(xm));
    }
    function st(U) {
      n.enabled === !1 || n.enablePan === !1 || X(U);
    }
    function Et(U) {
      switch ((he(U), E.length)) {
        case 1:
          switch (n.touches.ONE) {
            case ks.ROTATE:
              if (n.enableRotate === !1) return;
              Y(), (s = i.TOUCH_ROTATE);
              break;
            case ks.PAN:
              if (n.enablePan === !1) return;
              le(), (s = i.TOUCH_PAN);
              break;
            default:
              s = i.NONE;
          }
          break;
        case 2:
          switch (n.touches.TWO) {
            case ks.DOLLY_PAN:
              if (n.enableZoom === !1 && n.enablePan === !1) return;
              O(), (s = i.TOUCH_DOLLY_PAN);
              break;
            case ks.DOLLY_ROTATE:
              if (n.enableZoom === !1 && n.enableRotate === !1) return;
              Me(), (s = i.TOUCH_DOLLY_ROTATE);
              break;
            default:
              s = i.NONE;
          }
          break;
        default:
          s = i.NONE;
      }
      s !== i.NONE && n.dispatchEvent(sh);
    }
    function P(U) {
      switch ((he(U), s)) {
        case i.TOUCH_ROTATE:
          if (n.enableRotate === !1) return;
          ve(U), n.update();
          break;
        case i.TOUCH_PAN:
          if (n.enablePan === !1) return;
          re(U), n.update();
          break;
        case i.TOUCH_DOLLY_PAN:
          if (n.enableZoom === !1 && n.enablePan === !1) return;
          Fe(U), n.update();
          break;
        case i.TOUCH_DOLLY_ROTATE:
          if (n.enableZoom === !1 && n.enableRotate === !1) return;
          ae(U), n.update();
          break;
        default:
          s = i.NONE;
      }
    }
    function w(U) {
      n.enabled !== !1 && U.preventDefault();
    }
    function $(U) {
      E.push(U);
    }
    function ue(U) {
      delete b[U.pointerId];
      for (let ne = 0; ne < E.length; ne++)
        if (E[ne].pointerId == U.pointerId) {
          E.splice(ne, 1);
          return;
        }
    }
    function he(U) {
      let ne = b[U.pointerId];
      ne === void 0 && ((ne = new We()), (b[U.pointerId] = ne)),
        ne.set(U.pageX, U.pageY);
    }
    function me(U) {
      const ne = U.pointerId === E[0].pointerId ? E[1] : E[0];
      return b[ne.pointerId];
    }
    n.domElement.addEventListener("contextmenu", w),
      n.domElement.addEventListener("pointerdown", _e),
      n.domElement.addEventListener("pointercancel", $e),
      n.domElement.addEventListener("wheel", Xe, { passive: !1 }),
      this.update();
  }
}
function Ki(r) {
  if (r === void 0)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return r;
}
function gg(r, e) {
  (r.prototype = Object.create(e.prototype)),
    (r.prototype.constructor = r),
    (r.__proto__ = e);
}
/*!
 * GSAP 3.12.1
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var Gn = {
    autoSleep: 120,
    force3D: "auto",
    nullTargetWarn: 1,
    units: { lineHeight: "" },
  },
  Ha = { duration: 0.5, overwrite: !1, delay: 0 },
  zf,
  an,
  Rt,
  ti = 1e8,
  pt = 1 / ti,
  Hh = Math.PI * 2,
  zT = Hh / 4,
  HT = 0,
  vg = Math.sqrt,
  VT = Math.cos,
  GT = Math.sin,
  jt = function (e) {
    return typeof e == "string";
  },
  Ct = function (e) {
    return typeof e == "function";
  },
  lr = function (e) {
    return typeof e == "number";
  },
  Hf = function (e) {
    return typeof e > "u";
  },
  Ui = function (e) {
    return typeof e == "object";
  },
  Tn = function (e) {
    return e !== !1;
  },
  Vf = function () {
    return typeof window < "u";
  },
  Jl = function (e) {
    return Ct(e) || jt(e);
  },
  xg =
    (typeof ArrayBuffer == "function" && ArrayBuffer.isView) || function () {},
  on = Array.isArray,
  Vh = /(?:-?\.?\d|\.)+/gi,
  yg = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
  _a = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
  ah = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
  Eg = /[+-]=-?[.\d]+/,
  Sg = /[^,'"\[\]\s]+/gi,
  WT = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
  Mt,
  qn,
  Gh,
  Gf,
  Wn = {},
  Ic = {},
  Mg,
  bg = function (e) {
    return (Ic = As(e, Wn)) && Rn;
  },
  Wf = function (e, t) {
    return console.warn(
      "Invalid property",
      e,
      "set to",
      t,
      "Missing plugin? gsap.registerPlugin()"
    );
  },
  Nc = function (e, t) {
    return !t && console.warn(e);
  },
  Tg = function (e, t) {
    return (e && (Wn[e] = t) && Ic && (Ic[e] = t)) || Wn;
  },
  qo = function () {
    return 0;
  },
  XT = { suppressEvents: !0, isStart: !0, kill: !1 },
  _c = { suppressEvents: !0, kill: !1 },
  YT = { suppressEvents: !0 },
  Xf = {},
  Pr = [],
  Wh = {},
  Ag,
  kn = {},
  oh = {},
  ym = 30,
  gc = [],
  Yf = "",
  qf = function (e) {
    var t = e[0],
      n,
      i;
    if ((Ui(t) || Ct(t) || (e = [e]), !(n = (t._gsap || {}).harness))) {
      for (i = gc.length; i-- && !gc[i].targetTest(t); );
      n = gc[i];
    }
    for (i = e.length; i--; )
      (e[i] && (e[i]._gsap || (e[i]._gsap = new $g(e[i], n)))) ||
        e.splice(i, 1);
    return e;
  },
  ps = function (e) {
    return e._gsap || qf(ni(e))[0]._gsap;
  },
  wg = function (e, t, n) {
    return (n = e[t]) && Ct(n)
      ? e[t]()
      : (Hf(n) && e.getAttribute && e.getAttribute(t)) || n;
  },
  An = function (e, t) {
    return (e = e.split(",")).forEach(t) || e;
  },
  Lt = function (e) {
    return Math.round(e * 1e5) / 1e5 || 0;
  },
  Zt = function (e) {
    return Math.round(e * 1e7) / 1e7 || 0;
  },
  Ta = function (e, t) {
    var n = t.charAt(0),
      i = parseFloat(t.substr(2));
    return (
      (e = parseFloat(e)),
      n === "+" ? e + i : n === "-" ? e - i : n === "*" ? e * i : e / i
    );
  },
  qT = function (e, t) {
    for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n; );
    return i < n;
  },
  Oc = function () {
    var e = Pr.length,
      t = Pr.slice(0),
      n,
      i;
    for (Wh = {}, Pr.length = 0, n = 0; n < e; n++)
      (i = t[n]),
        i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0);
  },
  Rg = function (e, t, n, i) {
    Pr.length && !an && Oc(),
      e.render(t, n, i || (an && t < 0 && (e._initted || e._startAt))),
      Pr.length && !an && Oc();
  },
  Cg = function (e) {
    var t = parseFloat(e);
    return (t || t === 0) && (e + "").match(Sg).length < 2
      ? t
      : jt(e)
      ? e.trim()
      : e;
  },
  Pg = function (e) {
    return e;
  },
  ai = function (e, t) {
    for (var n in t) n in e || (e[n] = t[n]);
    return e;
  },
  jT = function (e) {
    return function (t, n) {
      for (var i in n)
        i in t || (i === "duration" && e) || i === "ease" || (t[i] = n[i]);
    };
  },
  As = function (e, t) {
    for (var n in t) e[n] = t[n];
    return e;
  },
  Em = function r(e, t) {
    for (var n in t)
      n !== "__proto__" &&
        n !== "constructor" &&
        n !== "prototype" &&
        (e[n] = Ui(t[n]) ? r(e[n] || (e[n] = {}), t[n]) : t[n]);
    return e;
  },
  Uc = function (e, t) {
    var n = {},
      i;
    for (i in e) i in t || (n[i] = e[i]);
    return n;
  },
  wo = function (e) {
    var t = e.parent || Mt,
      n = e.keyframes ? jT(on(e.keyframes)) : ai;
    if (Tn(e.inherit))
      for (; t; ) n(e, t.vars.defaults), (t = t.parent || t._dp);
    return e;
  },
  KT = function (e, t) {
    for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n]; );
    return n < 0;
  },
  Lg = function (e, t, n, i, s) {
    n === void 0 && (n = "_first"), i === void 0 && (i = "_last");
    var a = e[i],
      o;
    if (s) for (o = t[s]; a && a[s] > o; ) a = a._prev;
    return (
      a ? ((t._next = a._next), (a._next = t)) : ((t._next = e[n]), (e[n] = t)),
      t._next ? (t._next._prev = t) : (e[i] = t),
      (t._prev = a),
      (t.parent = t._dp = e),
      t
    );
  },
  uu = function (e, t, n, i) {
    n === void 0 && (n = "_first"), i === void 0 && (i = "_last");
    var s = t._prev,
      a = t._next;
    s ? (s._next = a) : e[n] === t && (e[n] = a),
      a ? (a._prev = s) : e[i] === t && (e[i] = s),
      (t._next = t._prev = t.parent = null);
  },
  Nr = function (e, t) {
    e.parent &&
      (!t || e.parent.autoRemoveChildren) &&
      e.parent.remove &&
      e.parent.remove(e),
      (e._act = 0);
  },
  ms = function (e, t) {
    if (e && (!t || t._end > e._dur || t._start < 0))
      for (var n = e; n; ) (n._dirty = 1), (n = n.parent);
    return e;
  },
  $T = function (e) {
    for (var t = e.parent; t && t.parent; )
      (t._dirty = 1), t.totalDuration(), (t = t.parent);
    return e;
  },
  Xh = function (e, t, n, i) {
    return (
      e._startAt &&
      (an
        ? e._startAt.revert(_c)
        : (e.vars.immediateRender && !e.vars.autoRevert) ||
          e._startAt.render(t, !0, i))
    );
  },
  ZT = function r(e) {
    return !e || (e._ts && r(e.parent));
  },
  Sm = function (e) {
    return e._repeat ? Va(e._tTime, (e = e.duration() + e._rDelay)) * e : 0;
  },
  Va = function (e, t) {
    var n = Math.floor((e /= t));
    return e && n === e ? n - 1 : n;
  },
  Fc = function (e, t) {
    return (
      (e - t._start) * t._ts +
      (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
    );
  },
  hu = function (e) {
    return (e._end = Zt(
      e._start + (e._tDur / Math.abs(e._ts || e._rts || pt) || 0)
    ));
  },
  fu = function (e, t) {
    var n = e._dp;
    return (
      n &&
        n.smoothChildTiming &&
        e._ts &&
        ((e._start = Zt(
          n._time -
            (e._ts > 0
              ? t / e._ts
              : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)
        )),
        hu(e),
        n._dirty || ms(n, e)),
      e
    );
  },
  Dg = function (e, t) {
    var n;
    if (
      ((t._time || (t._initted && !t._dur)) &&
        ((n = Fc(e.rawTime(), t)),
        (!t._dur || gl(0, t.totalDuration(), n) - t._tTime > pt) &&
          t.render(n, !0)),
      ms(e, t)._dp && e._initted && e._time >= e._dur && e._ts)
    ) {
      if (e._dur < e.duration())
        for (n = e; n._dp; )
          n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp);
      e._zTime = -pt;
    }
  },
  Ri = function (e, t, n, i) {
    return (
      t.parent && Nr(t),
      (t._start = Zt(
        (lr(n) ? n : n || e !== Mt ? Yn(e, n, t) : e._time) + t._delay
      )),
      (t._end = Zt(
        t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)
      )),
      Lg(e, t, "_first", "_last", e._sort ? "_start" : 0),
      Yh(t) || (e._recent = t),
      i || Dg(e, t),
      e._ts < 0 && fu(e, e._tTime),
      e
    );
  },
  Ig = function (e, t) {
    return (
      (Wn.ScrollTrigger || Wf("scrollTrigger", t)) &&
      Wn.ScrollTrigger.create(t, e)
    );
  },
  Ng = function (e, t, n, i, s) {
    if ((Kf(e, t, s), !e._initted)) return 1;
    if (
      !n &&
      e._pt &&
      !an &&
      ((e._dur && e.vars.lazy !== !1) || (!e._dur && e.vars.lazy)) &&
      Ag !== zn.frame
    )
      return Pr.push(e), (e._lazy = [s, i]), 1;
  },
  JT = function r(e) {
    var t = e.parent;
    return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || r(t));
  },
  Yh = function (e) {
    var t = e.data;
    return t === "isFromStart" || t === "isStart";
  },
  QT = function (e, t, n, i) {
    var s = e.ratio,
      a =
        t < 0 ||
        (!t &&
          ((!e._start && JT(e) && !(!e._initted && Yh(e))) ||
            ((e._ts < 0 || e._dp._ts < 0) && !Yh(e))))
          ? 0
          : 1,
      o = e._rDelay,
      l = 0,
      c,
      u,
      h;
    if (
      (o &&
        e._repeat &&
        ((l = gl(0, e._tDur, t)),
        (u = Va(l, o)),
        e._yoyo && u & 1 && (a = 1 - a),
        u !== Va(e._tTime, o) &&
          ((s = 1 - a), e.vars.repeatRefresh && e._initted && e.invalidate())),
      a !== s || an || i || e._zTime === pt || (!t && e._zTime))
    ) {
      if (!e._initted && Ng(e, t, i, n, l)) return;
      for (
        h = e._zTime,
          e._zTime = t || (n ? pt : 0),
          n || (n = t && !h),
          e.ratio = a,
          e._from && (a = 1 - a),
          e._time = 0,
          e._tTime = l,
          c = e._pt;
        c;

      )
        c.r(a, c.d), (c = c._next);
      t < 0 && Xh(e, t, n, !0),
        e._onUpdate && !n && ii(e, "onUpdate"),
        l && e._repeat && !n && e.parent && ii(e, "onRepeat"),
        (t >= e._tDur || t < 0) &&
          e.ratio === a &&
          (a && Nr(e, 1),
          !n &&
            !an &&
            (ii(e, a ? "onComplete" : "onReverseComplete", !0),
            e._prom && e._prom()));
    } else e._zTime || (e._zTime = t);
  },
  eA = function (e, t, n) {
    var i;
    if (n > t)
      for (i = e._first; i && i._start <= n; ) {
        if (i.data === "isPause" && i._start > t) return i;
        i = i._next;
      }
    else
      for (i = e._last; i && i._start >= n; ) {
        if (i.data === "isPause" && i._start < t) return i;
        i = i._prev;
      }
  },
  Ga = function (e, t, n, i) {
    var s = e._repeat,
      a = Zt(t) || 0,
      o = e._tTime / e._tDur;
    return (
      o && !i && (e._time *= a / e._dur),
      (e._dur = a),
      (e._tDur = s ? (s < 0 ? 1e10 : Zt(a * (s + 1) + e._rDelay * s)) : a),
      o > 0 && !i && fu(e, (e._tTime = e._tDur * o)),
      e.parent && hu(e),
      n || ms(e.parent, e),
      e
    );
  },
  Mm = function (e) {
    return e instanceof _n ? ms(e) : Ga(e, e._dur);
  },
  tA = { _start: 0, endTime: qo, totalDuration: qo },
  Yn = function r(e, t, n) {
    var i = e.labels,
      s = e._recent || tA,
      a = e.duration() >= ti ? s.endTime(!1) : e._dur,
      o,
      l,
      c;
    return jt(t) && (isNaN(t) || t in i)
      ? ((l = t.charAt(0)),
        (c = t.substr(-1) === "%"),
        (o = t.indexOf("=")),
        l === "<" || l === ">"
          ? (o >= 0 && (t = t.replace(/=/, "")),
            (l === "<" ? s._start : s.endTime(s._repeat >= 0)) +
              (parseFloat(t.substr(1)) || 0) *
                (c ? (o < 0 ? s : n).totalDuration() / 100 : 1))
          : o < 0
          ? (t in i || (i[t] = a), i[t])
          : ((l = parseFloat(t.charAt(o - 1) + t.substr(o + 1))),
            c && n && (l = (l / 100) * (on(n) ? n[0] : n).totalDuration()),
            o > 1 ? r(e, t.substr(0, o - 1), n) + l : a + l))
      : t == null
      ? a
      : +t;
  },
  Ro = function (e, t, n) {
    var i = lr(t[1]),
      s = (i ? 2 : 1) + (e < 2 ? 0 : 1),
      a = t[s],
      o,
      l;
    if ((i && (a.duration = t[1]), (a.parent = n), e)) {
      for (o = a, l = n; l && !("immediateRender" in o); )
        (o = l.vars.defaults || {}), (l = Tn(l.vars.inherit) && l.parent);
      (a.immediateRender = Tn(o.immediateRender)),
        e < 2 ? (a.runBackwards = 1) : (a.startAt = t[s - 1]);
    }
    return new Ut(t[0], a, t[s + 1]);
  },
  Hr = function (e, t) {
    return e || e === 0 ? t(e) : t;
  },
  gl = function (e, t, n) {
    return n < e ? e : n > t ? t : n;
  },
  sn = function (e, t) {
    return !jt(e) || !(t = WT.exec(e)) ? "" : t[1];
  },
  nA = function (e, t, n) {
    return Hr(n, function (i) {
      return gl(e, t, i);
    });
  },
  qh = [].slice,
  Og = function (e, t) {
    return (
      e &&
      Ui(e) &&
      "length" in e &&
      ((!t && !e.length) || (e.length - 1 in e && Ui(e[0]))) &&
      !e.nodeType &&
      e !== qn
    );
  },
  iA = function (e, t, n) {
    return (
      n === void 0 && (n = []),
      e.forEach(function (i) {
        var s;
        return (jt(i) && !t) || Og(i, 1)
          ? (s = n).push.apply(s, ni(i))
          : n.push(i);
      }) || n
    );
  },
  ni = function (e, t, n) {
    return Rt && !t && Rt.selector
      ? Rt.selector(e)
      : jt(e) && !n && (Gh || !Wa())
      ? qh.call((t || Gf).querySelectorAll(e), 0)
      : on(e)
      ? iA(e, n)
      : Og(e)
      ? qh.call(e, 0)
      : e
      ? [e]
      : [];
  },
  jh = function (e) {
    return (
      (e = ni(e)[0] || Nc("Invalid scope") || {}),
      function (t) {
        var n = e.current || e.nativeElement || e;
        return ni(
          t,
          n.querySelectorAll
            ? n
            : n === e
            ? Nc("Invalid scope") || Gf.createElement("div")
            : e
        );
      }
    );
  },
  Ug = function (e) {
    return e.sort(function () {
      return 0.5 - Math.random();
    });
  },
  Fg = function (e) {
    if (Ct(e)) return e;
    var t = Ui(e) ? e : { each: e },
      n = _s(t.ease),
      i = t.from || 0,
      s = parseFloat(t.base) || 0,
      a = {},
      o = i > 0 && i < 1,
      l = isNaN(i) || o,
      c = t.axis,
      u = i,
      h = i;
    return (
      jt(i)
        ? (u = h = { center: 0.5, edges: 0.5, end: 1 }[i] || 0)
        : !o && l && ((u = i[0]), (h = i[1])),
      function (f, p, g) {
        var m = (g || t).length,
          _ = a[m],
          d,
          y,
          v,
          S,
          E,
          b,
          M,
          C,
          x;
        if (!_) {
          if (((x = t.grid === "auto" ? 0 : (t.grid || [1, ti])[1]), !x)) {
            for (
              M = -ti;
              M < (M = g[x++].getBoundingClientRect().left) && x < m;

            );
            x--;
          }
          for (
            _ = a[m] = [],
              d = l ? Math.min(x, m) * u - 0.5 : i % x,
              y = x === ti ? 0 : l ? (m * h) / x - 0.5 : (i / x) | 0,
              M = 0,
              C = ti,
              b = 0;
            b < m;
            b++
          )
            (v = (b % x) - d),
              (S = y - ((b / x) | 0)),
              (_[b] = E = c ? Math.abs(c === "y" ? S : v) : vg(v * v + S * S)),
              E > M && (M = E),
              E < C && (C = E);
          i === "random" && Ug(_),
            (_.max = M - C),
            (_.min = C),
            (_.v = m =
              (parseFloat(t.amount) ||
                parseFloat(t.each) *
                  (x > m
                    ? m - 1
                    : c
                    ? c === "y"
                      ? m / x
                      : x
                    : Math.max(x, m / x)) ||
                0) * (i === "edges" ? -1 : 1)),
            (_.b = m < 0 ? s - m : s),
            (_.u = sn(t.amount || t.each) || 0),
            (n = n && m < 0 ? qg(n) : n);
        }
        return (
          (m = (_[f] - _.min) / _.max || 0),
          Zt(_.b + (n ? n(m) : m) * _.v) + _.u
        );
      }
    );
  },
  Kh = function (e) {
    var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
    return function (n) {
      var i = Zt(Math.round(parseFloat(n) / e) * e * t);
      return (i - (i % 1)) / t + (lr(n) ? 0 : sn(n));
    };
  },
  Bg = function (e, t) {
    var n = on(e),
      i,
      s;
    return (
      !n &&
        Ui(e) &&
        ((i = n = e.radius || ti),
        e.values
          ? ((e = ni(e.values)), (s = !lr(e[0])) && (i *= i))
          : (e = Kh(e.increment))),
      Hr(
        t,
        n
          ? Ct(e)
            ? function (a) {
                return (s = e(a)), Math.abs(s - a) <= i ? s : a;
              }
            : function (a) {
                for (
                  var o = parseFloat(s ? a.x : a),
                    l = parseFloat(s ? a.y : 0),
                    c = ti,
                    u = 0,
                    h = e.length,
                    f,
                    p;
                  h--;

                )
                  s
                    ? ((f = e[h].x - o), (p = e[h].y - l), (f = f * f + p * p))
                    : (f = Math.abs(e[h] - o)),
                    f < c && ((c = f), (u = h));
                return (
                  (u = !i || c <= i ? e[u] : a),
                  s || u === a || lr(a) ? u : u + sn(a)
                );
              }
          : Kh(e)
      )
    );
  },
  kg = function (e, t, n, i) {
    return Hr(on(e) ? !t : n === !0 ? !!(n = 0) : !i, function () {
      return on(e)
        ? e[~~(Math.random() * e.length)]
        : (n = n || 1e-5) &&
            (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) &&
            Math.floor(
              Math.round((e - n / 2 + Math.random() * (t - e + n * 0.99)) / n) *
                n *
                i
            ) / i;
    });
  },
  rA = function () {
    for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
      t[n] = arguments[n];
    return function (i) {
      return t.reduce(function (s, a) {
        return a(s);
      }, i);
    };
  },
  sA = function (e, t) {
    return function (n) {
      return e(parseFloat(n)) + (t || sn(n));
    };
  },
  aA = function (e, t, n) {
    return Hg(e, t, 0, 1, n);
  },
  zg = function (e, t, n) {
    return Hr(n, function (i) {
      return e[~~t(i)];
    });
  },
  oA = function r(e, t, n) {
    var i = t - e;
    return on(e)
      ? zg(e, r(0, e.length), t)
      : Hr(n, function (s) {
          return ((i + ((s - e) % i)) % i) + e;
        });
  },
  lA = function r(e, t, n) {
    var i = t - e,
      s = i * 2;
    return on(e)
      ? zg(e, r(0, e.length - 1), t)
      : Hr(n, function (a) {
          return (a = (s + ((a - e) % s)) % s || 0), e + (a > i ? s - a : a);
        });
  },
  jo = function (e) {
    for (var t = 0, n = "", i, s, a, o; ~(i = e.indexOf("random(", t)); )
      (a = e.indexOf(")", i)),
        (o = e.charAt(i + 7) === "["),
        (s = e.substr(i + 7, a - i - 7).match(o ? Sg : Vh)),
        (n +=
          e.substr(t, i - t) + kg(o ? s : +s[0], o ? 0 : +s[1], +s[2] || 1e-5)),
        (t = a + 1);
    return n + e.substr(t, e.length - t);
  },
  Hg = function (e, t, n, i, s) {
    var a = t - e,
      o = i - n;
    return Hr(s, function (l) {
      return n + (((l - e) / a) * o || 0);
    });
  },
  cA = function r(e, t, n, i) {
    var s = isNaN(e + t)
      ? 0
      : function (p) {
          return (1 - p) * e + p * t;
        };
    if (!s) {
      var a = jt(e),
        o = {},
        l,
        c,
        u,
        h,
        f;
      if ((n === !0 && (i = 1) && (n = null), a))
        (e = { p: e }), (t = { p: t });
      else if (on(e) && !on(t)) {
        for (u = [], h = e.length, f = h - 2, c = 1; c < h; c++)
          u.push(r(e[c - 1], e[c]));
        h--,
          (s = function (g) {
            g *= h;
            var m = Math.min(f, ~~g);
            return u[m](g - m);
          }),
          (n = t);
      } else i || (e = As(on(e) ? [] : {}, e));
      if (!u) {
        for (l in t) jf.call(o, e, l, "get", t[l]);
        s = function (g) {
          return Jf(g, o) || (a ? e.p : e);
        };
      }
    }
    return Hr(n, s);
  },
  bm = function (e, t, n) {
    var i = e.labels,
      s = ti,
      a,
      o,
      l;
    for (a in i)
      (o = i[a] - t),
        o < 0 == !!n && o && s > (o = Math.abs(o)) && ((l = a), (s = o));
    return l;
  },
  ii = function (e, t, n) {
    var i = e.vars,
      s = i[t],
      a = Rt,
      o = e._ctx,
      l,
      c,
      u;
    if (s)
      return (
        (l = i[t + "Params"]),
        (c = i.callbackScope || e),
        n && Pr.length && Oc(),
        o && (Rt = o),
        (u = l ? s.apply(c, l) : s.call(c)),
        (Rt = a),
        u
      );
  },
  vo = function (e) {
    return (
      Nr(e),
      e.scrollTrigger && e.scrollTrigger.kill(!!an),
      e.progress() < 1 && ii(e, "onInterrupt"),
      e
    );
  },
  ga,
  Vg = [],
  Gg = function (e) {
    if (Vf() && e) {
      e = (!e.name && e.default) || e;
      var t = e.name,
        n = Ct(e),
        i =
          t && !n && e.init
            ? function () {
                this._props = [];
              }
            : e,
        s = {
          init: qo,
          render: Jf,
          add: jf,
          kill: TA,
          modifier: bA,
          rawVars: 0,
        },
        a = { targetTest: 0, get: 0, getSetter: Zf, aliases: {}, register: 0 };
      if ((Wa(), e !== i)) {
        if (kn[t]) return;
        ai(i, ai(Uc(e, s), a)),
          As(i.prototype, As(s, Uc(e, a))),
          (kn[(i.prop = t)] = i),
          e.targetTest && (gc.push(i), (Xf[t] = 1)),
          (t =
            (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) +
            "Plugin");
      }
      Tg(t, i), e.register && e.register(Rn, i, wn);
    } else e && Vg.push(e);
  },
  ft = 255,
  xo = {
    aqua: [0, ft, ft],
    lime: [0, ft, 0],
    silver: [192, 192, 192],
    black: [0, 0, 0],
    maroon: [128, 0, 0],
    teal: [0, 128, 128],
    blue: [0, 0, ft],
    navy: [0, 0, 128],
    white: [ft, ft, ft],
    olive: [128, 128, 0],
    yellow: [ft, ft, 0],
    orange: [ft, 165, 0],
    gray: [128, 128, 128],
    purple: [128, 0, 128],
    green: [0, 128, 0],
    red: [ft, 0, 0],
    pink: [ft, 192, 203],
    cyan: [0, ft, ft],
    transparent: [ft, ft, ft, 0],
  },
  lh = function (e, t, n) {
    return (
      (e += e < 0 ? 1 : e > 1 ? -1 : 0),
      ((e * 6 < 1
        ? t + (n - t) * e * 6
        : e < 0.5
        ? n
        : e * 3 < 2
        ? t + (n - t) * (2 / 3 - e) * 6
        : t) *
        ft +
        0.5) |
        0
    );
  },
  Wg = function (e, t, n) {
    var i = e ? (lr(e) ? [e >> 16, (e >> 8) & ft, e & ft] : 0) : xo.black,
      s,
      a,
      o,
      l,
      c,
      u,
      h,
      f,
      p,
      g;
    if (!i) {
      if ((e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), xo[e]))
        i = xo[e];
      else if (e.charAt(0) === "#") {
        if (
          (e.length < 6 &&
            ((s = e.charAt(1)),
            (a = e.charAt(2)),
            (o = e.charAt(3)),
            (e =
              "#" +
              s +
              s +
              a +
              a +
              o +
              o +
              (e.length === 5 ? e.charAt(4) + e.charAt(4) : ""))),
          e.length === 9)
        )
          return (
            (i = parseInt(e.substr(1, 6), 16)),
            [i >> 16, (i >> 8) & ft, i & ft, parseInt(e.substr(7), 16) / 255]
          );
        (e = parseInt(e.substr(1), 16)), (i = [e >> 16, (e >> 8) & ft, e & ft]);
      } else if (e.substr(0, 3) === "hsl") {
        if (((i = g = e.match(Vh)), !t))
          (l = (+i[0] % 360) / 360),
            (c = +i[1] / 100),
            (u = +i[2] / 100),
            (a = u <= 0.5 ? u * (c + 1) : u + c - u * c),
            (s = u * 2 - a),
            i.length > 3 && (i[3] *= 1),
            (i[0] = lh(l + 1 / 3, s, a)),
            (i[1] = lh(l, s, a)),
            (i[2] = lh(l - 1 / 3, s, a));
        else if (~e.indexOf("="))
          return (i = e.match(yg)), n && i.length < 4 && (i[3] = 1), i;
      } else i = e.match(Vh) || xo.transparent;
      i = i.map(Number);
    }
    return (
      t &&
        !g &&
        ((s = i[0] / ft),
        (a = i[1] / ft),
        (o = i[2] / ft),
        (h = Math.max(s, a, o)),
        (f = Math.min(s, a, o)),
        (u = (h + f) / 2),
        h === f
          ? (l = c = 0)
          : ((p = h - f),
            (c = u > 0.5 ? p / (2 - h - f) : p / (h + f)),
            (l =
              h === s
                ? (a - o) / p + (a < o ? 6 : 0)
                : h === a
                ? (o - s) / p + 2
                : (s - a) / p + 4),
            (l *= 60)),
        (i[0] = ~~(l + 0.5)),
        (i[1] = ~~(c * 100 + 0.5)),
        (i[2] = ~~(u * 100 + 0.5))),
      n && i.length < 4 && (i[3] = 1),
      i
    );
  },
  Xg = function (e) {
    var t = [],
      n = [],
      i = -1;
    return (
      e.split(Lr).forEach(function (s) {
        var a = s.match(_a) || [];
        t.push.apply(t, a), n.push((i += a.length + 1));
      }),
      (t.c = n),
      t
    );
  },
  Tm = function (e, t, n) {
    var i = "",
      s = (e + i).match(Lr),
      a = t ? "hsla(" : "rgba(",
      o = 0,
      l,
      c,
      u,
      h;
    if (!s) return e;
    if (
      ((s = s.map(function (f) {
        return (
          (f = Wg(f, t, 1)) &&
          a +
            (t ? f[0] + "," + f[1] + "%," + f[2] + "%," + f[3] : f.join(",")) +
            ")"
        );
      })),
      n && ((u = Xg(e)), (l = n.c), l.join(i) !== u.c.join(i)))
    )
      for (c = e.replace(Lr, "1").split(_a), h = c.length - 1; o < h; o++)
        i +=
          c[o] +
          (~l.indexOf(o)
            ? s.shift() || a + "0,0,0,0)"
            : (u.length ? u : s.length ? s : n).shift());
    if (!c)
      for (c = e.split(Lr), h = c.length - 1; o < h; o++) i += c[o] + s[o];
    return i + c[h];
  },
  Lr = (function () {
    var r =
        "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
      e;
    for (e in xo) r += "|" + e + "\\b";
    return new RegExp(r + ")", "gi");
  })(),
  uA = /hsl[a]?\(/,
  Yg = function (e) {
    var t = e.join(" "),
      n;
    if (((Lr.lastIndex = 0), Lr.test(t)))
      return (
        (n = uA.test(t)),
        (e[1] = Tm(e[1], n)),
        (e[0] = Tm(e[0], n, Xg(e[1]))),
        !0
      );
  },
  Ko,
  zn = (function () {
    var r = Date.now,
      e = 500,
      t = 33,
      n = r(),
      i = n,
      s = 1e3 / 240,
      a = s,
      o = [],
      l,
      c,
      u,
      h,
      f,
      p,
      g = function m(_) {
        var d = r() - i,
          y = _ === !0,
          v,
          S,
          E,
          b;
        if (
          (d > e && (n += d - t),
          (i += d),
          (E = i - n),
          (v = E - a),
          (v > 0 || y) &&
            ((b = ++h.frame),
            (f = E - h.time * 1e3),
            (h.time = E = E / 1e3),
            (a += v + (v >= s ? 4 : s - v)),
            (S = 1)),
          y || (l = c(m)),
          S)
        )
          for (p = 0; p < o.length; p++) o[p](E, f, b, _);
      };
    return (
      (h = {
        time: 0,
        frame: 0,
        tick: function () {
          g(!0);
        },
        deltaRatio: function (_) {
          return f / (1e3 / (_ || 60));
        },
        wake: function () {
          Mg &&
            (!Gh &&
              Vf() &&
              ((qn = Gh = window),
              (Gf = qn.document || {}),
              (Wn.gsap = Rn),
              (qn.gsapVersions || (qn.gsapVersions = [])).push(Rn.version),
              bg(Ic || qn.GreenSockGlobals || (!qn.gsap && qn) || {}),
              (u = qn.requestAnimationFrame),
              Vg.forEach(Gg)),
            l && h.sleep(),
            (c =
              u ||
              function (_) {
                return setTimeout(_, (a - h.time * 1e3 + 1) | 0);
              }),
            (Ko = 1),
            g(2));
        },
        sleep: function () {
          (u ? qn.cancelAnimationFrame : clearTimeout)(l), (Ko = 0), (c = qo);
        },
        lagSmoothing: function (_, d) {
          (e = _ || 1 / 0), (t = Math.min(d || 33, e));
        },
        fps: function (_) {
          (s = 1e3 / (_ || 240)), (a = h.time * 1e3 + s);
        },
        add: function (_, d, y) {
          var v = d
            ? function (S, E, b, M) {
                _(S, E, b, M), h.remove(v);
              }
            : _;
          return h.remove(_), o[y ? "unshift" : "push"](v), Wa(), v;
        },
        remove: function (_, d) {
          ~(d = o.indexOf(_)) && o.splice(d, 1) && p >= d && p--;
        },
        _listeners: o,
      }),
      h
    );
  })(),
  Wa = function () {
    return !Ko && zn.wake();
  },
  rt = {},
  hA = /^[\d.\-M][\d.\-,\s]/,
  fA = /["']/g,
  dA = function (e) {
    for (
      var t = {},
        n = e.substr(1, e.length - 3).split(":"),
        i = n[0],
        s = 1,
        a = n.length,
        o,
        l,
        c;
      s < a;
      s++
    )
      (l = n[s]),
        (o = s !== a - 1 ? l.lastIndexOf(",") : l.length),
        (c = l.substr(0, o)),
        (t[i] = isNaN(c) ? c.replace(fA, "").trim() : +c),
        (i = l.substr(o + 1).trim());
    return t;
  },
  pA = function (e) {
    var t = e.indexOf("(") + 1,
      n = e.indexOf(")"),
      i = e.indexOf("(", t);
    return e.substring(t, ~i && i < n ? e.indexOf(")", n + 1) : n);
  },
  mA = function (e) {
    var t = (e + "").split("("),
      n = rt[t[0]];
    return n && t.length > 1 && n.config
      ? n.config.apply(
          null,
          ~e.indexOf("{") ? [dA(t[1])] : pA(e).split(",").map(Cg)
        )
      : rt._CE && hA.test(e)
      ? rt._CE("", e)
      : n;
  },
  qg = function (e) {
    return function (t) {
      return 1 - e(1 - t);
    };
  },
  jg = function r(e, t) {
    for (var n = e._first, i; n; )
      n instanceof _n
        ? r(n, t)
        : n.vars.yoyoEase &&
          (!n._yoyo || !n._repeat) &&
          n._yoyo !== t &&
          (n.timeline
            ? r(n.timeline, t)
            : ((i = n._ease),
              (n._ease = n._yEase),
              (n._yEase = i),
              (n._yoyo = t))),
        (n = n._next);
  },
  _s = function (e, t) {
    return (e && (Ct(e) ? e : rt[e] || mA(e))) || t;
  },
  Ns = function (e, t, n, i) {
    n === void 0 &&
      (n = function (l) {
        return 1 - t(1 - l);
      }),
      i === void 0 &&
        (i = function (l) {
          return l < 0.5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2;
        });
    var s = { easeIn: t, easeOut: n, easeInOut: i },
      a;
    return (
      An(e, function (o) {
        (rt[o] = Wn[o] = s), (rt[(a = o.toLowerCase())] = n);
        for (var l in s)
          rt[
            a + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")
          ] = rt[o + "." + l] = s[l];
      }),
      s
    );
  },
  Kg = function (e) {
    return function (t) {
      return t < 0.5 ? (1 - e(1 - t * 2)) / 2 : 0.5 + e((t - 0.5) * 2) / 2;
    };
  },
  ch = function r(e, t, n) {
    var i = t >= 1 ? t : 1,
      s = (n || (e ? 0.3 : 0.45)) / (t < 1 ? t : 1),
      a = (s / Hh) * (Math.asin(1 / i) || 0),
      o = function (u) {
        return u === 1 ? 1 : i * Math.pow(2, -10 * u) * GT((u - a) * s) + 1;
      },
      l =
        e === "out"
          ? o
          : e === "in"
          ? function (c) {
              return 1 - o(1 - c);
            }
          : Kg(o);
    return (
      (s = Hh / s),
      (l.config = function (c, u) {
        return r(e, c, u);
      }),
      l
    );
  },
  uh = function r(e, t) {
    t === void 0 && (t = 1.70158);
    var n = function (a) {
        return a ? --a * a * ((t + 1) * a + t) + 1 : 0;
      },
      i =
        e === "out"
          ? n
          : e === "in"
          ? function (s) {
              return 1 - n(1 - s);
            }
          : Kg(n);
    return (
      (i.config = function (s) {
        return r(e, s);
      }),
      i
    );
  };
An("Linear,Quad,Cubic,Quart,Quint,Strong", function (r, e) {
  var t = e < 5 ? e + 1 : e;
  Ns(
    r + ",Power" + (t - 1),
    e
      ? function (n) {
          return Math.pow(n, t);
        }
      : function (n) {
          return n;
        },
    function (n) {
      return 1 - Math.pow(1 - n, t);
    },
    function (n) {
      return n < 0.5
        ? Math.pow(n * 2, t) / 2
        : 1 - Math.pow((1 - n) * 2, t) / 2;
    }
  );
});
rt.Linear.easeNone = rt.none = rt.Linear.easeIn;
Ns("Elastic", ch("in"), ch("out"), ch());
(function (r, e) {
  var t = 1 / e,
    n = 2 * t,
    i = 2.5 * t,
    s = function (o) {
      return o < t
        ? r * o * o
        : o < n
        ? r * Math.pow(o - 1.5 / e, 2) + 0.75
        : o < i
        ? r * (o -= 2.25 / e) * o + 0.9375
        : r * Math.pow(o - 2.625 / e, 2) + 0.984375;
    };
  Ns(
    "Bounce",
    function (a) {
      return 1 - s(1 - a);
    },
    s
  );
})(7.5625, 2.75);
Ns("Expo", function (r) {
  return r ? Math.pow(2, 10 * (r - 1)) : 0;
});
Ns("Circ", function (r) {
  return -(vg(1 - r * r) - 1);
});
Ns("Sine", function (r) {
  return r === 1 ? 1 : -VT(r * zT) + 1;
});
Ns("Back", uh("in"), uh("out"), uh());
rt.SteppedEase =
  rt.steps =
  Wn.SteppedEase =
    {
      config: function (e, t) {
        e === void 0 && (e = 1);
        var n = 1 / e,
          i = e + (t ? 0 : 1),
          s = t ? 1 : 0,
          a = 1 - pt;
        return function (o) {
          return (((i * gl(0, a, o)) | 0) + s) * n;
        };
      },
    };
Ha.ease = rt["quad.out"];
An(
  "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
  function (r) {
    return (Yf += r + "," + r + "Params,");
  }
);
var $g = function (e, t) {
    (this.id = HT++),
      (e._gsap = this),
      (this.target = e),
      (this.harness = t),
      (this.get = t ? t.get : wg),
      (this.set = t ? t.getSetter : Zf);
  },
  $o = (function () {
    function r(t) {
      (this.vars = t),
        (this._delay = +t.delay || 0),
        (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) &&
          ((this._rDelay = t.repeatDelay || 0),
          (this._yoyo = !!t.yoyo || !!t.yoyoEase)),
        (this._ts = 1),
        Ga(this, +t.duration, 1, 1),
        (this.data = t.data),
        Rt && ((this._ctx = Rt), Rt.data.push(this)),
        Ko || zn.wake();
    }
    var e = r.prototype;
    return (
      (e.delay = function (n) {
        return n || n === 0
          ? (this.parent &&
              this.parent.smoothChildTiming &&
              this.startTime(this._start + n - this._delay),
            (this._delay = n),
            this)
          : this._delay;
      }),
      (e.duration = function (n) {
        return arguments.length
          ? this.totalDuration(
              this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n
            )
          : this.totalDuration() && this._dur;
      }),
      (e.totalDuration = function (n) {
        return arguments.length
          ? ((this._dirty = 0),
            Ga(
              this,
              this._repeat < 0
                ? n
                : (n - this._repeat * this._rDelay) / (this._repeat + 1)
            ))
          : this._tDur;
      }),
      (e.totalTime = function (n, i) {
        if ((Wa(), !arguments.length)) return this._tTime;
        var s = this._dp;
        if (s && s.smoothChildTiming && this._ts) {
          for (fu(this, n), !s._dp || s.parent || Dg(s, this); s && s.parent; )
            s.parent._time !==
              s._start +
                (s._ts >= 0
                  ? s._tTime / s._ts
                  : (s.totalDuration() - s._tTime) / -s._ts) &&
              s.totalTime(s._tTime, !0),
              (s = s.parent);
          !this.parent &&
            this._dp.autoRemoveChildren &&
            ((this._ts > 0 && n < this._tDur) ||
              (this._ts < 0 && n > 0) ||
              (!this._tDur && !n)) &&
            Ri(this._dp, this, this._start - this._delay);
        }
        return (
          (this._tTime !== n ||
            (!this._dur && !i) ||
            (this._initted && Math.abs(this._zTime) === pt) ||
            (!n && !this._initted && (this.add || this._ptLookup))) &&
            (this._ts || (this._pTime = n), Rg(this, n, i)),
          this
        );
      }),
      (e.time = function (n, i) {
        return arguments.length
          ? this.totalTime(
              Math.min(this.totalDuration(), n + Sm(this)) %
                (this._dur + this._rDelay) || (n ? this._dur : 0),
              i
            )
          : this._time;
      }),
      (e.totalProgress = function (n, i) {
        return arguments.length
          ? this.totalTime(this.totalDuration() * n, i)
          : this.totalDuration()
          ? Math.min(1, this._tTime / this._tDur)
          : this.ratio;
      }),
      (e.progress = function (n, i) {
        return arguments.length
          ? this.totalTime(
              this.duration() *
                (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) +
                Sm(this),
              i
            )
          : this.duration()
          ? Math.min(1, this._time / this._dur)
          : this.ratio;
      }),
      (e.iteration = function (n, i) {
        var s = this.duration() + this._rDelay;
        return arguments.length
          ? this.totalTime(this._time + (n - 1) * s, i)
          : this._repeat
          ? Va(this._tTime, s) + 1
          : 1;
      }),
      (e.timeScale = function (n) {
        if (!arguments.length) return this._rts === -pt ? 0 : this._rts;
        if (this._rts === n) return this;
        var i =
          this.parent && this._ts ? Fc(this.parent._time, this) : this._tTime;
        return (
          (this._rts = +n || 0),
          (this._ts = this._ps || n === -pt ? 0 : this._rts),
          this.totalTime(gl(-Math.abs(this._delay), this._tDur, i), !0),
          hu(this),
          $T(this)
        );
      }),
      (e.paused = function (n) {
        return arguments.length
          ? (this._ps !== n &&
              ((this._ps = n),
              n
                ? ((this._pTime =
                    this._tTime || Math.max(-this._delay, this.rawTime())),
                  (this._ts = this._act = 0))
                : (Wa(),
                  (this._ts = this._rts),
                  this.totalTime(
                    this.parent && !this.parent.smoothChildTiming
                      ? this.rawTime()
                      : this._tTime || this._pTime,
                    this.progress() === 1 &&
                      Math.abs(this._zTime) !== pt &&
                      (this._tTime -= pt)
                  ))),
            this)
          : this._ps;
      }),
      (e.startTime = function (n) {
        if (arguments.length) {
          this._start = n;
          var i = this.parent || this._dp;
          return (
            i && (i._sort || !this.parent) && Ri(i, this, n - this._delay), this
          );
        }
        return this._start;
      }),
      (e.endTime = function (n) {
        return (
          this._start +
          (Tn(n) ? this.totalDuration() : this.duration()) /
            Math.abs(this._ts || 1)
        );
      }),
      (e.rawTime = function (n) {
        var i = this.parent || this._dp;
        return i
          ? n &&
            (!this._ts ||
              (this._repeat && this._time && this.totalProgress() < 1))
            ? this._tTime % (this._dur + this._rDelay)
            : this._ts
            ? Fc(i.rawTime(n), this)
            : this._tTime
          : this._tTime;
      }),
      (e.revert = function (n) {
        n === void 0 && (n = YT);
        var i = an;
        return (
          (an = n),
          (this._initted || this._startAt) &&
            (this.timeline && this.timeline.revert(n),
            this.totalTime(-0.01, n.suppressEvents)),
          this.data !== "nested" && n.kill !== !1 && this.kill(),
          (an = i),
          this
        );
      }),
      (e.globalTime = function (n) {
        for (var i = this, s = arguments.length ? n : i.rawTime(); i; )
          (s = i._start + s / (i._ts || 1)), (i = i._dp);
        return !this.parent && this._sat
          ? this._sat.vars.immediateRender
            ? -1
            : this._sat.globalTime(n)
          : s;
      }),
      (e.repeat = function (n) {
        return arguments.length
          ? ((this._repeat = n === 1 / 0 ? -2 : n), Mm(this))
          : this._repeat === -2
          ? 1 / 0
          : this._repeat;
      }),
      (e.repeatDelay = function (n) {
        if (arguments.length) {
          var i = this._time;
          return (this._rDelay = n), Mm(this), i ? this.time(i) : this;
        }
        return this._rDelay;
      }),
      (e.yoyo = function (n) {
        return arguments.length ? ((this._yoyo = n), this) : this._yoyo;
      }),
      (e.seek = function (n, i) {
        return this.totalTime(Yn(this, n), Tn(i));
      }),
      (e.restart = function (n, i) {
        return this.play().totalTime(n ? -this._delay : 0, Tn(i));
      }),
      (e.play = function (n, i) {
        return n != null && this.seek(n, i), this.reversed(!1).paused(!1);
      }),
      (e.reverse = function (n, i) {
        return (
          n != null && this.seek(n || this.totalDuration(), i),
          this.reversed(!0).paused(!1)
        );
      }),
      (e.pause = function (n, i) {
        return n != null && this.seek(n, i), this.paused(!0);
      }),
      (e.resume = function () {
        return this.paused(!1);
      }),
      (e.reversed = function (n) {
        return arguments.length
          ? (!!n !== this.reversed() &&
              this.timeScale(-this._rts || (n ? -pt : 0)),
            this)
          : this._rts < 0;
      }),
      (e.invalidate = function () {
        return (this._initted = this._act = 0), (this._zTime = -pt), this;
      }),
      (e.isActive = function () {
        var n = this.parent || this._dp,
          i = this._start,
          s;
        return !!(
          !n ||
          (this._ts &&
            this._initted &&
            n.isActive() &&
            (s = n.rawTime(!0)) >= i &&
            s < this.endTime(!0) - pt)
        );
      }),
      (e.eventCallback = function (n, i, s) {
        var a = this.vars;
        return arguments.length > 1
          ? (i
              ? ((a[n] = i),
                s && (a[n + "Params"] = s),
                n === "onUpdate" && (this._onUpdate = i))
              : delete a[n],
            this)
          : a[n];
      }),
      (e.then = function (n) {
        var i = this;
        return new Promise(function (s) {
          var a = Ct(n) ? n : Pg,
            o = function () {
              var c = i.then;
              (i.then = null),
                Ct(a) && (a = a(i)) && (a.then || a === i) && (i.then = c),
                s(a),
                (i.then = c);
            };
          (i._initted && i.totalProgress() === 1 && i._ts >= 0) ||
          (!i._tTime && i._ts < 0)
            ? o()
            : (i._prom = o);
        });
      }),
      (e.kill = function () {
        vo(this);
      }),
      r
    );
  })();
ai($o.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: !1,
  parent: null,
  _initted: !1,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -pt,
  _prom: 0,
  _ps: !1,
  _rts: 1,
});
var _n = (function (r) {
  gg(e, r);
  function e(n, i) {
    var s;
    return (
      n === void 0 && (n = {}),
      (s = r.call(this, n) || this),
      (s.labels = {}),
      (s.smoothChildTiming = !!n.smoothChildTiming),
      (s.autoRemoveChildren = !!n.autoRemoveChildren),
      (s._sort = Tn(n.sortChildren)),
      Mt && Ri(n.parent || Mt, Ki(s), i),
      n.reversed && s.reverse(),
      n.paused && s.paused(!0),
      n.scrollTrigger && Ig(Ki(s), n.scrollTrigger),
      s
    );
  }
  var t = e.prototype;
  return (
    (t.to = function (i, s, a) {
      return Ro(0, arguments, this), this;
    }),
    (t.from = function (i, s, a) {
      return Ro(1, arguments, this), this;
    }),
    (t.fromTo = function (i, s, a, o) {
      return Ro(2, arguments, this), this;
    }),
    (t.set = function (i, s, a) {
      return (
        (s.duration = 0),
        (s.parent = this),
        wo(s).repeatDelay || (s.repeat = 0),
        (s.immediateRender = !!s.immediateRender),
        new Ut(i, s, Yn(this, a), 1),
        this
      );
    }),
    (t.call = function (i, s, a) {
      return Ri(this, Ut.delayedCall(0, i, s), a);
    }),
    (t.staggerTo = function (i, s, a, o, l, c, u) {
      return (
        (a.duration = s),
        (a.stagger = a.stagger || o),
        (a.onComplete = c),
        (a.onCompleteParams = u),
        (a.parent = this),
        new Ut(i, a, Yn(this, l)),
        this
      );
    }),
    (t.staggerFrom = function (i, s, a, o, l, c, u) {
      return (
        (a.runBackwards = 1),
        (wo(a).immediateRender = Tn(a.immediateRender)),
        this.staggerTo(i, s, a, o, l, c, u)
      );
    }),
    (t.staggerFromTo = function (i, s, a, o, l, c, u, h) {
      return (
        (o.startAt = a),
        (wo(o).immediateRender = Tn(o.immediateRender)),
        this.staggerTo(i, s, o, l, c, u, h)
      );
    }),
    (t.render = function (i, s, a) {
      var o = this._time,
        l = this._dirty ? this.totalDuration() : this._tDur,
        c = this._dur,
        u = i <= 0 ? 0 : Zt(i),
        h = this._zTime < 0 != i < 0 && (this._initted || !c),
        f,
        p,
        g,
        m,
        _,
        d,
        y,
        v,
        S,
        E,
        b,
        M;
      if (
        (this !== Mt && u > l && i >= 0 && (u = l), u !== this._tTime || a || h)
      ) {
        if (
          (o !== this._time &&
            c &&
            ((u += this._time - o), (i += this._time - o)),
          (f = u),
          (S = this._start),
          (v = this._ts),
          (d = !v),
          h && (c || (o = this._zTime), (i || !s) && (this._zTime = i)),
          this._repeat)
        ) {
          if (
            ((b = this._yoyo),
            (_ = c + this._rDelay),
            this._repeat < -1 && i < 0)
          )
            return this.totalTime(_ * 100 + i, s, a);
          if (
            ((f = Zt(u % _)),
            u === l
              ? ((m = this._repeat), (f = c))
              : ((m = ~~(u / _)),
                m && m === u / _ && ((f = c), m--),
                f > c && (f = c)),
            (E = Va(this._tTime, _)),
            !o &&
              this._tTime &&
              E !== m &&
              this._tTime - E * _ - this._dur <= 0 &&
              (E = m),
            b && m & 1 && ((f = c - f), (M = 1)),
            m !== E && !this._lock)
          ) {
            var C = b && E & 1,
              x = C === (b && m & 1);
            if (
              (m < E && (C = !C),
              (o = C ? 0 : c),
              (this._lock = 1),
              (this.render(o || (M ? 0 : Zt(m * _)), s, !c)._lock = 0),
              (this._tTime = u),
              !s && this.parent && ii(this, "onRepeat"),
              this.vars.repeatRefresh && !M && (this.invalidate()._lock = 1),
              (o && o !== this._time) ||
                d !== !this._ts ||
                (this.vars.onRepeat && !this.parent && !this._act))
            )
              return this;
            if (
              ((c = this._dur),
              (l = this._tDur),
              x &&
                ((this._lock = 2),
                (o = C ? c : -1e-4),
                this.render(o, !0),
                this.vars.repeatRefresh && !M && this.invalidate()),
              (this._lock = 0),
              !this._ts && !d)
            )
              return this;
            jg(this, M);
          }
        }
        if (
          (this._hasPause &&
            !this._forcing &&
            this._lock < 2 &&
            ((y = eA(this, Zt(o), Zt(f))), y && (u -= f - (f = y._start))),
          (this._tTime = u),
          (this._time = f),
          (this._act = !v),
          this._initted ||
            ((this._onUpdate = this.vars.onUpdate),
            (this._initted = 1),
            (this._zTime = i),
            (o = 0)),
          !o && f && !s && !m && (ii(this, "onStart"), this._tTime !== u))
        )
          return this;
        if (f >= o && i >= 0)
          for (p = this._first; p; ) {
            if (
              ((g = p._next), (p._act || f >= p._start) && p._ts && y !== p)
            ) {
              if (p.parent !== this) return this.render(i, s, a);
              if (
                (p.render(
                  p._ts > 0
                    ? (f - p._start) * p._ts
                    : (p._dirty ? p.totalDuration() : p._tDur) +
                        (f - p._start) * p._ts,
                  s,
                  a
                ),
                f !== this._time || (!this._ts && !d))
              ) {
                (y = 0), g && (u += this._zTime = -pt);
                break;
              }
            }
            p = g;
          }
        else {
          p = this._last;
          for (var T = i < 0 ? i : f; p; ) {
            if (((g = p._prev), (p._act || T <= p._end) && p._ts && y !== p)) {
              if (p.parent !== this) return this.render(i, s, a);
              if (
                (p.render(
                  p._ts > 0
                    ? (T - p._start) * p._ts
                    : (p._dirty ? p.totalDuration() : p._tDur) +
                        (T - p._start) * p._ts,
                  s,
                  a || (an && (p._initted || p._startAt))
                ),
                f !== this._time || (!this._ts && !d))
              ) {
                (y = 0), g && (u += this._zTime = T ? -pt : pt);
                break;
              }
            }
            p = g;
          }
        }
        if (
          y &&
          !s &&
          (this.pause(),
          (y.render(f >= o ? 0 : -pt)._zTime = f >= o ? 1 : -1),
          this._ts)
        )
          return (this._start = S), hu(this), this.render(i, s, a);
        this._onUpdate && !s && ii(this, "onUpdate", !0),
          ((u === l && this._tTime >= this.totalDuration()) || (!u && o)) &&
            (S === this._start || Math.abs(v) !== Math.abs(this._ts)) &&
            (this._lock ||
              ((i || !c) &&
                ((u === l && this._ts > 0) || (!u && this._ts < 0)) &&
                Nr(this, 1),
              !s &&
                !(i < 0 && !o) &&
                (u || o || !l) &&
                (ii(
                  this,
                  u === l && i >= 0 ? "onComplete" : "onReverseComplete",
                  !0
                ),
                this._prom &&
                  !(u < l && this.timeScale() > 0) &&
                  this._prom())));
      }
      return this;
    }),
    (t.add = function (i, s) {
      var a = this;
      if ((lr(s) || (s = Yn(this, s, i)), !(i instanceof $o))) {
        if (on(i))
          return (
            i.forEach(function (o) {
              return a.add(o, s);
            }),
            this
          );
        if (jt(i)) return this.addLabel(i, s);
        if (Ct(i)) i = Ut.delayedCall(0, i);
        else return this;
      }
      return this !== i ? Ri(this, i, s) : this;
    }),
    (t.getChildren = function (i, s, a, o) {
      i === void 0 && (i = !0),
        s === void 0 && (s = !0),
        a === void 0 && (a = !0),
        o === void 0 && (o = -ti);
      for (var l = [], c = this._first; c; )
        c._start >= o &&
          (c instanceof Ut
            ? s && l.push(c)
            : (a && l.push(c), i && l.push.apply(l, c.getChildren(!0, s, a)))),
          (c = c._next);
      return l;
    }),
    (t.getById = function (i) {
      for (var s = this.getChildren(1, 1, 1), a = s.length; a--; )
        if (s[a].vars.id === i) return s[a];
    }),
    (t.remove = function (i) {
      return jt(i)
        ? this.removeLabel(i)
        : Ct(i)
        ? this.killTweensOf(i)
        : (uu(this, i),
          i === this._recent && (this._recent = this._last),
          ms(this));
    }),
    (t.totalTime = function (i, s) {
      return arguments.length
        ? ((this._forcing = 1),
          !this._dp &&
            this._ts &&
            (this._start = Zt(
              zn.time -
                (this._ts > 0
                  ? i / this._ts
                  : (this.totalDuration() - i) / -this._ts)
            )),
          r.prototype.totalTime.call(this, i, s),
          (this._forcing = 0),
          this)
        : this._tTime;
    }),
    (t.addLabel = function (i, s) {
      return (this.labels[i] = Yn(this, s)), this;
    }),
    (t.removeLabel = function (i) {
      return delete this.labels[i], this;
    }),
    (t.addPause = function (i, s, a) {
      var o = Ut.delayedCall(0, s || qo, a);
      return (
        (o.data = "isPause"), (this._hasPause = 1), Ri(this, o, Yn(this, i))
      );
    }),
    (t.removePause = function (i) {
      var s = this._first;
      for (i = Yn(this, i); s; )
        s._start === i && s.data === "isPause" && Nr(s), (s = s._next);
    }),
    (t.killTweensOf = function (i, s, a) {
      for (var o = this.getTweensOf(i, a), l = o.length; l--; )
        Mr !== o[l] && o[l].kill(i, s);
      return this;
    }),
    (t.getTweensOf = function (i, s) {
      for (var a = [], o = ni(i), l = this._first, c = lr(s), u; l; )
        l instanceof Ut
          ? qT(l._targets, o) &&
            (c
              ? (!Mr || (l._initted && l._ts)) &&
                l.globalTime(0) <= s &&
                l.globalTime(l.totalDuration()) > s
              : !s || l.isActive()) &&
            a.push(l)
          : (u = l.getTweensOf(o, s)).length && a.push.apply(a, u),
          (l = l._next);
      return a;
    }),
    (t.tweenTo = function (i, s) {
      s = s || {};
      var a = this,
        o = Yn(a, i),
        l = s,
        c = l.startAt,
        u = l.onStart,
        h = l.onStartParams,
        f = l.immediateRender,
        p,
        g = Ut.to(
          a,
          ai(
            {
              ease: s.ease || "none",
              lazy: !1,
              immediateRender: !1,
              time: o,
              overwrite: "auto",
              duration:
                s.duration ||
                Math.abs(
                  (o - (c && "time" in c ? c.time : a._time)) / a.timeScale()
                ) ||
                pt,
              onStart: function () {
                if ((a.pause(), !p)) {
                  var _ =
                    s.duration ||
                    Math.abs(
                      (o - (c && "time" in c ? c.time : a._time)) /
                        a.timeScale()
                    );
                  g._dur !== _ && Ga(g, _, 0, 1).render(g._time, !0, !0),
                    (p = 1);
                }
                u && u.apply(g, h || []);
              },
            },
            s
          )
        );
      return f ? g.render(0) : g;
    }),
    (t.tweenFromTo = function (i, s, a) {
      return this.tweenTo(s, ai({ startAt: { time: Yn(this, i) } }, a));
    }),
    (t.recent = function () {
      return this._recent;
    }),
    (t.nextLabel = function (i) {
      return i === void 0 && (i = this._time), bm(this, Yn(this, i));
    }),
    (t.previousLabel = function (i) {
      return i === void 0 && (i = this._time), bm(this, Yn(this, i), 1);
    }),
    (t.currentLabel = function (i) {
      return arguments.length
        ? this.seek(i, !0)
        : this.previousLabel(this._time + pt);
    }),
    (t.shiftChildren = function (i, s, a) {
      a === void 0 && (a = 0);
      for (var o = this._first, l = this.labels, c; o; )
        o._start >= a && ((o._start += i), (o._end += i)), (o = o._next);
      if (s) for (c in l) l[c] >= a && (l[c] += i);
      return ms(this);
    }),
    (t.invalidate = function (i) {
      var s = this._first;
      for (this._lock = 0; s; ) s.invalidate(i), (s = s._next);
      return r.prototype.invalidate.call(this, i);
    }),
    (t.clear = function (i) {
      i === void 0 && (i = !0);
      for (var s = this._first, a; s; ) (a = s._next), this.remove(s), (s = a);
      return (
        this._dp && (this._time = this._tTime = this._pTime = 0),
        i && (this.labels = {}),
        ms(this)
      );
    }),
    (t.totalDuration = function (i) {
      var s = 0,
        a = this,
        o = a._last,
        l = ti,
        c,
        u,
        h;
      if (arguments.length)
        return a.timeScale(
          (a._repeat < 0 ? a.duration() : a.totalDuration()) /
            (a.reversed() ? -i : i)
        );
      if (a._dirty) {
        for (h = a.parent; o; )
          (c = o._prev),
            o._dirty && o.totalDuration(),
            (u = o._start),
            u > l && a._sort && o._ts && !a._lock
              ? ((a._lock = 1), (Ri(a, o, u - o._delay, 1)._lock = 0))
              : (l = u),
            u < 0 &&
              o._ts &&
              ((s -= u),
              ((!h && !a._dp) || (h && h.smoothChildTiming)) &&
                ((a._start += u / a._ts), (a._time -= u), (a._tTime -= u)),
              a.shiftChildren(-u, !1, -1 / 0),
              (l = 0)),
            o._end > s && o._ts && (s = o._end),
            (o = c);
        Ga(a, a === Mt && a._time > s ? a._time : s, 1, 1), (a._dirty = 0);
      }
      return a._tDur;
    }),
    (e.updateRoot = function (i) {
      if ((Mt._ts && (Rg(Mt, Fc(i, Mt)), (Ag = zn.frame)), zn.frame >= ym)) {
        ym += Gn.autoSleep || 120;
        var s = Mt._first;
        if ((!s || !s._ts) && Gn.autoSleep && zn._listeners.length < 2) {
          for (; s && !s._ts; ) s = s._next;
          s || zn.sleep();
        }
      }
    }),
    e
  );
})($o);
ai(_n.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
var _A = function (e, t, n, i, s, a, o) {
    var l = new wn(this._pt, e, t, 0, 1, n0, null, s),
      c = 0,
      u = 0,
      h,
      f,
      p,
      g,
      m,
      _,
      d,
      y;
    for (
      l.b = n,
        l.e = i,
        n += "",
        i += "",
        (d = ~i.indexOf("random(")) && (i = jo(i)),
        a && ((y = [n, i]), a(y, e, t), (n = y[0]), (i = y[1])),
        f = n.match(ah) || [];
      (h = ah.exec(i));

    )
      (g = h[0]),
        (m = i.substring(c, h.index)),
        p ? (p = (p + 1) % 5) : m.substr(-5) === "rgba(" && (p = 1),
        g !== f[u++] &&
          ((_ = parseFloat(f[u - 1]) || 0),
          (l._pt = {
            _next: l._pt,
            p: m || u === 1 ? m : ",",
            s: _,
            c: g.charAt(1) === "=" ? Ta(_, g) - _ : parseFloat(g) - _,
            m: p && p < 4 ? Math.round : 0,
          }),
          (c = ah.lastIndex));
    return (
      (l.c = c < i.length ? i.substring(c, i.length) : ""),
      (l.fp = o),
      (Eg.test(i) || d) && (l.e = 0),
      (this._pt = l),
      l
    );
  },
  jf = function (e, t, n, i, s, a, o, l, c, u) {
    Ct(i) && (i = i(s || 0, e, a));
    var h = e[t],
      f =
        n !== "get"
          ? n
          : Ct(h)
          ? c
            ? e[
                t.indexOf("set") || !Ct(e["get" + t.substr(3)])
                  ? t
                  : "get" + t.substr(3)
              ](c)
            : e[t]()
          : h,
      p = Ct(h) ? (c ? EA : e0) : $f,
      g;
    if (
      (jt(i) &&
        (~i.indexOf("random(") && (i = jo(i)),
        i.charAt(1) === "=" &&
          ((g = Ta(f, i) + (sn(f) || 0)), (g || g === 0) && (i = g))),
      !u || f !== i || $h)
    )
      return !isNaN(f * i) && i !== ""
        ? ((g = new wn(
            this._pt,
            e,
            t,
            +f || 0,
            i - (f || 0),
            typeof h == "boolean" ? MA : t0,
            0,
            p
          )),
          c && (g.fp = c),
          o && g.modifier(o, this, e),
          (this._pt = g))
        : (!h && !(t in e) && Wf(t, i),
          _A.call(this, e, t, f, i, p, l || Gn.stringFilter, c));
  },
  gA = function (e, t, n, i, s) {
    if (
      (Ct(e) && (e = Co(e, s, t, n, i)),
      !Ui(e) || (e.style && e.nodeType) || on(e) || xg(e))
    )
      return jt(e) ? Co(e, s, t, n, i) : e;
    var a = {},
      o;
    for (o in e) a[o] = Co(e[o], s, t, n, i);
    return a;
  },
  Zg = function (e, t, n, i, s, a) {
    var o, l, c, u;
    if (
      kn[e] &&
      (o = new kn[e]()).init(
        s,
        o.rawVars ? t[e] : gA(t[e], i, s, a, n),
        n,
        i,
        a
      ) !== !1 &&
      ((n._pt = l = new wn(n._pt, s, e, 0, 1, o.render, o, 0, o.priority)),
      n !== ga)
    )
      for (c = n._ptLookup[n._targets.indexOf(s)], u = o._props.length; u--; )
        c[o._props[u]] = l;
    return o;
  },
  Mr,
  $h,
  Kf = function r(e, t, n) {
    var i = e.vars,
      s = i.ease,
      a = i.startAt,
      o = i.immediateRender,
      l = i.lazy,
      c = i.onUpdate,
      u = i.onUpdateParams,
      h = i.callbackScope,
      f = i.runBackwards,
      p = i.yoyoEase,
      g = i.keyframes,
      m = i.autoRevert,
      _ = e._dur,
      d = e._startAt,
      y = e._targets,
      v = e.parent,
      S = v && v.data === "nested" ? v.vars.targets : y,
      E = e._overwrite === "auto" && !zf,
      b = e.timeline,
      M,
      C,
      x,
      T,
      D,
      N,
      L,
      F,
      I,
      j,
      A,
      k,
      G;
    if (
      (b && (!g || !s) && (s = "none"),
      (e._ease = _s(s, Ha.ease)),
      (e._yEase = p ? qg(_s(p === !0 ? s : p, Ha.ease)) : 0),
      p &&
        e._yoyo &&
        !e._repeat &&
        ((p = e._yEase), (e._yEase = e._ease), (e._ease = p)),
      (e._from = !b && !!i.runBackwards),
      !b || (g && !i.stagger))
    ) {
      if (
        ((F = y[0] ? ps(y[0]).harness : 0),
        (k = F && i[F.prop]),
        (M = Uc(i, Xf)),
        d &&
          (d._zTime < 0 && d.progress(1),
          t < 0 && f && o && !m ? d.render(-1, !0) : d.revert(f && _ ? _c : XT),
          (d._lazy = 0)),
        a)
      ) {
        if (
          (Nr(
            (e._startAt = Ut.set(
              y,
              ai(
                {
                  data: "isStart",
                  overwrite: !1,
                  parent: v,
                  immediateRender: !0,
                  lazy: !d && Tn(l),
                  startAt: null,
                  delay: 0,
                  onUpdate: c,
                  onUpdateParams: u,
                  callbackScope: h,
                  stagger: 0,
                },
                a
              )
            ))
          ),
          (e._startAt._dp = 0),
          (e._startAt._sat = e),
          t < 0 && (an || (!o && !m)) && e._startAt.revert(_c),
          o && _ && t <= 0 && n <= 0)
        ) {
          t && (e._zTime = t);
          return;
        }
      } else if (f && _ && !d) {
        if (
          (t && (o = !1),
          (x = ai(
            {
              overwrite: !1,
              data: "isFromStart",
              lazy: o && !d && Tn(l),
              immediateRender: o,
              stagger: 0,
              parent: v,
            },
            M
          )),
          k && (x[F.prop] = k),
          Nr((e._startAt = Ut.set(y, x))),
          (e._startAt._dp = 0),
          (e._startAt._sat = e),
          t < 0 && (an ? e._startAt.revert(_c) : e._startAt.render(-1, !0)),
          (e._zTime = t),
          !o)
        )
          r(e._startAt, pt, pt);
        else if (!t) return;
      }
      for (
        e._pt = e._ptCache = 0, l = (_ && Tn(l)) || (l && !_), C = 0;
        C < y.length;
        C++
      ) {
        if (
          ((D = y[C]),
          (L = D._gsap || qf(y)[C]._gsap),
          (e._ptLookup[C] = j = {}),
          Wh[L.id] && Pr.length && Oc(),
          (A = S === y ? C : S.indexOf(D)),
          F &&
            (I = new F()).init(D, k || M, e, A, S) !== !1 &&
            ((e._pt = T =
              new wn(e._pt, D, I.name, 0, 1, I.render, I, 0, I.priority)),
            I._props.forEach(function (z) {
              j[z] = T;
            }),
            I.priority && (N = 1)),
          !F || k)
        )
          for (x in M)
            kn[x] && (I = Zg(x, M, e, A, D, S))
              ? I.priority && (N = 1)
              : (j[x] = T =
                  jf.call(e, D, x, "get", M[x], A, S, 0, i.stringFilter));
        e._op && e._op[C] && e.kill(D, e._op[C]),
          E &&
            e._pt &&
            ((Mr = e),
            Mt.killTweensOf(D, j, e.globalTime(t)),
            (G = !e.parent),
            (Mr = 0)),
          e._pt && l && (Wh[L.id] = 1);
      }
      N && i0(e), e._onInit && e._onInit(e);
    }
    (e._onUpdate = c),
      (e._initted = (!e._op || e._pt) && !G),
      g && t <= 0 && b.render(ti, !0, !0);
  },
  vA = function (e, t, n, i, s, a, o) {
    var l = ((e._pt && e._ptCache) || (e._ptCache = {}))[t],
      c,
      u,
      h,
      f;
    if (!l)
      for (
        l = e._ptCache[t] = [], h = e._ptLookup, f = e._targets.length;
        f--;

      ) {
        if (((c = h[f][t]), c && c.d && c.d._pt))
          for (c = c.d._pt; c && c.p !== t && c.fp !== t; ) c = c._next;
        if (!c) return ($h = 1), (e.vars[t] = "+=0"), Kf(e, o), ($h = 0), 1;
        l.push(c);
      }
    for (f = l.length; f--; )
      (u = l[f]),
        (c = u._pt || u),
        (c.s = (i || i === 0) && !s ? i : c.s + (i || 0) + a * c.c),
        (c.c = n - c.s),
        u.e && (u.e = Lt(n) + sn(u.e)),
        u.b && (u.b = c.s + sn(u.b));
  },
  xA = function (e, t) {
    var n = e[0] ? ps(e[0]).harness : 0,
      i = n && n.aliases,
      s,
      a,
      o,
      l;
    if (!i) return t;
    s = As({}, t);
    for (a in i)
      if (a in s) for (l = i[a].split(","), o = l.length; o--; ) s[l[o]] = s[a];
    return s;
  },
  yA = function (e, t, n, i) {
    var s = t.ease || i || "power1.inOut",
      a,
      o;
    if (on(t))
      (o = n[e] || (n[e] = [])),
        t.forEach(function (l, c) {
          return o.push({ t: (c / (t.length - 1)) * 100, v: l, e: s });
        });
    else
      for (a in t)
        (o = n[a] || (n[a] = [])),
          a === "ease" || o.push({ t: parseFloat(e), v: t[a], e: s });
  },
  Co = function (e, t, n, i, s) {
    return Ct(e)
      ? e.call(t, n, i, s)
      : jt(e) && ~e.indexOf("random(")
      ? jo(e)
      : e;
  },
  Jg = Yf + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
  Qg = {};
An(Jg + ",id,stagger,delay,duration,paused,scrollTrigger", function (r) {
  return (Qg[r] = 1);
});
var Ut = (function (r) {
  gg(e, r);
  function e(n, i, s, a) {
    var o;
    typeof i == "number" && ((s.duration = i), (i = s), (s = null)),
      (o = r.call(this, a ? i : wo(i)) || this);
    var l = o.vars,
      c = l.duration,
      u = l.delay,
      h = l.immediateRender,
      f = l.stagger,
      p = l.overwrite,
      g = l.keyframes,
      m = l.defaults,
      _ = l.scrollTrigger,
      d = l.yoyoEase,
      y = i.parent || Mt,
      v = (on(n) || xg(n) ? lr(n[0]) : "length" in i) ? [n] : ni(n),
      S,
      E,
      b,
      M,
      C,
      x,
      T,
      D;
    if (
      ((o._targets = v.length
        ? qf(v)
        : Nc(
            "GSAP target " + n + " not found. https://greensock.com",
            !Gn.nullTargetWarn
          ) || []),
      (o._ptLookup = []),
      (o._overwrite = p),
      g || f || Jl(c) || Jl(u))
    ) {
      if (
        ((i = o.vars),
        (S = o.timeline =
          new _n({
            data: "nested",
            defaults: m || {},
            targets: y && y.data === "nested" ? y.vars.targets : v,
          })),
        S.kill(),
        (S.parent = S._dp = Ki(o)),
        (S._start = 0),
        f || Jl(c) || Jl(u))
      ) {
        if (((M = v.length), (T = f && Fg(f)), Ui(f)))
          for (C in f) ~Jg.indexOf(C) && (D || (D = {}), (D[C] = f[C]));
        for (E = 0; E < M; E++)
          (b = Uc(i, Qg)),
            (b.stagger = 0),
            d && (b.yoyoEase = d),
            D && As(b, D),
            (x = v[E]),
            (b.duration = +Co(c, Ki(o), E, x, v)),
            (b.delay = (+Co(u, Ki(o), E, x, v) || 0) - o._delay),
            !f &&
              M === 1 &&
              b.delay &&
              ((o._delay = u = b.delay), (o._start += u), (b.delay = 0)),
            S.to(x, b, T ? T(E, x, v) : 0),
            (S._ease = rt.none);
        S.duration() ? (c = u = 0) : (o.timeline = 0);
      } else if (g) {
        wo(ai(S.vars.defaults, { ease: "none" })),
          (S._ease = _s(g.ease || i.ease || "none"));
        var N = 0,
          L,
          F,
          I;
        if (on(g))
          g.forEach(function (j) {
            return S.to(v, j, ">");
          }),
            S.duration();
        else {
          b = {};
          for (C in g)
            C === "ease" || C === "easeEach" || yA(C, g[C], b, g.easeEach);
          for (C in b)
            for (
              L = b[C].sort(function (j, A) {
                return j.t - A.t;
              }),
                N = 0,
                E = 0;
              E < L.length;
              E++
            )
              (F = L[E]),
                (I = {
                  ease: F.e,
                  duration: ((F.t - (E ? L[E - 1].t : 0)) / 100) * c,
                }),
                (I[C] = F.v),
                S.to(v, I, N),
                (N += I.duration);
          S.duration() < c && S.to({}, { duration: c - S.duration() });
        }
      }
      c || o.duration((c = S.duration()));
    } else o.timeline = 0;
    return (
      p === !0 && !zf && ((Mr = Ki(o)), Mt.killTweensOf(v), (Mr = 0)),
      Ri(y, Ki(o), s),
      i.reversed && o.reverse(),
      i.paused && o.paused(!0),
      (h ||
        (!c &&
          !g &&
          o._start === Zt(y._time) &&
          Tn(h) &&
          ZT(Ki(o)) &&
          y.data !== "nested")) &&
        ((o._tTime = -pt), o.render(Math.max(0, -u) || 0)),
      _ && Ig(Ki(o), _),
      o
    );
  }
  var t = e.prototype;
  return (
    (t.render = function (i, s, a) {
      var o = this._time,
        l = this._tDur,
        c = this._dur,
        u = i < 0,
        h = i > l - pt && !u ? l : i < pt ? 0 : i,
        f,
        p,
        g,
        m,
        _,
        d,
        y,
        v,
        S;
      if (!c) QT(this, i, s, a);
      else if (
        h !== this._tTime ||
        !i ||
        a ||
        (!this._initted && this._tTime) ||
        (this._startAt && this._zTime < 0 !== u)
      ) {
        if (((f = h), (v = this.timeline), this._repeat)) {
          if (((m = c + this._rDelay), this._repeat < -1 && u))
            return this.totalTime(m * 100 + i, s, a);
          if (
            ((f = Zt(h % m)),
            h === l
              ? ((g = this._repeat), (f = c))
              : ((g = ~~(h / m)),
                g && g === h / m && ((f = c), g--),
                f > c && (f = c)),
            (d = this._yoyo && g & 1),
            d && ((S = this._yEase), (f = c - f)),
            (_ = Va(this._tTime, m)),
            f === o && !a && this._initted)
          )
            return (this._tTime = h), this;
          g !== _ &&
            (v && this._yEase && jg(v, d),
            this.vars.repeatRefresh &&
              !d &&
              !this._lock &&
              ((this._lock = a = 1),
              (this.render(Zt(m * g), !0).invalidate()._lock = 0)));
        }
        if (!this._initted) {
          if (Ng(this, u ? i : f, a, s, h)) return (this._tTime = 0), this;
          if (o !== this._time) return this;
          if (c !== this._dur) return this.render(i, s, a);
        }
        if (
          ((this._tTime = h),
          (this._time = f),
          !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
          (this.ratio = y = (S || this._ease)(f / c)),
          this._from && (this.ratio = y = 1 - y),
          f && !o && !s && !g && (ii(this, "onStart"), this._tTime !== h))
        )
          return this;
        for (p = this._pt; p; ) p.r(y, p.d), (p = p._next);
        (v &&
          v.render(
            i < 0 ? i : !f && d ? -pt : v._dur * v._ease(f / this._dur),
            s,
            a
          )) ||
          (this._startAt && (this._zTime = i)),
          this._onUpdate &&
            !s &&
            (u && Xh(this, i, s, a), ii(this, "onUpdate")),
          this._repeat &&
            g !== _ &&
            this.vars.onRepeat &&
            !s &&
            this.parent &&
            ii(this, "onRepeat"),
          (h === this._tDur || !h) &&
            this._tTime === h &&
            (u && !this._onUpdate && Xh(this, i, !0, !0),
            (i || !c) &&
              ((h === this._tDur && this._ts > 0) || (!h && this._ts < 0)) &&
              Nr(this, 1),
            !s &&
              !(u && !o) &&
              (h || o || d) &&
              (ii(this, h === l ? "onComplete" : "onReverseComplete", !0),
              this._prom && !(h < l && this.timeScale() > 0) && this._prom()));
      }
      return this;
    }),
    (t.targets = function () {
      return this._targets;
    }),
    (t.invalidate = function (i) {
      return (
        (!i || !this.vars.runBackwards) && (this._startAt = 0),
        (this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0),
        (this._ptLookup = []),
        this.timeline && this.timeline.invalidate(i),
        r.prototype.invalidate.call(this, i)
      );
    }),
    (t.resetTo = function (i, s, a, o) {
      Ko || zn.wake(), this._ts || this.play();
      var l = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
        c;
      return (
        this._initted || Kf(this, l),
        (c = this._ease(l / this._dur)),
        vA(this, i, s, a, o, c, l)
          ? this.resetTo(i, s, a, o)
          : (fu(this, 0),
            this.parent ||
              Lg(
                this._dp,
                this,
                "_first",
                "_last",
                this._dp._sort ? "_start" : 0
              ),
            this.render(0))
      );
    }),
    (t.kill = function (i, s) {
      if ((s === void 0 && (s = "all"), !i && (!s || s === "all")))
        return (this._lazy = this._pt = 0), this.parent ? vo(this) : this;
      if (this.timeline) {
        var a = this.timeline.totalDuration();
        return (
          this.timeline.killTweensOf(i, s, Mr && Mr.vars.overwrite !== !0)
            ._first || vo(this),
          this.parent &&
            a !== this.timeline.totalDuration() &&
            Ga(this, (this._dur * this.timeline._tDur) / a, 0, 1),
          this
        );
      }
      var o = this._targets,
        l = i ? ni(i) : o,
        c = this._ptLookup,
        u = this._pt,
        h,
        f,
        p,
        g,
        m,
        _,
        d;
      if ((!s || s === "all") && KT(o, l))
        return s === "all" && (this._pt = 0), vo(this);
      for (
        h = this._op = this._op || [],
          s !== "all" &&
            (jt(s) &&
              ((m = {}),
              An(s, function (y) {
                return (m[y] = 1);
              }),
              (s = m)),
            (s = xA(o, s))),
          d = o.length;
        d--;

      )
        if (~l.indexOf(o[d])) {
          (f = c[d]),
            s === "all"
              ? ((h[d] = s), (g = f), (p = {}))
              : ((p = h[d] = h[d] || {}), (g = s));
          for (m in g)
            (_ = f && f[m]),
              _ &&
                ((!("kill" in _.d) || _.d.kill(m) === !0) && uu(this, _, "_pt"),
                delete f[m]),
              p !== "all" && (p[m] = 1);
        }
      return this._initted && !this._pt && u && vo(this), this;
    }),
    (e.to = function (i, s) {
      return new e(i, s, arguments[2]);
    }),
    (e.from = function (i, s) {
      return Ro(1, arguments);
    }),
    (e.delayedCall = function (i, s, a, o) {
      return new e(s, 0, {
        immediateRender: !1,
        lazy: !1,
        overwrite: !1,
        delay: i,
        onComplete: s,
        onReverseComplete: s,
        onCompleteParams: a,
        onReverseCompleteParams: a,
        callbackScope: o,
      });
    }),
    (e.fromTo = function (i, s, a) {
      return Ro(2, arguments);
    }),
    (e.set = function (i, s) {
      return (s.duration = 0), s.repeatDelay || (s.repeat = 0), new e(i, s);
    }),
    (e.killTweensOf = function (i, s, a) {
      return Mt.killTweensOf(i, s, a);
    }),
    e
  );
})($o);
ai(Ut.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 });
An("staggerTo,staggerFrom,staggerFromTo", function (r) {
  Ut[r] = function () {
    var e = new _n(),
      t = qh.call(arguments, 0);
    return t.splice(r === "staggerFromTo" ? 5 : 4, 0, 0), e[r].apply(e, t);
  };
});
var $f = function (e, t, n) {
    return (e[t] = n);
  },
  e0 = function (e, t, n) {
    return e[t](n);
  },
  EA = function (e, t, n, i) {
    return e[t](i.fp, n);
  },
  SA = function (e, t, n) {
    return e.setAttribute(t, n);
  },
  Zf = function (e, t) {
    return Ct(e[t]) ? e0 : Hf(e[t]) && e.setAttribute ? SA : $f;
  },
  t0 = function (e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t);
  },
  MA = function (e, t) {
    return t.set(t.t, t.p, !!(t.s + t.c * e), t);
  },
  n0 = function (e, t) {
    var n = t._pt,
      i = "";
    if (!e && t.b) i = t.b;
    else if (e === 1 && t.e) i = t.e;
    else {
      for (; n; )
        (i =
          n.p +
          (n.m ? n.m(n.s + n.c * e) : Math.round((n.s + n.c * e) * 1e4) / 1e4) +
          i),
          (n = n._next);
      i += t.c;
    }
    t.set(t.t, t.p, i, t);
  },
  Jf = function (e, t) {
    for (var n = t._pt; n; ) n.r(e, n.d), (n = n._next);
  },
  bA = function (e, t, n, i) {
    for (var s = this._pt, a; s; )
      (a = s._next), s.p === i && s.modifier(e, t, n), (s = a);
  },
  TA = function (e) {
    for (var t = this._pt, n, i; t; )
      (i = t._next),
        (t.p === e && !t.op) || t.op === e
          ? uu(this, t, "_pt")
          : t.dep || (n = 1),
        (t = i);
    return !n;
  },
  AA = function (e, t, n, i) {
    i.mSet(e, t, i.m.call(i.tween, n, i.mt), i);
  },
  i0 = function (e) {
    for (var t = e._pt, n, i, s, a; t; ) {
      for (n = t._next, i = s; i && i.pr > t.pr; ) i = i._next;
      (t._prev = i ? i._prev : a) ? (t._prev._next = t) : (s = t),
        (t._next = i) ? (i._prev = t) : (a = t),
        (t = n);
    }
    e._pt = s;
  },
  wn = (function () {
    function r(t, n, i, s, a, o, l, c, u) {
      (this.t = n),
        (this.s = s),
        (this.c = a),
        (this.p = i),
        (this.r = o || t0),
        (this.d = l || this),
        (this.set = c || $f),
        (this.pr = u || 0),
        (this._next = t),
        t && (t._prev = this);
    }
    var e = r.prototype;
    return (
      (e.modifier = function (n, i, s) {
        (this.mSet = this.mSet || this.set),
          (this.set = AA),
          (this.m = n),
          (this.mt = s),
          (this.tween = i);
      }),
      r
    );
  })();
An(
  Yf +
    "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
  function (r) {
    return (Xf[r] = 1);
  }
);
Wn.TweenMax = Wn.TweenLite = Ut;
Wn.TimelineLite = Wn.TimelineMax = _n;
Mt = new _n({
  sortChildren: !1,
  defaults: Ha,
  autoRemoveChildren: !0,
  id: "root",
  smoothChildTiming: !0,
});
Gn.stringFilter = Yg;
var gs = [],
  vc = {},
  wA = [],
  Am = 0,
  RA = 0,
  hh = function (e) {
    return (vc[e] || wA).map(function (t) {
      return t();
    });
  },
  Zh = function () {
    var e = Date.now(),
      t = [];
    e - Am > 2 &&
      (hh("matchMediaInit"),
      gs.forEach(function (n) {
        var i = n.queries,
          s = n.conditions,
          a,
          o,
          l,
          c;
        for (o in i)
          (a = qn.matchMedia(i[o]).matches),
            a && (l = 1),
            a !== s[o] && ((s[o] = a), (c = 1));
        c && (n.revert(), l && t.push(n));
      }),
      hh("matchMediaRevert"),
      t.forEach(function (n) {
        return n.onMatch(n);
      }),
      (Am = e),
      hh("matchMedia"));
  },
  r0 = (function () {
    function r(t, n) {
      (this.selector = n && jh(n)),
        (this.data = []),
        (this._r = []),
        (this.isReverted = !1),
        (this.id = RA++),
        t && this.add(t);
    }
    var e = r.prototype;
    return (
      (e.add = function (n, i, s) {
        Ct(n) && ((s = i), (i = n), (n = Ct));
        var a = this,
          o = function () {
            var c = Rt,
              u = a.selector,
              h;
            return (
              c && c !== a && c.data.push(a),
              s && (a.selector = jh(s)),
              (Rt = a),
              (h = i.apply(a, arguments)),
              Ct(h) && a._r.push(h),
              (Rt = c),
              (a.selector = u),
              (a.isReverted = !1),
              h
            );
          };
        return (a.last = o), n === Ct ? o(a) : n ? (a[n] = o) : o;
      }),
      (e.ignore = function (n) {
        var i = Rt;
        (Rt = null), n(this), (Rt = i);
      }),
      (e.getTweens = function () {
        var n = [];
        return (
          this.data.forEach(function (i) {
            return i instanceof r
              ? n.push.apply(n, i.getTweens())
              : i instanceof Ut &&
                  !(i.parent && i.parent.data === "nested") &&
                  n.push(i);
          }),
          n
        );
      }),
      (e.clear = function () {
        this._r.length = this.data.length = 0;
      }),
      (e.kill = function (n, i) {
        var s = this;
        if (n) {
          var a = this.getTweens();
          this.data.forEach(function (l) {
            l.data === "isFlip" &&
              (l.revert(),
              l.getChildren(!0, !0, !1).forEach(function (c) {
                return a.splice(a.indexOf(c), 1);
              }));
          }),
            a
              .map(function (l) {
                return { g: l.globalTime(0), t: l };
              })
              .sort(function (l, c) {
                return c.g - l.g || -1;
              })
              .forEach(function (l) {
                return l.t.revert(n);
              }),
            this.data.forEach(function (l) {
              return l instanceof _n
                ? l.data !== "nested" && l.kill()
                : !(l instanceof Ut) && l.revert && l.revert(n);
            }),
            this._r.forEach(function (l) {
              return l(n, s);
            }),
            (this.isReverted = !0);
        } else
          this.data.forEach(function (l) {
            return l.kill && l.kill();
          });
        if ((this.clear(), i))
          for (var o = gs.length; o--; )
            gs[o].id === this.id && gs.splice(o, 1);
      }),
      (e.revert = function (n) {
        this.kill(n || {});
      }),
      r
    );
  })(),
  CA = (function () {
    function r(t) {
      (this.contexts = []), (this.scope = t);
    }
    var e = r.prototype;
    return (
      (e.add = function (n, i, s) {
        Ui(n) || (n = { matches: n });
        var a = new r0(0, s || this.scope),
          o = (a.conditions = {}),
          l,
          c,
          u;
        Rt && !a.selector && (a.selector = Rt.selector),
          this.contexts.push(a),
          (i = a.add("onMatch", i)),
          (a.queries = n);
        for (c in n)
          c === "all"
            ? (u = 1)
            : ((l = qn.matchMedia(n[c])),
              l &&
                (gs.indexOf(a) < 0 && gs.push(a),
                (o[c] = l.matches) && (u = 1),
                l.addListener
                  ? l.addListener(Zh)
                  : l.addEventListener("change", Zh)));
        return u && i(a), this;
      }),
      (e.revert = function (n) {
        this.kill(n || {});
      }),
      (e.kill = function (n) {
        this.contexts.forEach(function (i) {
          return i.kill(n, !0);
        });
      }),
      r
    );
  })(),
  Bc = {
    registerPlugin: function () {
      for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
        t[n] = arguments[n];
      t.forEach(function (i) {
        return Gg(i);
      });
    },
    timeline: function (e) {
      return new _n(e);
    },
    getTweensOf: function (e, t) {
      return Mt.getTweensOf(e, t);
    },
    getProperty: function (e, t, n, i) {
      jt(e) && (e = ni(e)[0]);
      var s = ps(e || {}).get,
        a = n ? Pg : Cg;
      return (
        n === "native" && (n = ""),
        e &&
          (t
            ? a(((kn[t] && kn[t].get) || s)(e, t, n, i))
            : function (o, l, c) {
                return a(((kn[o] && kn[o].get) || s)(e, o, l, c));
              })
      );
    },
    quickSetter: function (e, t, n) {
      if (((e = ni(e)), e.length > 1)) {
        var i = e.map(function (u) {
            return Rn.quickSetter(u, t, n);
          }),
          s = i.length;
        return function (u) {
          for (var h = s; h--; ) i[h](u);
        };
      }
      e = e[0] || {};
      var a = kn[t],
        o = ps(e),
        l = (o.harness && (o.harness.aliases || {})[t]) || t,
        c = a
          ? function (u) {
              var h = new a();
              (ga._pt = 0),
                h.init(e, n ? u + n : u, ga, 0, [e]),
                h.render(1, h),
                ga._pt && Jf(1, ga);
            }
          : o.set(e, l);
      return a
        ? c
        : function (u) {
            return c(e, l, n ? u + n : u, o, 1);
          };
    },
    quickTo: function (e, t, n) {
      var i,
        s = Rn.to(
          e,
          As(((i = {}), (i[t] = "+=0.1"), (i.paused = !0), i), n || {})
        ),
        a = function (l, c, u) {
          return s.resetTo(t, l, c, u);
        };
      return (a.tween = s), a;
    },
    isTweening: function (e) {
      return Mt.getTweensOf(e, !0).length > 0;
    },
    defaults: function (e) {
      return e && e.ease && (e.ease = _s(e.ease, Ha.ease)), Em(Ha, e || {});
    },
    config: function (e) {
      return Em(Gn, e || {});
    },
    registerEffect: function (e) {
      var t = e.name,
        n = e.effect,
        i = e.plugins,
        s = e.defaults,
        a = e.extendTimeline;
      (i || "").split(",").forEach(function (o) {
        return (
          o && !kn[o] && !Wn[o] && Nc(t + " effect requires " + o + " plugin.")
        );
      }),
        (oh[t] = function (o, l, c) {
          return n(ni(o), ai(l || {}, s), c);
        }),
        a &&
          (_n.prototype[t] = function (o, l, c) {
            return this.add(oh[t](o, Ui(l) ? l : (c = l) && {}, this), c);
          });
    },
    registerEase: function (e, t) {
      rt[e] = _s(t);
    },
    parseEase: function (e, t) {
      return arguments.length ? _s(e, t) : rt;
    },
    getById: function (e) {
      return Mt.getById(e);
    },
    exportRoot: function (e, t) {
      e === void 0 && (e = {});
      var n = new _n(e),
        i,
        s;
      for (
        n.smoothChildTiming = Tn(e.smoothChildTiming),
          Mt.remove(n),
          n._dp = 0,
          n._time = n._tTime = Mt._time,
          i = Mt._first;
        i;

      )
        (s = i._next),
          (t ||
            !(
              !i._dur &&
              i instanceof Ut &&
              i.vars.onComplete === i._targets[0]
            )) &&
            Ri(n, i, i._start - i._delay),
          (i = s);
      return Ri(Mt, n, 0), n;
    },
    context: function (e, t) {
      return e ? new r0(e, t) : Rt;
    },
    matchMedia: function (e) {
      return new CA(e);
    },
    matchMediaRefresh: function () {
      return (
        gs.forEach(function (e) {
          var t = e.conditions,
            n,
            i;
          for (i in t) t[i] && ((t[i] = !1), (n = 1));
          n && e.revert();
        }) || Zh()
      );
    },
    addEventListener: function (e, t) {
      var n = vc[e] || (vc[e] = []);
      ~n.indexOf(t) || n.push(t);
    },
    removeEventListener: function (e, t) {
      var n = vc[e],
        i = n && n.indexOf(t);
      i >= 0 && n.splice(i, 1);
    },
    utils: {
      wrap: oA,
      wrapYoyo: lA,
      distribute: Fg,
      random: kg,
      snap: Bg,
      normalize: aA,
      getUnit: sn,
      clamp: nA,
      splitColor: Wg,
      toArray: ni,
      selector: jh,
      mapRange: Hg,
      pipe: rA,
      unitize: sA,
      interpolate: cA,
      shuffle: Ug,
    },
    install: bg,
    effects: oh,
    ticker: zn,
    updateRoot: _n.updateRoot,
    plugins: kn,
    globalTimeline: Mt,
    core: {
      PropTween: wn,
      globals: Tg,
      Tween: Ut,
      Timeline: _n,
      Animation: $o,
      getCache: ps,
      _removeLinkedListItem: uu,
      reverting: function () {
        return an;
      },
      context: function (e) {
        return e && Rt && (Rt.data.push(e), (e._ctx = Rt)), Rt;
      },
      suppressOverwrites: function (e) {
        return (zf = e);
      },
    },
  };
An("to,from,fromTo,delayedCall,set,killTweensOf", function (r) {
  return (Bc[r] = Ut[r]);
});
zn.add(_n.updateRoot);
ga = Bc.to({}, { duration: 0 });
var PA = function (e, t) {
    for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t; )
      n = n._next;
    return n;
  },
  LA = function (e, t) {
    var n = e._targets,
      i,
      s,
      a;
    for (i in t)
      for (s = n.length; s--; )
        (a = e._ptLookup[s][i]),
          a &&
            (a = a.d) &&
            (a._pt && (a = PA(a, i)),
            a && a.modifier && a.modifier(t[i], e, n[s], i));
  },
  fh = function (e, t) {
    return {
      name: e,
      rawVars: 1,
      init: function (i, s, a) {
        a._onInit = function (o) {
          var l, c;
          if (
            (jt(s) &&
              ((l = {}),
              An(s, function (u) {
                return (l[u] = 1);
              }),
              (s = l)),
            t)
          ) {
            l = {};
            for (c in s) l[c] = t(s[c]);
            s = l;
          }
          LA(o, s);
        };
      },
    };
  },
  Rn =
    Bc.registerPlugin(
      {
        name: "attr",
        init: function (e, t, n, i, s) {
          var a, o, l;
          this.tween = n;
          for (a in t)
            (l = e.getAttribute(a) || ""),
              (o = this.add(
                e,
                "setAttribute",
                (l || 0) + "",
                t[a],
                i,
                s,
                0,
                0,
                a
              )),
              (o.op = a),
              (o.b = l),
              this._props.push(a);
        },
        render: function (e, t) {
          for (var n = t._pt; n; )
            an ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d), (n = n._next);
        },
      },
      {
        name: "endArray",
        init: function (e, t) {
          for (var n = t.length; n--; )
            this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1);
        },
      },
      fh("roundProps", Kh),
      fh("modifiers"),
      fh("snap", Bg)
    ) || Bc;
Ut.version = _n.version = Rn.version = "3.12.1";
Mg = 1;
Vf() && Wa();
rt.Power0;
rt.Power1;
rt.Power2;
rt.Power3;
rt.Power4;
rt.Linear;
rt.Quad;
rt.Cubic;
rt.Quart;
rt.Quint;
rt.Strong;
rt.Elastic;
rt.Back;
rt.SteppedEase;
rt.Bounce;
rt.Sine;
rt.Expo;
rt.Circ;
/*!
 * CSSPlugin 3.12.1
 * https://greensock.com
 *
 * Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ var wm,
  br,
  Aa,
  Qf,
  cs,
  Rm,
  ed,
  DA = function () {
    return typeof window < "u";
  },
  cr = {},
  is = 180 / Math.PI,
  wa = Math.PI / 180,
  ra = Math.atan2,
  Cm = 1e8,
  td = /([A-Z])/g,
  IA = /(left|right|width|margin|padding|x)/i,
  NA = /[\s,\(]\S/,
  Ci = {
    autoAlpha: "opacity,visibility",
    scale: "scaleX,scaleY",
    alpha: "opacity",
  },
  Jh = function (e, t) {
    return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t);
  },
  OA = function (e, t) {
    return t.set(
      t.t,
      t.p,
      e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u,
      t
    );
  },
  UA = function (e, t) {
    return t.set(
      t.t,
      t.p,
      e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b,
      t
    );
  },
  FA = function (e, t) {
    var n = t.s + t.c * e;
    t.set(t.t, t.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + t.u, t);
  },
  s0 = function (e, t) {
    return t.set(t.t, t.p, e ? t.e : t.b, t);
  },
  a0 = function (e, t) {
    return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t);
  },
  BA = function (e, t, n) {
    return (e.style[t] = n);
  },
  kA = function (e, t, n) {
    return e.style.setProperty(t, n);
  },
  zA = function (e, t, n) {
    return (e._gsap[t] = n);
  },
  HA = function (e, t, n) {
    return (e._gsap.scaleX = e._gsap.scaleY = n);
  },
  VA = function (e, t, n, i, s) {
    var a = e._gsap;
    (a.scaleX = a.scaleY = n), a.renderTransform(s, a);
  },
  GA = function (e, t, n, i, s) {
    var a = e._gsap;
    (a[t] = n), a.renderTransform(s, a);
  },
  bt = "transform",
  vi = bt + "Origin",
  WA = function r(e, t) {
    var n = this,
      i = this.target,
      s = i.style;
    if (e in cr && s) {
      if (((this.tfm = this.tfm || {}), e !== "transform"))
        (e = Ci[e] || e),
          ~e.indexOf(",")
            ? e.split(",").forEach(function (a) {
                return (n.tfm[a] = $i(i, a));
              })
            : (this.tfm[e] = i._gsap.x ? i._gsap[e] : $i(i, e));
      else
        return Ci.transform.split(",").forEach(function (a) {
          return r.call(n, a, t);
        });
      if (this.props.indexOf(bt) >= 0) return;
      i._gsap.svg &&
        ((this.svgo = i.getAttribute("data-svg-origin")),
        this.props.push(vi, t, "")),
        (e = bt);
    }
    (s || t) && this.props.push(e, t, s[e]);
  },
  o0 = function (e) {
    e.translate &&
      (e.removeProperty("translate"),
      e.removeProperty("scale"),
      e.removeProperty("rotate"));
  },
  XA = function () {
    var e = this.props,
      t = this.target,
      n = t.style,
      i = t._gsap,
      s,
      a;
    for (s = 0; s < e.length; s += 3)
      e[s + 1]
        ? (t[e[s]] = e[s + 2])
        : e[s + 2]
        ? (n[e[s]] = e[s + 2])
        : n.removeProperty(
            e[s].substr(0, 2) === "--"
              ? e[s]
              : e[s].replace(td, "-$1").toLowerCase()
          );
    if (this.tfm) {
      for (a in this.tfm) i[a] = this.tfm[a];
      i.svg &&
        (i.renderTransform(),
        t.setAttribute("data-svg-origin", this.svgo || "")),
        (s = ed()),
        (!s || !s.isStart) && !n[bt] && (o0(n), (i.uncache = 1));
    }
  },
  l0 = function (e, t) {
    var n = { target: e, props: [], revert: XA, save: WA };
    return (
      e._gsap || Rn.core.getCache(e),
      t &&
        t.split(",").forEach(function (i) {
          return n.save(i);
        }),
      n
    );
  },
  c0,
  Qh = function (e, t) {
    var n = br.createElementNS
      ? br.createElementNS(
          (t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
          e
        )
      : br.createElement(e);
    return n.style ? n : br.createElement(e);
  },
  Li = function r(e, t, n) {
    var i = getComputedStyle(e);
    return (
      i[t] ||
      i.getPropertyValue(t.replace(td, "-$1").toLowerCase()) ||
      i.getPropertyValue(t) ||
      (!n && r(e, Xa(t) || t, 1)) ||
      ""
    );
  },
  Pm = "O,Moz,ms,Ms,Webkit".split(","),
  Xa = function (e, t, n) {
    var i = t || cs,
      s = i.style,
      a = 5;
    if (e in s && !n) return e;
    for (
      e = e.charAt(0).toUpperCase() + e.substr(1);
      a-- && !(Pm[a] + e in s);

    );
    return a < 0 ? null : (a === 3 ? "ms" : a >= 0 ? Pm[a] : "") + e;
  },
  ef = function () {
    DA() &&
      window.document &&
      ((wm = window),
      (br = wm.document),
      (Aa = br.documentElement),
      (cs = Qh("div") || { style: {} }),
      Qh("div"),
      (bt = Xa(bt)),
      (vi = bt + "Origin"),
      (cs.style.cssText =
        "border-width:0;line-height:0;position:absolute;padding:0"),
      (c0 = !!Xa("perspective")),
      (ed = Rn.core.reverting),
      (Qf = 1));
  },
  dh = function r(e) {
    var t = Qh(
        "svg",
        (this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns")) ||
          "http://www.w3.org/2000/svg"
      ),
      n = this.parentNode,
      i = this.nextSibling,
      s = this.style.cssText,
      a;
    if (
      (Aa.appendChild(t),
      t.appendChild(this),
      (this.style.display = "block"),
      e)
    )
      try {
        (a = this.getBBox()),
          (this._gsapBBox = this.getBBox),
          (this.getBBox = r);
      } catch {}
    else this._gsapBBox && (a = this._gsapBBox());
    return (
      n && (i ? n.insertBefore(this, i) : n.appendChild(this)),
      Aa.removeChild(t),
      (this.style.cssText = s),
      a
    );
  },
  Lm = function (e, t) {
    for (var n = t.length; n--; )
      if (e.hasAttribute(t[n])) return e.getAttribute(t[n]);
  },
  u0 = function (e) {
    var t;
    try {
      t = e.getBBox();
    } catch {
      t = dh.call(e, !0);
    }
    return (
      (t && (t.width || t.height)) || e.getBBox === dh || (t = dh.call(e, !0)),
      t && !t.width && !t.x && !t.y
        ? {
            x: +Lm(e, ["x", "cx", "x1"]) || 0,
            y: +Lm(e, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0,
          }
        : t
    );
  },
  h0 = function (e) {
    return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && u0(e));
  },
  Zo = function (e, t) {
    if (t) {
      var n = e.style;
      t in cr && t !== vi && (t = bt),
        n.removeProperty
          ? ((t.substr(0, 2) === "ms" || t.substr(0, 6) === "webkit") &&
              (t = "-" + t),
            n.removeProperty(t.replace(td, "-$1").toLowerCase()))
          : n.removeAttribute(t);
    }
  },
  Tr = function (e, t, n, i, s, a) {
    var o = new wn(e._pt, t, n, 0, 1, a ? a0 : s0);
    return (e._pt = o), (o.b = i), (o.e = s), e._props.push(n), o;
  },
  Dm = { deg: 1, rad: 1, turn: 1 },
  YA = { grid: 1, flex: 1 },
  Or = function r(e, t, n, i) {
    var s = parseFloat(n) || 0,
      a = (n + "").trim().substr((s + "").length) || "px",
      o = cs.style,
      l = IA.test(t),
      c = e.tagName.toLowerCase() === "svg",
      u = (c ? "client" : "offset") + (l ? "Width" : "Height"),
      h = 100,
      f = i === "px",
      p = i === "%",
      g,
      m,
      _,
      d;
    return i === a || !s || Dm[i] || Dm[a]
      ? s
      : (a !== "px" && !f && (s = r(e, t, n, "px")),
        (d = e.getCTM && h0(e)),
        (p || a === "%") && (cr[t] || ~t.indexOf("adius"))
          ? ((g = d ? e.getBBox()[l ? "width" : "height"] : e[u]),
            Lt(p ? (s / g) * h : (s / 100) * g))
          : ((o[l ? "width" : "height"] = h + (f ? a : i)),
            (m =
              ~t.indexOf("adius") || (i === "em" && e.appendChild && !c)
                ? e
                : e.parentNode),
            d && (m = (e.ownerSVGElement || {}).parentNode),
            (!m || m === br || !m.appendChild) && (m = br.body),
            (_ = m._gsap),
            _ && p && _.width && l && _.time === zn.time && !_.uncache
              ? Lt((s / _.width) * h)
              : ((p || a === "%") &&
                  !YA[Li(m, "display")] &&
                  (o.position = Li(e, "position")),
                m === e && (o.position = "static"),
                m.appendChild(cs),
                (g = cs[u]),
                m.removeChild(cs),
                (o.position = "absolute"),
                l && p && ((_ = ps(m)), (_.time = zn.time), (_.width = m[u])),
                Lt(f ? (g * s) / h : g && s ? (h / g) * s : 0))));
  },
  $i = function (e, t, n, i) {
    var s;
    return (
      Qf || ef(),
      t in Ci &&
        t !== "transform" &&
        ((t = Ci[t]), ~t.indexOf(",") && (t = t.split(",")[0])),
      cr[t] && t !== "transform"
        ? ((s = Qo(e, i)),
          (s =
            t !== "transformOrigin"
              ? s[t]
              : s.svg
              ? s.origin
              : zc(Li(e, vi)) + " " + s.zOrigin + "px"))
        : ((s = e.style[t]),
          (!s || s === "auto" || i || ~(s + "").indexOf("calc(")) &&
            (s =
              (kc[t] && kc[t](e, t, n)) ||
              Li(e, t) ||
              wg(e, t) ||
              (t === "opacity" ? 1 : 0))),
      n && !~(s + "").trim().indexOf(" ") ? Or(e, t, s, n) + n : s
    );
  },
  qA = function (e, t, n, i) {
    if (!n || n === "none") {
      var s = Xa(t, e, 1),
        a = s && Li(e, s, 1);
      a && a !== n
        ? ((t = s), (n = a))
        : t === "borderColor" && (n = Li(e, "borderTopColor"));
    }
    var o = new wn(this._pt, e.style, t, 0, 1, n0),
      l = 0,
      c = 0,
      u,
      h,
      f,
      p,
      g,
      m,
      _,
      d,
      y,
      v,
      S,
      E;
    if (
      ((o.b = n),
      (o.e = i),
      (n += ""),
      (i += ""),
      i === "auto" && ((e.style[t] = i), (i = Li(e, t) || i), (e.style[t] = n)),
      (u = [n, i]),
      Yg(u),
      (n = u[0]),
      (i = u[1]),
      (f = n.match(_a) || []),
      (E = i.match(_a) || []),
      E.length)
    ) {
      for (; (h = _a.exec(i)); )
        (_ = h[0]),
          (y = i.substring(l, h.index)),
          g
            ? (g = (g + 1) % 5)
            : (y.substr(-5) === "rgba(" || y.substr(-5) === "hsla(") && (g = 1),
          _ !== (m = f[c++] || "") &&
            ((p = parseFloat(m) || 0),
            (S = m.substr((p + "").length)),
            _.charAt(1) === "=" && (_ = Ta(p, _) + S),
            (d = parseFloat(_)),
            (v = _.substr((d + "").length)),
            (l = _a.lastIndex - v.length),
            v ||
              ((v = v || Gn.units[t] || S),
              l === i.length && ((i += v), (o.e += v))),
            S !== v && (p = Or(e, t, m, v) || 0),
            (o._pt = {
              _next: o._pt,
              p: y || c === 1 ? y : ",",
              s: p,
              c: d - p,
              m: (g && g < 4) || t === "zIndex" ? Math.round : 0,
            }));
      o.c = l < i.length ? i.substring(l, i.length) : "";
    } else o.r = t === "display" && i === "none" ? a0 : s0;
    return Eg.test(i) && (o.e = 0), (this._pt = o), o;
  },
  Im = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" },
  jA = function (e) {
    var t = e.split(" "),
      n = t[0],
      i = t[1] || "50%";
    return (
      (n === "top" || n === "bottom" || i === "left" || i === "right") &&
        ((e = n), (n = i), (i = e)),
      (t[0] = Im[n] || n),
      (t[1] = Im[i] || i),
      t.join(" ")
    );
  },
  KA = function (e, t) {
    if (t.tween && t.tween._time === t.tween._dur) {
      var n = t.t,
        i = n.style,
        s = t.u,
        a = n._gsap,
        o,
        l,
        c;
      if (s === "all" || s === !0) (i.cssText = ""), (l = 1);
      else
        for (s = s.split(","), c = s.length; --c > -1; )
          (o = s[c]),
            cr[o] && ((l = 1), (o = o === "transformOrigin" ? vi : bt)),
            Zo(n, o);
      l &&
        (Zo(n, bt),
        a &&
          (a.svg && n.removeAttribute("transform"),
          Qo(n, 1),
          (a.uncache = 1),
          o0(i)));
    }
  },
  kc = {
    clearProps: function (e, t, n, i, s) {
      if (s.data !== "isFromStart") {
        var a = (e._pt = new wn(e._pt, t, n, 0, 0, KA));
        return (a.u = i), (a.pr = -10), (a.tween = s), e._props.push(n), 1;
      }
    },
  },
  Jo = [1, 0, 0, 1, 0, 0],
  f0 = {},
  d0 = function (e) {
    return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e;
  },
  Nm = function (e) {
    var t = Li(e, bt);
    return d0(t) ? Jo : t.substr(7).match(yg).map(Lt);
  },
  nd = function (e, t) {
    var n = e._gsap || ps(e),
      i = e.style,
      s = Nm(e),
      a,
      o,
      l,
      c;
    return n.svg && e.getAttribute("transform")
      ? ((l = e.transform.baseVal.consolidate().matrix),
        (s = [l.a, l.b, l.c, l.d, l.e, l.f]),
        s.join(",") === "1,0,0,1,0,0" ? Jo : s)
      : (s === Jo &&
          !e.offsetParent &&
          e !== Aa &&
          !n.svg &&
          ((l = i.display),
          (i.display = "block"),
          (a = e.parentNode),
          (!a || !e.offsetParent) &&
            ((c = 1), (o = e.nextElementSibling), Aa.appendChild(e)),
          (s = Nm(e)),
          l ? (i.display = l) : Zo(e, "display"),
          c &&
            (o
              ? a.insertBefore(e, o)
              : a
              ? a.appendChild(e)
              : Aa.removeChild(e))),
        t && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s);
  },
  tf = function (e, t, n, i, s, a) {
    var o = e._gsap,
      l = s || nd(e, !0),
      c = o.xOrigin || 0,
      u = o.yOrigin || 0,
      h = o.xOffset || 0,
      f = o.yOffset || 0,
      p = l[0],
      g = l[1],
      m = l[2],
      _ = l[3],
      d = l[4],
      y = l[5],
      v = t.split(" "),
      S = parseFloat(v[0]) || 0,
      E = parseFloat(v[1]) || 0,
      b,
      M,
      C,
      x;
    n
      ? l !== Jo &&
        (M = p * _ - g * m) &&
        ((C = S * (_ / M) + E * (-m / M) + (m * y - _ * d) / M),
        (x = S * (-g / M) + E * (p / M) - (p * y - g * d) / M),
        (S = C),
        (E = x))
      : ((b = u0(e)),
        (S = b.x + (~v[0].indexOf("%") ? (S / 100) * b.width : S)),
        (E = b.y + (~(v[1] || v[0]).indexOf("%") ? (E / 100) * b.height : E))),
      i || (i !== !1 && o.smooth)
        ? ((d = S - c),
          (y = E - u),
          (o.xOffset = h + (d * p + y * m) - d),
          (o.yOffset = f + (d * g + y * _) - y))
        : (o.xOffset = o.yOffset = 0),
      (o.xOrigin = S),
      (o.yOrigin = E),
      (o.smooth = !!i),
      (o.origin = t),
      (o.originIsAbsolute = !!n),
      (e.style[vi] = "0px 0px"),
      a &&
        (Tr(a, o, "xOrigin", c, S),
        Tr(a, o, "yOrigin", u, E),
        Tr(a, o, "xOffset", h, o.xOffset),
        Tr(a, o, "yOffset", f, o.yOffset)),
      e.setAttribute("data-svg-origin", S + " " + E);
  },
  Qo = function (e, t) {
    var n = e._gsap || new $g(e);
    if ("x" in n && !t && !n.uncache) return n;
    var i = e.style,
      s = n.scaleX < 0,
      a = "px",
      o = "deg",
      l = getComputedStyle(e),
      c = Li(e, vi) || "0",
      u,
      h,
      f,
      p,
      g,
      m,
      _,
      d,
      y,
      v,
      S,
      E,
      b,
      M,
      C,
      x,
      T,
      D,
      N,
      L,
      F,
      I,
      j,
      A,
      k,
      G,
      z,
      oe,
      te,
      X,
      Y,
      le;
    return (
      (u = h = f = m = _ = d = y = v = S = 0),
      (p = g = 1),
      (n.svg = !!(e.getCTM && h0(e))),
      l.translate &&
        ((l.translate !== "none" ||
          l.scale !== "none" ||
          l.rotate !== "none") &&
          (i[bt] =
            (l.translate !== "none"
              ? "translate3d(" +
                (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") +
                ") "
              : "") +
            (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") +
            (l.scale !== "none"
              ? "scale(" + l.scale.split(" ").join(",") + ") "
              : "") +
            (l[bt] !== "none" ? l[bt] : "")),
        (i.scale = i.rotate = i.translate = "none")),
      (M = nd(e, n.svg)),
      n.svg &&
        (n.uncache
          ? ((k = e.getBBox()),
            (c = n.xOrigin - k.x + "px " + (n.yOrigin - k.y) + "px"),
            (A = ""))
          : (A = !t && e.getAttribute("data-svg-origin")),
        tf(e, A || c, !!A || n.originIsAbsolute, n.smooth !== !1, M)),
      (E = n.xOrigin || 0),
      (b = n.yOrigin || 0),
      M !== Jo &&
        ((D = M[0]),
        (N = M[1]),
        (L = M[2]),
        (F = M[3]),
        (u = I = M[4]),
        (h = j = M[5]),
        M.length === 6
          ? ((p = Math.sqrt(D * D + N * N)),
            (g = Math.sqrt(F * F + L * L)),
            (m = D || N ? ra(N, D) * is : 0),
            (y = L || F ? ra(L, F) * is + m : 0),
            y && (g *= Math.abs(Math.cos(y * wa))),
            n.svg && ((u -= E - (E * D + b * L)), (h -= b - (E * N + b * F))))
          : ((le = M[6]),
            (X = M[7]),
            (z = M[8]),
            (oe = M[9]),
            (te = M[10]),
            (Y = M[11]),
            (u = M[12]),
            (h = M[13]),
            (f = M[14]),
            (C = ra(le, te)),
            (_ = C * is),
            C &&
              ((x = Math.cos(-C)),
              (T = Math.sin(-C)),
              (A = I * x + z * T),
              (k = j * x + oe * T),
              (G = le * x + te * T),
              (z = I * -T + z * x),
              (oe = j * -T + oe * x),
              (te = le * -T + te * x),
              (Y = X * -T + Y * x),
              (I = A),
              (j = k),
              (le = G)),
            (C = ra(-L, te)),
            (d = C * is),
            C &&
              ((x = Math.cos(-C)),
              (T = Math.sin(-C)),
              (A = D * x - z * T),
              (k = N * x - oe * T),
              (G = L * x - te * T),
              (Y = F * T + Y * x),
              (D = A),
              (N = k),
              (L = G)),
            (C = ra(N, D)),
            (m = C * is),
            C &&
              ((x = Math.cos(C)),
              (T = Math.sin(C)),
              (A = D * x + N * T),
              (k = I * x + j * T),
              (N = N * x - D * T),
              (j = j * x - I * T),
              (D = A),
              (I = k)),
            _ &&
              Math.abs(_) + Math.abs(m) > 359.9 &&
              ((_ = m = 0), (d = 180 - d)),
            (p = Lt(Math.sqrt(D * D + N * N + L * L))),
            (g = Lt(Math.sqrt(j * j + le * le))),
            (C = ra(I, j)),
            (y = Math.abs(C) > 2e-4 ? C * is : 0),
            (S = Y ? 1 / (Y < 0 ? -Y : Y) : 0)),
        n.svg &&
          ((A = e.getAttribute("transform")),
          (n.forceCSS = e.setAttribute("transform", "") || !d0(Li(e, bt))),
          A && e.setAttribute("transform", A))),
      Math.abs(y) > 90 &&
        Math.abs(y) < 270 &&
        (s
          ? ((p *= -1), (y += m <= 0 ? 180 : -180), (m += m <= 0 ? 180 : -180))
          : ((g *= -1), (y += y <= 0 ? 180 : -180))),
      (t = t || n.uncache),
      (n.x =
        u -
        ((n.xPercent =
          u &&
          ((!t && n.xPercent) ||
            (Math.round(e.offsetWidth / 2) === Math.round(-u) ? -50 : 0)))
          ? (e.offsetWidth * n.xPercent) / 100
          : 0) +
        a),
      (n.y =
        h -
        ((n.yPercent =
          h &&
          ((!t && n.yPercent) ||
            (Math.round(e.offsetHeight / 2) === Math.round(-h) ? -50 : 0)))
          ? (e.offsetHeight * n.yPercent) / 100
          : 0) +
        a),
      (n.z = f + a),
      (n.scaleX = Lt(p)),
      (n.scaleY = Lt(g)),
      (n.rotation = Lt(m) + o),
      (n.rotationX = Lt(_) + o),
      (n.rotationY = Lt(d) + o),
      (n.skewX = y + o),
      (n.skewY = v + o),
      (n.transformPerspective = S + a),
      (n.zOrigin = parseFloat(c.split(" ")[2]) || 0) && (i[vi] = zc(c)),
      (n.xOffset = n.yOffset = 0),
      (n.force3D = Gn.force3D),
      (n.renderTransform = n.svg ? ZA : c0 ? p0 : $A),
      (n.uncache = 0),
      n
    );
  },
  zc = function (e) {
    return (e = e.split(" "))[0] + " " + e[1];
  },
  ph = function (e, t, n) {
    var i = sn(t);
    return Lt(parseFloat(t) + parseFloat(Or(e, "x", n + "px", i))) + i;
  },
  $A = function (e, t) {
    (t.z = "0px"),
      (t.rotationY = t.rotationX = "0deg"),
      (t.force3D = 0),
      p0(e, t);
  },
  Jr = "0deg",
  co = "0px",
  Qr = ") ",
  p0 = function (e, t) {
    var n = t || this,
      i = n.xPercent,
      s = n.yPercent,
      a = n.x,
      o = n.y,
      l = n.z,
      c = n.rotation,
      u = n.rotationY,
      h = n.rotationX,
      f = n.skewX,
      p = n.skewY,
      g = n.scaleX,
      m = n.scaleY,
      _ = n.transformPerspective,
      d = n.force3D,
      y = n.target,
      v = n.zOrigin,
      S = "",
      E = (d === "auto" && e && e !== 1) || d === !0;
    if (v && (h !== Jr || u !== Jr)) {
      var b = parseFloat(u) * wa,
        M = Math.sin(b),
        C = Math.cos(b),
        x;
      (b = parseFloat(h) * wa),
        (x = Math.cos(b)),
        (a = ph(y, a, M * x * -v)),
        (o = ph(y, o, -Math.sin(b) * -v)),
        (l = ph(y, l, C * x * -v + v));
    }
    _ !== co && (S += "perspective(" + _ + Qr),
      (i || s) && (S += "translate(" + i + "%, " + s + "%) "),
      (E || a !== co || o !== co || l !== co) &&
        (S +=
          l !== co || E
            ? "translate3d(" + a + ", " + o + ", " + l + ") "
            : "translate(" + a + ", " + o + Qr),
      c !== Jr && (S += "rotate(" + c + Qr),
      u !== Jr && (S += "rotateY(" + u + Qr),
      h !== Jr && (S += "rotateX(" + h + Qr),
      (f !== Jr || p !== Jr) && (S += "skew(" + f + ", " + p + Qr),
      (g !== 1 || m !== 1) && (S += "scale(" + g + ", " + m + Qr),
      (y.style[bt] = S || "translate(0, 0)");
  },
  ZA = function (e, t) {
    var n = t || this,
      i = n.xPercent,
      s = n.yPercent,
      a = n.x,
      o = n.y,
      l = n.rotation,
      c = n.skewX,
      u = n.skewY,
      h = n.scaleX,
      f = n.scaleY,
      p = n.target,
      g = n.xOrigin,
      m = n.yOrigin,
      _ = n.xOffset,
      d = n.yOffset,
      y = n.forceCSS,
      v = parseFloat(a),
      S = parseFloat(o),
      E,
      b,
      M,
      C,
      x;
    (l = parseFloat(l)),
      (c = parseFloat(c)),
      (u = parseFloat(u)),
      u && ((u = parseFloat(u)), (c += u), (l += u)),
      l || c
        ? ((l *= wa),
          (c *= wa),
          (E = Math.cos(l) * h),
          (b = Math.sin(l) * h),
          (M = Math.sin(l - c) * -f),
          (C = Math.cos(l - c) * f),
          c &&
            ((u *= wa),
            (x = Math.tan(c - u)),
            (x = Math.sqrt(1 + x * x)),
            (M *= x),
            (C *= x),
            u &&
              ((x = Math.tan(u)),
              (x = Math.sqrt(1 + x * x)),
              (E *= x),
              (b *= x))),
          (E = Lt(E)),
          (b = Lt(b)),
          (M = Lt(M)),
          (C = Lt(C)))
        : ((E = h), (C = f), (b = M = 0)),
      ((v && !~(a + "").indexOf("px")) || (S && !~(o + "").indexOf("px"))) &&
        ((v = Or(p, "x", a, "px")), (S = Or(p, "y", o, "px"))),
      (g || m || _ || d) &&
        ((v = Lt(v + g - (g * E + m * M) + _)),
        (S = Lt(S + m - (g * b + m * C) + d))),
      (i || s) &&
        ((x = p.getBBox()),
        (v = Lt(v + (i / 100) * x.width)),
        (S = Lt(S + (s / 100) * x.height))),
      (x =
        "matrix(" + E + "," + b + "," + M + "," + C + "," + v + "," + S + ")"),
      p.setAttribute("transform", x),
      y && (p.style[bt] = x);
  },
  JA = function (e, t, n, i, s) {
    var a = 360,
      o = jt(s),
      l = parseFloat(s) * (o && ~s.indexOf("rad") ? is : 1),
      c = l - i,
      u = i + c + "deg",
      h,
      f;
    return (
      o &&
        ((h = s.split("_")[1]),
        h === "short" && ((c %= a), c !== c % (a / 2) && (c += c < 0 ? a : -a)),
        h === "cw" && c < 0
          ? (c = ((c + a * Cm) % a) - ~~(c / a) * a)
          : h === "ccw" && c > 0 && (c = ((c - a * Cm) % a) - ~~(c / a) * a)),
      (e._pt = f = new wn(e._pt, t, n, i, c, OA)),
      (f.e = u),
      (f.u = "deg"),
      e._props.push(n),
      f
    );
  },
  Om = function (e, t) {
    for (var n in t) e[n] = t[n];
    return e;
  },
  QA = function (e, t, n) {
    var i = Om({}, n._gsap),
      s = "perspective,force3D,transformOrigin,svgOrigin",
      a = n.style,
      o,
      l,
      c,
      u,
      h,
      f,
      p,
      g;
    i.svg
      ? ((c = n.getAttribute("transform")),
        n.setAttribute("transform", ""),
        (a[bt] = t),
        (o = Qo(n, 1)),
        Zo(n, bt),
        n.setAttribute("transform", c))
      : ((c = getComputedStyle(n)[bt]),
        (a[bt] = t),
        (o = Qo(n, 1)),
        (a[bt] = c));
    for (l in cr)
      (c = i[l]),
        (u = o[l]),
        c !== u &&
          s.indexOf(l) < 0 &&
          ((p = sn(c)),
          (g = sn(u)),
          (h = p !== g ? Or(n, l, c, g) : parseFloat(c)),
          (f = parseFloat(u)),
          (e._pt = new wn(e._pt, o, l, h, f - h, Jh)),
          (e._pt.u = g || 0),
          e._props.push(l));
    Om(o, i);
  };
An("padding,margin,Width,Radius", function (r, e) {
  var t = "Top",
    n = "Right",
    i = "Bottom",
    s = "Left",
    a = (e < 3 ? [t, n, i, s] : [t + s, t + n, i + n, i + s]).map(function (o) {
      return e < 2 ? r + o : "border" + o + r;
    });
  kc[e > 1 ? "border" + r : r] = function (o, l, c, u, h) {
    var f, p;
    if (arguments.length < 4)
      return (
        (f = a.map(function (g) {
          return $i(o, g, c);
        })),
        (p = f.join(" ")),
        p.split(f[0]).length === 5 ? f[0] : p
      );
    (f = (u + "").split(" ")),
      (p = {}),
      a.forEach(function (g, m) {
        return (p[g] = f[m] = f[m] || f[((m - 1) / 2) | 0]);
      }),
      o.init(l, p, h);
  };
});
var m0 = {
  name: "css",
  register: ef,
  targetTest: function (e) {
    return e.style && e.nodeType;
  },
  init: function (e, t, n, i, s) {
    var a = this._props,
      o = e.style,
      l = n.vars.startAt,
      c,
      u,
      h,
      f,
      p,
      g,
      m,
      _,
      d,
      y,
      v,
      S,
      E,
      b,
      M,
      C;
    Qf || ef(),
      (this.styles = this.styles || l0(e)),
      (C = this.styles.props),
      (this.tween = n);
    for (m in t)
      if (m !== "autoRound" && ((u = t[m]), !(kn[m] && Zg(m, t, n, i, e, s)))) {
        if (
          ((p = typeof u),
          (g = kc[m]),
          p === "function" && ((u = u.call(n, i, e, s)), (p = typeof u)),
          p === "string" && ~u.indexOf("random(") && (u = jo(u)),
          g)
        )
          g(this, e, m, u, n) && (M = 1);
        else if (m.substr(0, 2) === "--")
          (c = (getComputedStyle(e).getPropertyValue(m) + "").trim()),
            (u += ""),
            (Lr.lastIndex = 0),
            Lr.test(c) || ((_ = sn(c)), (d = sn(u))),
            d ? _ !== d && (c = Or(e, m, c, d) + d) : _ && (u += _),
            this.add(o, "setProperty", c, u, i, s, 0, 0, m),
            a.push(m),
            C.push(m, 0, o[m]);
        else if (p !== "undefined") {
          if (
            (l && m in l
              ? ((c = typeof l[m] == "function" ? l[m].call(n, i, e, s) : l[m]),
                jt(c) && ~c.indexOf("random(") && (c = jo(c)),
                sn(c + "") || (c += Gn.units[m] || sn($i(e, m)) || ""),
                (c + "").charAt(1) === "=" && (c = $i(e, m)))
              : (c = $i(e, m)),
            (f = parseFloat(c)),
            (y = p === "string" && u.charAt(1) === "=" && u.substr(0, 2)),
            y && (u = u.substr(2)),
            (h = parseFloat(u)),
            m in Ci &&
              (m === "autoAlpha" &&
                (f === 1 && $i(e, "visibility") === "hidden" && h && (f = 0),
                C.push("visibility", 0, o.visibility),
                Tr(
                  this,
                  o,
                  "visibility",
                  f ? "inherit" : "hidden",
                  h ? "inherit" : "hidden",
                  !h
                )),
              m !== "scale" &&
                m !== "transform" &&
                ((m = Ci[m]), ~m.indexOf(",") && (m = m.split(",")[0]))),
            (v = m in cr),
            v)
          ) {
            if (
              (this.styles.save(m),
              S ||
                ((E = e._gsap),
                (E.renderTransform && !t.parseTransform) ||
                  Qo(e, t.parseTransform),
                (b = t.smoothOrigin !== !1 && E.smooth),
                (S = this._pt =
                  new wn(this._pt, o, bt, 0, 1, E.renderTransform, E, 0, -1)),
                (S.dep = 1)),
              m === "scale")
            )
              (this._pt = new wn(
                this._pt,
                E,
                "scaleY",
                E.scaleY,
                (y ? Ta(E.scaleY, y + h) : h) - E.scaleY || 0,
                Jh
              )),
                (this._pt.u = 0),
                a.push("scaleY", m),
                (m += "X");
            else if (m === "transformOrigin") {
              C.push(vi, 0, o[vi]),
                (u = jA(u)),
                E.svg
                  ? tf(e, u, 0, b, 0, this)
                  : ((d = parseFloat(u.split(" ")[2]) || 0),
                    d !== E.zOrigin && Tr(this, E, "zOrigin", E.zOrigin, d),
                    Tr(this, o, m, zc(c), zc(u)));
              continue;
            } else if (m === "svgOrigin") {
              tf(e, u, 1, b, 0, this);
              continue;
            } else if (m in f0) {
              JA(this, E, m, f, y ? Ta(f, y + u) : u);
              continue;
            } else if (m === "smoothOrigin") {
              Tr(this, E, "smooth", E.smooth, u);
              continue;
            } else if (m === "force3D") {
              E[m] = u;
              continue;
            } else if (m === "transform") {
              QA(this, u, e);
              continue;
            }
          } else m in o || (m = Xa(m) || m);
          if (v || ((h || h === 0) && (f || f === 0) && !NA.test(u) && m in o))
            (_ = (c + "").substr((f + "").length)),
              h || (h = 0),
              (d = sn(u) || (m in Gn.units ? Gn.units[m] : _)),
              _ !== d && (f = Or(e, m, c, d)),
              (this._pt = new wn(
                this._pt,
                v ? E : o,
                m,
                f,
                (y ? Ta(f, y + h) : h) - f,
                !v && (d === "px" || m === "zIndex") && t.autoRound !== !1
                  ? FA
                  : Jh
              )),
              (this._pt.u = d || 0),
              _ !== d && d !== "%" && ((this._pt.b = c), (this._pt.r = UA));
          else if (m in o) qA.call(this, e, m, c, y ? y + u : u);
          else if (m in e) this.add(e, m, c || e[m], y ? y + u : u, i, s);
          else if (m !== "parseTransform") {
            Wf(m, u);
            continue;
          }
          v || (m in o ? C.push(m, 0, o[m]) : C.push(m, 1, c || e[m])),
            a.push(m);
        }
      }
    M && i0(this);
  },
  render: function (e, t) {
    if (t.tween._time || !ed())
      for (var n = t._pt; n; ) n.r(e, n.d), (n = n._next);
    else t.styles.revert();
  },
  get: $i,
  aliases: Ci,
  getSetter: function (e, t, n) {
    var i = Ci[t];
    return (
      i && i.indexOf(",") < 0 && (t = i),
      t in cr && t !== vi && (e._gsap.x || $i(e, "x"))
        ? n && Rm === n
          ? t === "scale"
            ? HA
            : zA
          : (Rm = n || {}) && (t === "scale" ? VA : GA)
        : e.style && !Hf(e.style[t])
        ? BA
        : ~t.indexOf("-")
        ? kA
        : Zf(e, t)
    );
  },
  core: { _removeProperty: Zo, _getMatrix: nd },
};
Rn.utils.checkPrefix = Xa;
Rn.core.getStyleSaver = l0;
(function (r, e, t, n) {
  var i = An(r + "," + e + "," + t, function (s) {
    cr[s] = 1;
  });
  An(e, function (s) {
    (Gn.units[s] = "deg"), (f0[s] = 1);
  }),
    (Ci[i[13]] = r + "," + e),
    An(n, function (s) {
      var a = s.split(":");
      Ci[a[1]] = i[a[0]];
    });
})(
  "x,y,z,scale,scaleX,scaleY,xPercent,yPercent",
  "rotation,rotationX,rotationY,skewX,skewY",
  "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
  "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"
);
An(
  "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
  function (r) {
    Gn.units[r] = "px";
  }
);
Rn.registerPlugin(m0);
var Hc = Rn.registerPlugin(m0) || Rn;
Hc.core.Tween;
/*!
 * Observer 3.12.1
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ let Jt,
  nf,
  Hn,
  Ar,
  wr,
  Ra,
  _0,
  rs,
  Po,
  g0,
  er,
  fi,
  v0,
  x0 = () =>
    Jt ||
    (typeof window < "u" && (Jt = window.gsap) && Jt.registerPlugin && Jt),
  y0 = 1,
  va = [],
  Qe = [],
  Di = [],
  Lo = Date.now,
  rf = (r, e) => e,
  ew = () => {
    let r = Po.core,
      e = r.bridge || {},
      t = r._scrollers,
      n = r._proxies;
    t.push(...Qe), n.push(...Di), (Qe = t), (Di = n), (rf = (i, s) => e[i](s));
  },
  Dr = (r, e) => ~Di.indexOf(r) && Di[Di.indexOf(r) + 1][e],
  Do = (r) => !!~g0.indexOf(r),
  yn = (r, e, t, n, i) =>
    r.addEventListener(e, t, { passive: !n, capture: !!i }),
  un = (r, e, t, n) => r.removeEventListener(e, t, !!n),
  Ql = "scrollLeft",
  ec = "scrollTop",
  sf = () => (er && er.isPressed) || Qe.cache++,
  Vc = (r, e) => {
    let t = (n) => {
      if (n || n === 0) {
        y0 && (Hn.history.scrollRestoration = "manual");
        let i = er && er.isPressed;
        (n = t.v = Math.round(n) || (er && er.iOS ? 1 : 0)),
          r(n),
          (t.cacheID = Qe.cache),
          i && rf("ss", n);
      } else
        (e || Qe.cache !== t.cacheID || rf("ref")) &&
          ((t.cacheID = Qe.cache), (t.v = r()));
      return t.v + t.offset;
    };
    return (t.offset = 0), r && t;
  },
  gn = {
    s: Ql,
    p: "left",
    p2: "Left",
    os: "right",
    os2: "Right",
    d: "width",
    d2: "Width",
    a: "x",
    sc: Vc(function (r) {
      return arguments.length
        ? Hn.scrollTo(r, Bt.sc())
        : Hn.pageXOffset || Ar[Ql] || wr[Ql] || Ra[Ql] || 0;
    }),
  },
  Bt = {
    s: ec,
    p: "top",
    p2: "Top",
    os: "bottom",
    os2: "Bottom",
    d: "height",
    d2: "Height",
    a: "y",
    op: gn,
    sc: Vc(function (r) {
      return arguments.length
        ? Hn.scrollTo(gn.sc(), r)
        : Hn.pageYOffset || Ar[ec] || wr[ec] || Ra[ec] || 0;
    }),
  },
  En = (r, e) =>
    ((e && e._ctx && e._ctx.selector) || Jt.utils.toArray)(r)[0] ||
    (typeof r == "string" && Jt.config().nullTargetWarn !== !1
      ? console.warn("Element not found:", r)
      : null),
  Ur = (r, { s: e, sc: t }) => {
    Do(r) && (r = Ar.scrollingElement || wr);
    let n = Qe.indexOf(r),
      i = t === Bt.sc ? 1 : 2;
    !~n && (n = Qe.push(r) - 1), Qe[n + i] || r.addEventListener("scroll", sf);
    let s = Qe[n + i],
      a =
        s ||
        (Qe[n + i] =
          Vc(Dr(r, e), !0) ||
          (Do(r)
            ? t
            : Vc(function (o) {
                return arguments.length ? (r[e] = o) : r[e];
              })));
    return (
      (a.target = r),
      s || (a.smooth = Jt.getProperty(r, "scrollBehavior") === "smooth"),
      a
    );
  },
  af = (r, e, t) => {
    let n = r,
      i = r,
      s = Lo(),
      a = s,
      o = e || 50,
      l = Math.max(500, o * 3),
      c = (f, p) => {
        let g = Lo();
        p || g - s > o
          ? ((i = n), (n = f), (a = s), (s = g))
          : t
          ? (n += f)
          : (n = i + ((f - i) / (g - a)) * (s - a));
      };
    return {
      update: c,
      reset: () => {
        (i = n = t ? 0 : n), (a = s = 0);
      },
      getVelocity: (f) => {
        let p = a,
          g = i,
          m = Lo();
        return (
          (f || f === 0) && f !== n && c(f),
          s === a || m - a > l
            ? 0
            : ((n + (t ? g : -g)) / ((t ? m : s) - p)) * 1e3
        );
      },
    };
  },
  uo = (r, e) => (
    e && !r._gsapAllow && r.preventDefault(),
    r.changedTouches ? r.changedTouches[0] : r
  ),
  Um = (r) => {
    let e = Math.max(...r),
      t = Math.min(...r);
    return Math.abs(e) >= Math.abs(t) ? e : t;
  },
  E0 = () => {
    (Po = Jt.core.globals().ScrollTrigger), Po && Po.core && ew();
  },
  S0 = (r) => (
    (Jt = r || x0()),
    Jt &&
      typeof document < "u" &&
      document.body &&
      ((Hn = window),
      (Ar = document),
      (wr = Ar.documentElement),
      (Ra = Ar.body),
      (g0 = [Hn, Ar, wr, Ra]),
      Jt.utils.clamp,
      (v0 = Jt.core.context || function () {}),
      (rs = "onpointerenter" in Ra ? "pointer" : "mouse"),
      (_0 = Ft.isTouch =
        Hn.matchMedia &&
        Hn.matchMedia("(hover: none), (pointer: coarse)").matches
          ? 1
          : "ontouchstart" in Hn ||
            navigator.maxTouchPoints > 0 ||
            navigator.msMaxTouchPoints > 0
          ? 2
          : 0),
      (fi = Ft.eventTypes =
        (
          "ontouchstart" in wr
            ? "touchstart,touchmove,touchcancel,touchend"
            : "onpointerdown" in wr
            ? "pointerdown,pointermove,pointercancel,pointerup"
            : "mousedown,mousemove,mouseup,mouseup"
        ).split(",")),
      setTimeout(() => (y0 = 0), 500),
      E0(),
      (nf = 1)),
    nf
  );
gn.op = Bt;
Qe.cache = 0;
class Ft {
  constructor(e) {
    this.init(e);
  }
  init(e) {
    nf || S0(Jt) || console.warn("Please gsap.registerPlugin(Observer)"),
      Po || E0();
    let {
      tolerance: t,
      dragMinimum: n,
      type: i,
      target: s,
      lineHeight: a,
      debounce: o,
      preventDefault: l,
      onStop: c,
      onStopDelay: u,
      ignore: h,
      wheelSpeed: f,
      event: p,
      onDragStart: g,
      onDragEnd: m,
      onDrag: _,
      onPress: d,
      onRelease: y,
      onRight: v,
      onLeft: S,
      onUp: E,
      onDown: b,
      onChangeX: M,
      onChangeY: C,
      onChange: x,
      onToggleX: T,
      onToggleY: D,
      onHover: N,
      onHoverEnd: L,
      onMove: F,
      ignoreCheck: I,
      isNormalizer: j,
      onGestureStart: A,
      onGestureEnd: k,
      onWheel: G,
      onEnable: z,
      onDisable: oe,
      onClick: te,
      scrollSpeed: X,
      capture: Y,
      allowClicks: le,
      lockAxis: W,
      onLockAxis: O,
    } = e;
    (this.target = s = En(s) || wr),
      (this.vars = e),
      h && (h = Jt.utils.toArray(h)),
      (t = t || 1e-9),
      (n = n || 0),
      (f = f || 1),
      (X = X || 1),
      (i = i || "wheel,touch,pointer"),
      (o = o !== !1),
      a || (a = parseFloat(Hn.getComputedStyle(Ra).lineHeight) || 22);
    let Me,
      ve,
      re,
      be,
      Fe,
      ae,
      _e,
      K = this,
      $e = 0,
      ct = 0,
      Ge = Ur(s, gn),
      Xe = Ur(s, Bt),
      st = Ge(),
      Et = Xe(),
      P =
        ~i.indexOf("touch") &&
        !~i.indexOf("pointer") &&
        fi[0] === "pointerdown",
      w = Do(s),
      $ = s.ownerDocument || Ar,
      ue = [0, 0, 0],
      he = [0, 0, 0],
      me = 0,
      U = () => (me = Lo()),
      ne = (se, pe) =>
        ((K.event = se) && h && ~h.indexOf(se.target)) ||
        (pe && P && se.pointerType !== "touch") ||
        (I && I(se, pe)),
      J = () => {
        K._vx.reset(), K._vy.reset(), ve.pause(), c && c(K);
      },
      ge = () => {
        let se = (K.deltaX = Um(ue)),
          pe = (K.deltaY = Um(he)),
          Re = Math.abs(se) >= t,
          Oe = Math.abs(pe) >= t;
        x && (Re || Oe) && x(K, se, pe, ue, he),
          Re &&
            (v && K.deltaX > 0 && v(K),
            S && K.deltaX < 0 && S(K),
            M && M(K),
            T && K.deltaX < 0 != $e < 0 && T(K),
            ($e = K.deltaX),
            (ue[0] = ue[1] = ue[2] = 0)),
          Oe &&
            (b && K.deltaY > 0 && b(K),
            E && K.deltaY < 0 && E(K),
            C && C(K),
            D && K.deltaY < 0 != ct < 0 && D(K),
            (ct = K.deltaY),
            (he[0] = he[1] = he[2] = 0)),
          (be || re) && (F && F(K), re && (_(K), (re = !1)), (be = !1)),
          ae && !(ae = !1) && O && O(K),
          Fe && (G(K), (Fe = !1)),
          (Me = 0);
      },
      Te = (se, pe, Re) => {
        (ue[Re] += se),
          (he[Re] += pe),
          K._vx.update(se),
          K._vy.update(pe),
          o ? Me || (Me = requestAnimationFrame(ge)) : ge();
      },
      Le = (se, pe) => {
        W &&
          !_e &&
          ((K.axis = _e = Math.abs(se) > Math.abs(pe) ? "x" : "y"), (ae = !0)),
          _e !== "y" && ((ue[2] += se), K._vx.update(se, !0)),
          _e !== "x" && ((he[2] += pe), K._vy.update(pe, !0)),
          o ? Me || (Me = requestAnimationFrame(ge)) : ge();
      },
      ye = (se) => {
        if (ne(se, 1)) return;
        se = uo(se, l);
        let pe = se.clientX,
          Re = se.clientY,
          Oe = pe - K.x,
          Ne = Re - K.y,
          tt = K.isDragging;
        (K.x = pe),
          (K.y = Re),
          (tt ||
            Math.abs(K.startX - pe) >= n ||
            Math.abs(K.startY - Re) >= n) &&
            (_ && (re = !0),
            tt || (K.isDragging = !0),
            Le(Oe, Ne),
            tt || (g && g(K)));
      },
      Ae = (K.onPress = (se) => {
        ne(se, 1) ||
          (se && se.button) ||
          ((K.axis = _e = null),
          ve.pause(),
          (K.isPressed = !0),
          (se = uo(se)),
          ($e = ct = 0),
          (K.startX = K.x = se.clientX),
          (K.startY = K.y = se.clientY),
          K._vx.reset(),
          K._vy.reset(),
          yn(j ? s : $, fi[1], ye, l, !0),
          (K.deltaX = K.deltaY = 0),
          d && d(K));
      }),
      xe = (K.onRelease = (se) => {
        if (ne(se, 1)) return;
        un(j ? s : $, fi[1], ye, !0);
        let pe = !isNaN(K.y - K.startY),
          Re =
            K.isDragging &&
            (Math.abs(K.x - K.startX) > 3 || Math.abs(K.y - K.startY) > 3),
          Oe = uo(se);
        !Re &&
          pe &&
          (K._vx.reset(),
          K._vy.reset(),
          l &&
            le &&
            Jt.delayedCall(0.08, () => {
              if (Lo() - me > 300 && !se.defaultPrevented) {
                if (se.target.click) se.target.click();
                else if ($.createEvent) {
                  let Ne = $.createEvent("MouseEvents");
                  Ne.initMouseEvent(
                    "click",
                    !0,
                    !0,
                    Hn,
                    1,
                    Oe.screenX,
                    Oe.screenY,
                    Oe.clientX,
                    Oe.clientY,
                    !1,
                    !1,
                    !1,
                    !1,
                    0,
                    null
                  ),
                    se.target.dispatchEvent(Ne);
                }
              }
            })),
          (K.isDragging = K.isGesturing = K.isPressed = !1),
          c && !j && ve.restart(!0),
          m && Re && m(K),
          y && y(K, Re);
      }),
      ze = (se) =>
        se.touches &&
        se.touches.length > 1 &&
        (K.isGesturing = !0) &&
        A(se, K.isDragging),
      ot = () => (K.isGesturing = !1) || k(K),
      B = (se) => {
        if (ne(se)) return;
        let pe = Ge(),
          Re = Xe();
        Te((pe - st) * X, (Re - Et) * X, 1),
          (st = pe),
          (Et = Re),
          c && ve.restart(!0);
      },
      Q = (se) => {
        if (ne(se)) return;
        (se = uo(se, l)), G && (Fe = !0);
        let pe =
          (se.deltaMode === 1 ? a : se.deltaMode === 2 ? Hn.innerHeight : 1) *
          f;
        Te(se.deltaX * pe, se.deltaY * pe, 0), c && !j && ve.restart(!0);
      },
      fe = (se) => {
        if (ne(se)) return;
        let pe = se.clientX,
          Re = se.clientY,
          Oe = pe - K.x,
          Ne = Re - K.y;
        (K.x = pe), (K.y = Re), (be = !0), (Oe || Ne) && Le(Oe, Ne);
      },
      Se = (se) => {
        (K.event = se), N(K);
      },
      we = (se) => {
        (K.event = se), L(K);
      },
      de = (se) => ne(se) || (uo(se, l) && te(K));
    (ve = K._dc = Jt.delayedCall(u || 0.25, J).pause()),
      (K.deltaX = K.deltaY = 0),
      (K._vx = af(0, 50, !0)),
      (K._vy = af(0, 50, !0)),
      (K.scrollX = Ge),
      (K.scrollY = Xe),
      (K.isDragging = K.isGesturing = K.isPressed = !1),
      v0(this),
      (K.enable = (se) => (
        K.isEnabled ||
          (yn(w ? $ : s, "scroll", sf),
          i.indexOf("scroll") >= 0 && yn(w ? $ : s, "scroll", B, l, Y),
          i.indexOf("wheel") >= 0 && yn(s, "wheel", Q, l, Y),
          ((i.indexOf("touch") >= 0 && _0) || i.indexOf("pointer") >= 0) &&
            (yn(s, fi[0], Ae, l, Y),
            yn($, fi[2], xe),
            yn($, fi[3], xe),
            le && yn(s, "click", U, !1, !0),
            te && yn(s, "click", de),
            A && yn($, "gesturestart", ze),
            k && yn($, "gestureend", ot),
            N && yn(s, rs + "enter", Se),
            L && yn(s, rs + "leave", we),
            F && yn(s, rs + "move", fe)),
          (K.isEnabled = !0),
          se && se.type && Ae(se),
          z && z(K)),
        K
      )),
      (K.disable = () => {
        K.isEnabled &&
          (va.filter((se) => se !== K && Do(se.target)).length ||
            un(w ? $ : s, "scroll", sf),
          K.isPressed &&
            (K._vx.reset(), K._vy.reset(), un(j ? s : $, fi[1], ye, !0)),
          un(w ? $ : s, "scroll", B, Y),
          un(s, "wheel", Q, Y),
          un(s, fi[0], Ae, Y),
          un($, fi[2], xe),
          un($, fi[3], xe),
          un(s, "click", U, !0),
          un(s, "click", de),
          un($, "gesturestart", ze),
          un($, "gestureend", ot),
          un(s, rs + "enter", Se),
          un(s, rs + "leave", we),
          un(s, rs + "move", fe),
          (K.isEnabled = K.isPressed = K.isDragging = !1),
          oe && oe(K));
      }),
      (K.kill = K.revert =
        () => {
          K.disable();
          let se = va.indexOf(K);
          se >= 0 && va.splice(se, 1), er === K && (er = 0);
        }),
      va.push(K),
      j && Do(s) && (er = K),
      K.enable(p);
  }
  get velocityX() {
    return this._vx.getVelocity();
  }
  get velocityY() {
    return this._vy.getVelocity();
  }
}
Ft.version = "3.12.1";
Ft.create = (r) => new Ft(r);
Ft.register = S0;
Ft.getAll = () => va.slice();
Ft.getById = (r) => va.filter((e) => e.vars.id === r)[0];
x0() && Jt.registerPlugin(Ft);
/*!
 * ScrollTrigger 3.12.1
 * https://greensock.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */ let Pe,
  ca,
  nt,
  yt,
  pi,
  St,
  M0,
  Gc,
  Wc,
  xa,
  xc,
  tc,
  nn,
  du,
  of,
  fn,
  Fm,
  Bm,
  ua,
  b0,
  mh,
  T0,
  Un,
  A0,
  w0,
  R0,
  xr,
  lf,
  id,
  _h,
  nc = 1,
  pn = Date.now,
  gh = pn(),
  si = 0,
  yo = 0,
  km = (r, e, t) => {
    let n = Bn(r) && (r.substr(0, 6) === "clamp(" || r.indexOf("max") > -1);
    return (t["_" + e + "Clamp"] = n), n ? r.substr(6, r.length - 7) : r;
  },
  zm = (r, e) =>
    e && (!Bn(r) || r.substr(0, 6) !== "clamp(") ? "clamp(" + r + ")" : r,
  C0 = () => yo && requestAnimationFrame(C0),
  Hm = () => (du = 1),
  Vm = () => (du = 0),
  Ti = (r) => r,
  Eo = (r) => Math.round(r * 1e5) / 1e5 || 0,
  P0 = () => typeof window < "u",
  L0 = () => Pe || (P0() && (Pe = window.gsap) && Pe.registerPlugin && Pe),
  ws = (r) => !!~M0.indexOf(r),
  D0 = (r) =>
    Dr(r, "getBoundingClientRect") ||
    (ws(r)
      ? () => ((Tc.width = nt.innerWidth), (Tc.height = nt.innerHeight), Tc)
      : () => Ji(r)),
  tw = (r, e, { d: t, d2: n, a: i }) =>
    (i = Dr(r, "getBoundingClientRect"))
      ? () => i()[t]
      : () => (e ? nt["inner" + n] : r["client" + n]) || 0,
  nw = (r, e) => (!e || ~Di.indexOf(r) ? D0(r) : () => Tc),
  tr = (r, { s: e, d2: t, d: n, a: i }) =>
    Math.max(
      0,
      (e = "scroll" + t) && (i = Dr(r, e))
        ? i() - D0(r)()[n]
        : ws(r)
        ? (pi[e] || St[e]) -
          (nt["inner" + t] || pi["client" + t] || St["client" + t])
        : r[e] - r["offset" + t]
    ),
  ic = (r, e) => {
    for (let t = 0; t < ua.length; t += 3)
      (!e || ~e.indexOf(ua[t + 1])) && r(ua[t], ua[t + 1], ua[t + 2]);
  },
  Bn = (r) => typeof r == "string",
  vn = (r) => typeof r == "function",
  yc = (r) => typeof r == "number",
  ss = (r) => typeof r == "object",
  ho = (r, e, t) => r && r.progress(e ? 0 : 1) && t && r.pause(),
  vh = (r, e) => {
    if (r.enabled) {
      let t = e(r);
      t && t.totalTime && (r.callbackAnimation = t);
    }
  },
  sa = Math.abs,
  I0 = "left",
  N0 = "top",
  rd = "right",
  sd = "bottom",
  vs = "width",
  xs = "height",
  Io = "Right",
  No = "Left",
  Oo = "Top",
  Uo = "Bottom",
  Ot = "padding",
  Kn = "margin",
  Ya = "Width",
  ad = "Height",
  Kt = "px",
  $n = (r) => nt.getComputedStyle(r),
  iw = (r) => {
    let e = $n(r).position;
    r.style.position = e === "absolute" || e === "fixed" ? e : "relative";
  },
  Gm = (r, e) => {
    for (let t in e) t in r || (r[t] = e[t]);
    return r;
  },
  Ji = (r, e) => {
    let t =
        e &&
        $n(r)[of] !== "matrix(1, 0, 0, 1, 0, 0)" &&
        Pe.to(r, {
          x: 0,
          y: 0,
          xPercent: 0,
          yPercent: 0,
          rotation: 0,
          rotationX: 0,
          rotationY: 0,
          scale: 1,
          skewX: 0,
          skewY: 0,
        }).progress(1),
      n = r.getBoundingClientRect();
    return t && t.progress(0).kill(), n;
  },
  cf = (r, { d2: e }) => r["offset" + e] || r["client" + e] || 0,
  O0 = (r) => {
    let e = [],
      t = r.labels,
      n = r.duration(),
      i;
    for (i in t) e.push(t[i] / n);
    return e;
  },
  rw = (r) => (e) => Pe.utils.snap(O0(r), e),
  od = (r) => {
    let e = Pe.utils.snap(r),
      t = Array.isArray(r) && r.slice(0).sort((n, i) => n - i);
    return t
      ? (n, i, s = 0.001) => {
          let a;
          if (!i) return e(n);
          if (i > 0) {
            for (n -= s, a = 0; a < t.length; a++) if (t[a] >= n) return t[a];
            return t[a - 1];
          } else for (a = t.length, n += s; a--; ) if (t[a] <= n) return t[a];
          return t[0];
        }
      : (n, i, s = 0.001) => {
          let a = e(n);
          return !i || Math.abs(a - n) < s || a - n < 0 == i < 0
            ? a
            : e(i < 0 ? n - r : n + r);
        };
  },
  sw = (r) => (e, t) => od(O0(r))(e, t.direction),
  rc = (r, e, t, n) => t.split(",").forEach((i) => r(e, i, n)),
  Yt = (r, e, t, n, i) =>
    r.addEventListener(e, t, { passive: !n, capture: !!i }),
  Xt = (r, e, t, n) => r.removeEventListener(e, t, !!n),
  sc = (r, e, t) => {
    (t = t && t.wheelHandler), t && (r(e, "wheel", t), r(e, "touchmove", t));
  },
  Wm = {
    startColor: "green",
    endColor: "red",
    indent: 0,
    fontSize: "16px",
    fontWeight: "normal",
  },
  ac = { toggleActions: "play", anticipatePin: 0 },
  Xc = { top: 0, left: 0, center: 0.5, bottom: 1, right: 1 },
  Ec = (r, e) => {
    if (Bn(r)) {
      let t = r.indexOf("="),
        n = ~t ? +(r.charAt(t - 1) + 1) * parseFloat(r.substr(t + 1)) : 0;
      ~t && (r.indexOf("%") > t && (n *= e / 100), (r = r.substr(0, t - 1))),
        (r =
          n +
          (r in Xc
            ? Xc[r] * e
            : ~r.indexOf("%")
            ? (parseFloat(r) * e) / 100
            : parseFloat(r) || 0));
    }
    return r;
  },
  oc = (
    r,
    e,
    t,
    n,
    { startColor: i, endColor: s, fontSize: a, indent: o, fontWeight: l },
    c,
    u,
    h
  ) => {
    let f = yt.createElement("div"),
      p = ws(t) || Dr(t, "pinType") === "fixed",
      g = r.indexOf("scroller") !== -1,
      m = p ? St : t,
      _ = r.indexOf("start") !== -1,
      d = _ ? i : s,
      y =
        "border-color:" +
        d +
        ";font-size:" +
        a +
        ";color:" +
        d +
        ";font-weight:" +
        l +
        ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
    return (
      (y += "position:" + ((g || h) && p ? "fixed;" : "absolute;")),
      (g || h || !p) &&
        (y += (n === Bt ? rd : sd) + ":" + (c + parseFloat(o)) + "px;"),
      u &&
        (y +=
          "box-sizing:border-box;text-align:left;width:" +
          u.offsetWidth +
          "px;"),
      (f._isStart = _),
      f.setAttribute("class", "gsap-marker-" + r + (e ? " marker-" + e : "")),
      (f.style.cssText = y),
      (f.innerText = e || e === 0 ? r + "-" + e : r),
      m.children[0] ? m.insertBefore(f, m.children[0]) : m.appendChild(f),
      (f._offset = f["offset" + n.op.d2]),
      Sc(f, 0, n, _),
      f
    );
  },
  Sc = (r, e, t, n) => {
    let i = { display: "block" },
      s = t[n ? "os2" : "p2"],
      a = t[n ? "p2" : "os2"];
    (r._isFlipped = n),
      (i[t.a + "Percent"] = n ? -100 : 0),
      (i[t.a] = n ? "1px" : 0),
      (i["border" + s + Ya] = 1),
      (i["border" + a + Ya] = 0),
      (i[t.p] = e + "px"),
      Pe.set(r, i);
  },
  Je = [],
  uf = {},
  el,
  Xm = () => pn() - si > 34 && (el || (el = requestAnimationFrame(sr))),
  aa = () => {
    (!Un || !Un.isPressed || Un.startX > St.clientWidth) &&
      (Qe.cache++,
      Un ? el || (el = requestAnimationFrame(sr)) : sr(),
      si || Cs("scrollStart"),
      (si = pn()));
  },
  xh = () => {
    (R0 = nt.innerWidth), (w0 = nt.innerHeight);
  },
  So = () => {
    Qe.cache++,
      !nn &&
        !T0 &&
        !yt.fullscreenElement &&
        !yt.webkitFullscreenElement &&
        (!A0 ||
          R0 !== nt.innerWidth ||
          Math.abs(nt.innerHeight - w0) > nt.innerHeight * 0.25) &&
        Gc.restart(!0);
  },
  Rs = {},
  aw = [],
  ld = () => Xt(He, "scrollEnd", ld) || us(!0),
  Cs = (r) => (Rs[r] && Rs[r].map((e) => e())) || aw,
  Fn = [],
  U0 = (r) => {
    for (let e = 0; e < Fn.length; e += 5)
      (!r || (Fn[e + 4] && Fn[e + 4].query === r)) &&
        ((Fn[e].style.cssText = Fn[e + 1]),
        Fn[e].getBBox && Fn[e].setAttribute("transform", Fn[e + 2] || ""),
        (Fn[e + 3].uncache = 1));
  },
  cd = (r, e) => {
    let t;
    for (fn = 0; fn < Je.length; fn++)
      (t = Je[fn]),
        t && (!e || t._ctx === e) && (r ? t.kill(1) : t.revert(!0, !0));
    e && U0(e), e || Cs("revert");
  },
  F0 = (r, e) => {
    Qe.cache++,
      (e || !dn) && Qe.forEach((t) => vn(t) && t.cacheID++ && (t.rec = 0)),
      Bn(r) && (nt.history.scrollRestoration = id = r);
  },
  dn,
  ys = 0,
  Ym,
  ow = () => {
    if (Ym !== ys) {
      let r = (Ym = ys);
      requestAnimationFrame(() => r === ys && us(!0));
    }
  },
  us = (r, e) => {
    if (si && !r) {
      Yt(He, "scrollEnd", ld);
      return;
    }
    (dn = He.isRefreshing = !0),
      Qe.forEach((n) => vn(n) && ++n.cacheID && (n.rec = n()));
    let t = Cs("refreshInit");
    b0 && He.sort(),
      e || cd(),
      Qe.forEach((n) => {
        vn(n) && (n.smooth && (n.target.style.scrollBehavior = "auto"), n(0));
      }),
      Je.slice(0).forEach((n) => n.refresh()),
      Je.forEach((n, i) => {
        if (n._subPinOffset && n.pin) {
          let s = n.vars.horizontal ? "offsetWidth" : "offsetHeight",
            a = n.pin[s];
          n.revert(!0, 1), n.adjustPinSpacing(n.pin[s] - a), n.refresh();
        }
      }),
      Je.forEach((n) => {
        let i = tr(n.scroller, n._dir);
        (n.vars.end === "max" || (n._endClamp && n.end > i)) &&
          n.setPositions(n.start, Math.max(n.start + 1, i), !0);
      }),
      t.forEach((n) => n && n.render && n.render(-1)),
      Qe.forEach((n) => {
        vn(n) &&
          (n.smooth &&
            requestAnimationFrame(
              () => (n.target.style.scrollBehavior = "smooth")
            ),
          n.rec && n(n.rec));
      }),
      F0(id, 1),
      Gc.pause(),
      ys++,
      (dn = 2),
      sr(2),
      Je.forEach((n) => vn(n.vars.onRefresh) && n.vars.onRefresh(n)),
      (dn = He.isRefreshing = !1),
      Cs("refresh");
  },
  hf = 0,
  Mc = 1,
  Fo,
  sr = (r) => {
    if (!dn || r === 2) {
      (He.isUpdating = !0), Fo && Fo.update(0);
      let e = Je.length,
        t = pn(),
        n = t - gh >= 50,
        i = e && Je[0].scroll();
      if (
        ((Mc = hf > i ? -1 : 1),
        dn || (hf = i),
        n &&
          (si && !du && t - si > 200 && ((si = 0), Cs("scrollEnd")),
          (xc = gh),
          (gh = t)),
        Mc < 0)
      ) {
        for (fn = e; fn-- > 0; ) Je[fn] && Je[fn].update(0, n);
        Mc = 1;
      } else for (fn = 0; fn < e; fn++) Je[fn] && Je[fn].update(0, n);
      He.isUpdating = !1;
    }
    el = 0;
  },
  ff = [
    I0,
    N0,
    sd,
    rd,
    Kn + Uo,
    Kn + Io,
    Kn + Oo,
    Kn + No,
    "display",
    "flexShrink",
    "float",
    "zIndex",
    "gridColumnStart",
    "gridColumnEnd",
    "gridRowStart",
    "gridRowEnd",
    "gridArea",
    "justifySelf",
    "alignSelf",
    "placeSelf",
    "order",
  ],
  bc = ff.concat([
    vs,
    xs,
    "boxSizing",
    "max" + Ya,
    "max" + ad,
    "position",
    Kn,
    Ot,
    Ot + Oo,
    Ot + Io,
    Ot + Uo,
    Ot + No,
  ]),
  lw = (r, e, t) => {
    Ca(t);
    let n = r._gsap;
    if (n.spacerIsNative) Ca(n.spacerState);
    else if (r._gsap.swappedIn) {
      let i = e.parentNode;
      i && (i.insertBefore(r, e), i.removeChild(e));
    }
    r._gsap.swappedIn = !1;
  },
  yh = (r, e, t, n) => {
    if (!r._gsap.swappedIn) {
      let i = ff.length,
        s = e.style,
        a = r.style,
        o;
      for (; i--; ) (o = ff[i]), (s[o] = t[o]);
      (s.position = t.position === "absolute" ? "absolute" : "relative"),
        t.display === "inline" && (s.display = "inline-block"),
        (a[sd] = a[rd] = "auto"),
        (s.flexBasis = t.flexBasis || "auto"),
        (s.overflow = "visible"),
        (s.boxSizing = "border-box"),
        (s[vs] = cf(r, gn) + Kt),
        (s[xs] = cf(r, Bt) + Kt),
        (s[Ot] = a[Kn] = a[N0] = a[I0] = "0"),
        Ca(n),
        (a[vs] = a["max" + Ya] = t[vs]),
        (a[xs] = a["max" + ad] = t[xs]),
        (a[Ot] = t[Ot]),
        r.parentNode !== e &&
          (r.parentNode.insertBefore(e, r), e.appendChild(r)),
        (r._gsap.swappedIn = !0);
    }
  },
  cw = /([A-Z])/g,
  Ca = (r) => {
    if (r) {
      let e = r.t.style,
        t = r.length,
        n = 0,
        i,
        s;
      for ((r.t._gsap || Pe.core.getCache(r.t)).uncache = 1; n < t; n += 2)
        (s = r[n + 1]),
          (i = r[n]),
          s
            ? (e[i] = s)
            : e[i] && e.removeProperty(i.replace(cw, "-$1").toLowerCase());
    }
  },
  lc = (r) => {
    let e = bc.length,
      t = r.style,
      n = [],
      i = 0;
    for (; i < e; i++) n.push(bc[i], t[bc[i]]);
    return (n.t = r), n;
  },
  uw = (r, e, t) => {
    let n = [],
      i = r.length,
      s = t ? 8 : 0,
      a;
    for (; s < i; s += 2) (a = r[s]), n.push(a, a in e ? e[a] : r[s + 1]);
    return (n.t = r.t), n;
  },
  Tc = { left: 0, top: 0 },
  qm = (r, e, t, n, i, s, a, o, l, c, u, h, f, p) => {
    vn(r) && (r = r(o)),
      Bn(r) &&
        r.substr(0, 3) === "max" &&
        (r = h + (r.charAt(4) === "=" ? Ec("0" + r.substr(3), t) : 0));
    let g = f ? f.time() : 0,
      m,
      _,
      d;
    if ((f && f.seek(0), isNaN(r) || (r = +r), yc(r)))
      f &&
        (r = Pe.utils.mapRange(
          f.scrollTrigger.start,
          f.scrollTrigger.end,
          0,
          h,
          r
        )),
        a && Sc(a, t, n, !0);
    else {
      vn(e) && (e = e(o));
      let y = (r || "0").split(" "),
        v,
        S,
        E,
        b;
      (d = En(e, o) || St),
        (v = Ji(d) || {}),
        (!v || (!v.left && !v.top)) &&
          $n(d).display === "none" &&
          ((b = d.style.display),
          (d.style.display = "block"),
          (v = Ji(d)),
          b ? (d.style.display = b) : d.style.removeProperty("display")),
        (S = Ec(y[0], v[n.d])),
        (E = Ec(y[1] || "0", t)),
        (r = v[n.p] - l[n.p] - c + S + i - E),
        a && Sc(a, E, n, t - E < 20 || (a._isStart && E > 20)),
        (t -= t - E);
    }
    if ((p && ((o[p] = r || -0.001), r < 0 && (r = 0)), s)) {
      let y = r + t,
        v = s._isStart;
      (m = "scroll" + n.d2),
        Sc(
          s,
          y,
          n,
          (v && y > 20) ||
            (!v && (u ? Math.max(St[m], pi[m]) : s.parentNode[m]) <= y + 1)
        ),
        u &&
          ((l = Ji(a)),
          u && (s.style[n.op.p] = l[n.op.p] - n.op.m - s._offset + Kt));
    }
    return (
      f &&
        d &&
        ((m = Ji(d)),
        f.seek(h),
        (_ = Ji(d)),
        (f._caScrollDist = m[n.p] - _[n.p]),
        (r = (r / f._caScrollDist) * h)),
      f && f.seek(g),
      f ? r : Math.round(r)
    );
  },
  hw = /(webkit|moz|length|cssText|inset)/i,
  jm = (r, e, t, n) => {
    if (r.parentNode !== e) {
      let i = r.style,
        s,
        a;
      if (e === St) {
        (r._stOrig = i.cssText), (a = $n(r));
        for (s in a)
          !+s &&
            !hw.test(s) &&
            a[s] &&
            typeof i[s] == "string" &&
            s !== "0" &&
            (i[s] = a[s]);
        (i.top = t), (i.left = n);
      } else i.cssText = r._stOrig;
      (Pe.core.getCache(r).uncache = 1), e.appendChild(r);
    }
  },
  B0 = (r, e, t) => {
    let n = e,
      i = n;
    return (s) => {
      let a = Math.round(r());
      return (
        a !== n &&
          a !== i &&
          Math.abs(a - n) > 3 &&
          Math.abs(a - i) > 3 &&
          ((s = a), t && t()),
        (i = n),
        (n = s),
        s
      );
    };
  },
  cc = (r, e, t) => {
    let n = {};
    (n[e.p] = "+=" + t), Pe.set(r, n);
  },
  Km = (r, e) => {
    let t = Ur(r, e),
      n = "_scroll" + e.p2,
      i = (s, a, o, l, c) => {
        let u = i.tween,
          h = a.onComplete,
          f = {};
        o = o || t();
        let p = B0(t, o, () => {
          u.kill(), (i.tween = 0);
        });
        return (
          (c = (l && c) || 0),
          (l = l || s - o),
          u && u.kill(),
          (a[n] = s),
          (a.modifiers = f),
          (f[n] = () => p(o + l * u.ratio + c * u.ratio * u.ratio)),
          (a.onUpdate = () => {
            Qe.cache++, sr();
          }),
          (a.onComplete = () => {
            (i.tween = 0), h && h.call(u);
          }),
          (u = i.tween = Pe.to(r, a)),
          u
        );
      };
    return (
      (r[n] = t),
      (t.wheelHandler = () => i.tween && i.tween.kill() && (i.tween = 0)),
      Yt(r, "wheel", t.wheelHandler),
      He.isTouch && Yt(r, "touchmove", t.wheelHandler),
      i
    );
  };
class He {
  constructor(e, t) {
    ca ||
      He.register(Pe) ||
      console.warn("Please gsap.registerPlugin(ScrollTrigger)"),
      lf(this),
      this.init(e, t);
  }
  init(e, t) {
    if (
      ((this.progress = this.start = 0), this.vars && this.kill(!0, !0), !yo)
    ) {
      this.update = this.refresh = this.kill = Ti;
      return;
    }
    e = Gm(Bn(e) || yc(e) || e.nodeType ? { trigger: e } : e, ac);
    let {
        onUpdate: n,
        toggleClass: i,
        id: s,
        onToggle: a,
        onRefresh: o,
        scrub: l,
        trigger: c,
        pin: u,
        pinSpacing: h,
        invalidateOnRefresh: f,
        anticipatePin: p,
        onScrubComplete: g,
        onSnapComplete: m,
        once: _,
        snap: d,
        pinReparent: y,
        pinSpacer: v,
        containerAnimation: S,
        fastScrollEnd: E,
        preventOverlaps: b,
      } = e,
      M =
        e.horizontal || (e.containerAnimation && e.horizontal !== !1) ? gn : Bt,
      C = !l && l !== 0,
      x = En(e.scroller || nt),
      T = Pe.core.getCache(x),
      D = ws(x),
      N =
        ("pinType" in e ? e.pinType : Dr(x, "pinType") || (D && "fixed")) ===
        "fixed",
      L = [e.onEnter, e.onLeave, e.onEnterBack, e.onLeaveBack],
      F = C && e.toggleActions.split(" "),
      I = "markers" in e ? e.markers : ac.markers,
      j = D ? 0 : parseFloat($n(x)["border" + M.p2 + Ya]) || 0,
      A = this,
      k = e.onRefreshInit && (() => e.onRefreshInit(A)),
      G = tw(x, D, M),
      z = nw(x, D),
      oe = 0,
      te = 0,
      X = 0,
      Y = Ur(x, M),
      le,
      W,
      O,
      Me,
      ve,
      re,
      be,
      Fe,
      ae,
      _e,
      K,
      $e,
      ct,
      Ge,
      Xe,
      st,
      Et,
      P,
      w,
      $,
      ue,
      he,
      me,
      U,
      ne,
      J,
      ge,
      Te,
      Le,
      ye,
      Ae,
      xe,
      ze,
      ot,
      B,
      Q,
      fe,
      Se,
      we;
    if (
      ((A._startClamp = A._endClamp = !1),
      (A._dir = M),
      (p *= 45),
      (A.scroller = x),
      (A.scroll = S ? S.time.bind(S) : Y),
      (Me = Y()),
      (A.vars = e),
      (t = t || e.animation),
      "refreshPriority" in e &&
        ((b0 = 1), e.refreshPriority === -9999 && (Fo = A)),
      (T.tweenScroll = T.tweenScroll || { top: Km(x, Bt), left: Km(x, gn) }),
      (A.tweenTo = le = T.tweenScroll[M.p]),
      (A.scrubDuration = (de) => {
        (ze = yc(de) && de),
          ze
            ? xe
              ? xe.duration(de)
              : (xe = Pe.to(t, {
                  ease: "expo",
                  totalProgress: "+=0",
                  duration: ze,
                  paused: !0,
                  onComplete: () => g && g(A),
                }))
            : (xe && xe.progress(1).kill(), (xe = 0));
      }),
      t &&
        ((t.vars.lazy = !1),
        (t._initted && !A.isReverted) ||
          (t.vars.immediateRender !== !1 &&
            e.immediateRender !== !1 &&
            t.duration() &&
            t.render(0, !0, !0)),
        (A.animation = t.pause()),
        (t.scrollTrigger = A),
        A.scrubDuration(l),
        (ye = 0),
        s || (s = t.vars.id)),
      d &&
        ((!ss(d) || d.push) && (d = { snapTo: d }),
        "scrollBehavior" in St.style &&
          Pe.set(D ? [St, pi] : x, { scrollBehavior: "auto" }),
        Qe.forEach(
          (de) =>
            vn(de) &&
            de.target === (D ? yt.scrollingElement || pi : x) &&
            (de.smooth = !1)
        ),
        (O = vn(d.snapTo)
          ? d.snapTo
          : d.snapTo === "labels"
          ? rw(t)
          : d.snapTo === "labelsDirectional"
          ? sw(t)
          : d.directional !== !1
          ? (de, se) => od(d.snapTo)(de, pn() - te < 500 ? 0 : se.direction)
          : Pe.utils.snap(d.snapTo)),
        (ot = d.duration || { min: 0.1, max: 2 }),
        (ot = ss(ot) ? xa(ot.min, ot.max) : xa(ot, ot)),
        (B = Pe.delayedCall(d.delay || ze / 2 || 0.1, () => {
          let de = Y(),
            se = pn() - te < 500,
            pe = le.tween;
          if (
            (se || Math.abs(A.getVelocity()) < 10) &&
            !pe &&
            !du &&
            oe !== de
          ) {
            let Re = (de - re) / Ge,
              Oe = t && !C ? t.totalProgress() : Re,
              Ne = se ? 0 : ((Oe - Ae) / (pn() - xc)) * 1e3 || 0,
              tt = Pe.utils.clamp(-Re, 1 - Re, (sa(Ne / 2) * Ne) / 0.185),
              Dt = Re + (d.inertia === !1 ? 0 : tt),
              It = xa(0, 1, O(Dt, A)),
              vt = Math.round(re + It * Ge),
              { onStart: ht, onInterrupt: Pn, onComplete: R } = d;
            if (de <= be && de >= re && vt !== de) {
              if (pe && !pe._initted && pe.data <= sa(vt - de)) return;
              d.inertia === !1 && (tt = It - Re),
                le(
                  vt,
                  {
                    duration: ot(
                      sa(
                        (Math.max(sa(Dt - Oe), sa(It - Oe)) * 0.185) /
                          Ne /
                          0.05 || 0
                      )
                    ),
                    ease: d.ease || "power3",
                    data: sa(vt - de),
                    onInterrupt: () => B.restart(!0) && Pn && Pn(A),
                    onComplete: () => {
                      A.update(),
                        (oe = Y()),
                        (ye = Ae = t && !C ? t.totalProgress() : A.progress),
                        m && m(A),
                        R && R(A);
                    },
                  },
                  de,
                  tt * Ge,
                  vt - de - tt * Ge
                ),
                ht && ht(A, le.tween);
            }
          } else A.isActive && oe !== de && B.restart(!0);
        }).pause())),
      s && (uf[s] = A),
      (c = A.trigger = En(c || (u !== !0 && u))),
      (we = c && c._gsap && c._gsap.stRevert),
      we && (we = we(A)),
      (u = u === !0 ? c : En(u)),
      Bn(i) && (i = { targets: c, className: i }),
      u &&
        (h === !1 ||
          h === Kn ||
          (h =
            !h &&
            u.parentNode &&
            u.parentNode.style &&
            $n(u.parentNode).display === "flex"
              ? !1
              : Ot),
        (A.pin = u),
        (W = Pe.core.getCache(u)),
        W.spacer
          ? (Xe = W.pinState)
          : (v &&
              ((v = En(v)),
              v && !v.nodeType && (v = v.current || v.nativeElement),
              (W.spacerIsNative = !!v),
              v && (W.spacerState = lc(v))),
            (W.spacer = P = v || yt.createElement("div")),
            P.classList.add("pin-spacer"),
            s && P.classList.add("pin-spacer-" + s),
            (W.pinState = Xe = lc(u))),
        e.force3D !== !1 && Pe.set(u, { force3D: !0 }),
        (A.spacer = P = W.spacer),
        (Le = $n(u)),
        (U = Le[h + M.os2]),
        ($ = Pe.getProperty(u)),
        (ue = Pe.quickSetter(u, M.a, Kt)),
        yh(u, P, Le),
        (Et = lc(u))),
      I)
    ) {
      ($e = ss(I) ? Gm(I, Wm) : Wm),
        (_e = oc("scroller-start", s, x, M, $e, 0)),
        (K = oc("scroller-end", s, x, M, $e, 0, _e)),
        (w = _e["offset" + M.op.d2]);
      let de = En(Dr(x, "content") || x);
      (Fe = this.markerStart = oc("start", s, de, M, $e, w, 0, S)),
        (ae = this.markerEnd = oc("end", s, de, M, $e, w, 0, S)),
        S && (Se = Pe.quickSetter([Fe, ae], M.a, Kt)),
        !N &&
          !(Di.length && Dr(x, "fixedMarkers") === !0) &&
          (iw(D ? St : x),
          Pe.set([_e, K], { force3D: !0 }),
          (J = Pe.quickSetter(_e, M.a, Kt)),
          (Te = Pe.quickSetter(K, M.a, Kt)));
    }
    if (S) {
      let de = S.vars.onUpdate,
        se = S.vars.onUpdateParams;
      S.eventCallback("onUpdate", () => {
        A.update(0, 0, 1), de && de.apply(S, se || []);
      });
    }
    if (
      ((A.previous = () => Je[Je.indexOf(A) - 1]),
      (A.next = () => Je[Je.indexOf(A) + 1]),
      (A.revert = (de, se) => {
        if (!se) return A.kill(!0);
        let pe = de !== !1 || !A.enabled,
          Re = nn;
        pe !== A.isReverted &&
          (pe &&
            ((Q = Math.max(Y(), A.scroll.rec || 0)),
            (X = A.progress),
            (fe = t && t.progress())),
          Fe &&
            [Fe, ae, _e, K].forEach(
              (Oe) => (Oe.style.display = pe ? "none" : "block")
            ),
          pe && ((nn = A), A.update(pe)),
          u && (!y || !A.isActive) && (pe ? lw(u, P, Xe) : yh(u, P, $n(u), ne)),
          pe || A.update(pe),
          (nn = Re),
          (A.isReverted = pe));
      }),
      (A.refresh = (de, se, pe, Re) => {
        if ((nn || !A.enabled) && !se) return;
        if (u && de && si) {
          Yt(He, "scrollEnd", ld);
          return;
        }
        !dn && k && k(A),
          (nn = A),
          le.tween && (le.tween.kill(), (le.tween = 0)),
          xe && xe.pause(),
          f && t && t.revert({ kill: !1 }).invalidate(),
          A.isReverted || A.revert(!0, !0),
          (A._subPinOffset = !1);
        let Oe = G(),
          Ne = z(),
          tt = S ? S.duration() : tr(x, M),
          Dt = Ge <= 0.01,
          It = 0,
          vt = Re || 0,
          ht = ss(pe) ? pe.end : e.end,
          Pn = e.endTrigger || c,
          R = ss(pe)
            ? pe.start
            : e.start || (e.start === 0 || !c ? 0 : u ? "0 0" : "0 100%"),
          q = (A.pinnedContainer =
            e.pinnedContainer && En(e.pinnedContainer, A)),
          ie = (c && Math.max(0, Je.indexOf(A))) || 0,
          V = ie,
          ee,
          Ce,
          Ue,
          Be,
          Ie,
          De,
          ke,
          qe,
          lt,
          Pt,
          wt,
          Ln,
          xt;
        for (
          I &&
          ss(pe) &&
          ((Ln = Pe.getProperty(_e, M.p)), (xt = Pe.getProperty(K, M.p)));
          V--;

        )
          (De = Je[V]),
            De.end || De.refresh(0, 1) || (nn = A),
            (ke = De.pin),
            ke &&
              (ke === c || ke === u || ke === q) &&
              !De.isReverted &&
              (Pt || (Pt = []), Pt.unshift(De), De.revert(!0, !0)),
            De !== Je[V] && (ie--, V--);
        for (
          vn(R) && (R = R(A)),
            R = km(R, "start", A),
            re =
              qm(
                R,
                c,
                Oe,
                M,
                Y(),
                Fe,
                _e,
                A,
                Ne,
                j,
                N,
                tt,
                S,
                A._startClamp && "_startClamp"
              ) || (u ? -0.001 : 0),
            vn(ht) && (ht = ht(A)),
            Bn(ht) &&
              !ht.indexOf("+=") &&
              (~ht.indexOf(" ")
                ? (ht = (Bn(R) ? R.split(" ")[0] : "") + ht)
                : ((It = Ec(ht.substr(2), Oe)),
                  (ht = Bn(R)
                    ? R
                    : (S
                        ? Pe.utils.mapRange(
                            0,
                            S.duration(),
                            S.scrollTrigger.start,
                            S.scrollTrigger.end,
                            re
                          )
                        : re) + It),
                  (Pn = c))),
            ht = km(ht, "end", A),
            be =
              Math.max(
                re,
                qm(
                  ht || (Pn ? "100% 0" : tt),
                  Pn,
                  Oe,
                  M,
                  Y() + It,
                  ae,
                  K,
                  A,
                  Ne,
                  j,
                  N,
                  tt,
                  S,
                  A._endClamp && "_endClamp"
                )
              ) || -0.001,
            It = 0,
            V = ie;
          V--;

        )
          (De = Je[V]),
            (ke = De.pin),
            ke &&
              De.start - De._pinPush <= re &&
              !S &&
              De.end > 0 &&
              ((ee =
                De.end - (A._startClamp ? Math.max(0, De.start) : De.start)),
              ((ke === c && De.start - De._pinPush < re) || ke === q) &&
                isNaN(R) &&
                (It += ee * (1 - De.progress)),
              ke === u && (vt += ee));
        if (
          ((re += It),
          (be += It),
          A._startClamp && (A._startClamp += It),
          A._endClamp &&
            !dn &&
            ((A._endClamp = be || -0.001), (be = Math.min(be, tr(x, M)))),
          (Ge = be - re || ((re -= 0.01) && 0.001)),
          Dt && (X = Pe.utils.clamp(0, 1, Pe.utils.normalize(re, be, Q))),
          (A._pinPush = vt),
          Fe &&
            It &&
            ((ee = {}),
            (ee[M.a] = "+=" + It),
            q && (ee[M.p] = "-=" + Y()),
            Pe.set([Fe, ae], ee)),
          u)
        )
          (ee = $n(u)),
            (Be = M === Bt),
            (Ue = Y()),
            (he = parseFloat($(M.a)) + vt),
            !tt &&
              be > 1 &&
              ((wt = (D ? yt.scrollingElement || pi : x).style),
              (wt = { style: wt, value: wt["overflow" + M.a.toUpperCase()] }),
              D &&
                $n(St)["overflow" + M.a.toUpperCase()] !== "scroll" &&
                (wt.style["overflow" + M.a.toUpperCase()] = "scroll")),
            yh(u, P, ee),
            (Et = lc(u)),
            (Ce = Ji(u, !0)),
            (qe = N && Ur(x, Be ? gn : Bt)()),
            h &&
              ((ne = [h + M.os2, Ge + vt + Kt]),
              (ne.t = P),
              (V = h === Ot ? cf(u, M) + Ge + vt : 0),
              V && ne.push(M.d, V + Kt),
              Ca(ne),
              q &&
                Je.forEach((je) => {
                  je.pin === q &&
                    je.vars.pinSpacing !== !1 &&
                    (je._subPinOffset = !0);
                }),
              N && Y(Q)),
            N &&
              ((Ie = {
                top: Ce.top + (Be ? Ue - re : qe) + Kt,
                left: Ce.left + (Be ? qe : Ue - re) + Kt,
                boxSizing: "border-box",
                position: "fixed",
              }),
              (Ie[vs] = Ie["max" + Ya] = Math.ceil(Ce.width) + Kt),
              (Ie[xs] = Ie["max" + ad] = Math.ceil(Ce.height) + Kt),
              (Ie[Kn] =
                Ie[Kn + Oo] =
                Ie[Kn + Io] =
                Ie[Kn + Uo] =
                Ie[Kn + No] =
                  "0"),
              (Ie[Ot] = ee[Ot]),
              (Ie[Ot + Oo] = ee[Ot + Oo]),
              (Ie[Ot + Io] = ee[Ot + Io]),
              (Ie[Ot + Uo] = ee[Ot + Uo]),
              (Ie[Ot + No] = ee[Ot + No]),
              (st = uw(Xe, Ie, y)),
              dn && Y(0)),
            t
              ? ((lt = t._initted),
                mh(1),
                t.render(t.duration(), !0, !0),
                (me = $(M.a) - he + Ge + vt),
                (ge = Math.abs(Ge - me) > 1),
                N && ge && st.splice(st.length - 2, 2),
                t.render(0, !0, !0),
                lt || t.invalidate(!0),
                t.parent || t.totalTime(t.totalTime()),
                mh(0))
              : (me = Ge),
            wt &&
              (wt.value
                ? (wt.style["overflow" + M.a.toUpperCase()] = wt.value)
                : wt.style.removeProperty("overflow-" + M.a));
        else if (c && Y() && !S)
          for (Ce = c.parentNode; Ce && Ce !== St; )
            Ce._pinOffset && ((re -= Ce._pinOffset), (be -= Ce._pinOffset)),
              (Ce = Ce.parentNode);
        Pt && Pt.forEach((je) => je.revert(!1, !0)),
          (A.start = re),
          (A.end = be),
          (Me = ve = dn ? Q : Y()),
          !S && !dn && (Me < Q && Y(Q), (A.scroll.rec = 0)),
          A.revert(!1, !0),
          (te = pn()),
          B && ((oe = -1), A.isActive && Y(re + Ge * X), B.restart(!0)),
          (nn = 0),
          t &&
            C &&
            (t._initted || fe) &&
            t.progress() !== fe &&
            t.progress(fe || 0, !0).render(t.time(), !0, !0),
          (Dt || X !== A.progress || S) &&
            (t &&
              !C &&
              t.totalProgress(
                S && re < -0.001 && !X ? Pe.utils.normalize(re, be, 0) : X,
                !0
              ),
            (A.progress = Dt || (Me - re) / Ge === X ? 0 : X)),
          u && h && (P._pinOffset = Math.round(A.progress * me)),
          xe && xe.invalidate(),
          isNaN(Ln) ||
            ((Ln -= Pe.getProperty(_e, M.p)),
            (xt -= Pe.getProperty(K, M.p)),
            cc(_e, M, Ln),
            cc(Fe, M, Ln - (Re || 0)),
            cc(K, M, xt),
            cc(ae, M, xt - (Re || 0))),
          Dt && !dn && A.update(),
          o && !dn && !ct && ((ct = !0), o(A), (ct = !1));
      }),
      (A.getVelocity = () => ((Y() - ve) / (pn() - xc)) * 1e3 || 0),
      (A.endAnimation = () => {
        ho(A.callbackAnimation),
          t &&
            (xe
              ? xe.progress(1)
              : t.paused()
              ? C || ho(t, A.direction < 0, 1)
              : ho(t, t.reversed()));
      }),
      (A.labelToScroll = (de) =>
        (t &&
          t.labels &&
          (re || A.refresh() || re) + (t.labels[de] / t.duration()) * Ge) ||
        0),
      (A.getTrailing = (de) => {
        let se = Je.indexOf(A),
          pe = A.direction > 0 ? Je.slice(0, se).reverse() : Je.slice(se + 1);
        return (
          Bn(de) ? pe.filter((Re) => Re.vars.preventOverlaps === de) : pe
        ).filter((Re) => (A.direction > 0 ? Re.end <= re : Re.start >= be));
      }),
      (A.update = (de, se, pe) => {
        if (S && !pe && !de) return;
        let Re = dn === !0 ? Q : A.scroll(),
          Oe = de ? 0 : (Re - re) / Ge,
          Ne = Oe < 0 ? 0 : Oe > 1 ? 1 : Oe || 0,
          tt = A.progress,
          Dt,
          It,
          vt,
          ht,
          Pn,
          R,
          q,
          ie;
        if (
          (se &&
            ((ve = Me),
            (Me = S ? Y() : Re),
            d && ((Ae = ye), (ye = t && !C ? t.totalProgress() : Ne))),
          p &&
            !Ne &&
            u &&
            !nn &&
            !nc &&
            si &&
            re < Re + ((Re - ve) / (pn() - xc)) * p &&
            (Ne = 1e-4),
          Ne !== tt && A.enabled)
        ) {
          if (
            ((Dt = A.isActive = !!Ne && Ne < 1),
            (It = !!tt && tt < 1),
            (R = Dt !== It),
            (Pn = R || !!Ne != !!tt),
            (A.direction = Ne > tt ? 1 : -1),
            (A.progress = Ne),
            Pn &&
              !nn &&
              ((vt = Ne && !tt ? 0 : Ne === 1 ? 1 : tt === 1 ? 2 : 3),
              C &&
                ((ht = (!R && F[vt + 1] !== "none" && F[vt + 1]) || F[vt]),
                (ie = t && (ht === "complete" || ht === "reset" || ht in t)))),
            b &&
              (R || ie) &&
              (ie || l || !t) &&
              (vn(b)
                ? b(A)
                : A.getTrailing(b).forEach((V) => V.endAnimation())),
            C ||
              (xe && !nn && !nc
                ? (xe._dp._time - xe._start !== xe._time &&
                    xe.render(xe._dp._time - xe._start),
                  xe.resetTo
                    ? xe.resetTo("totalProgress", Ne, t._tTime / t._tDur)
                    : ((xe.vars.totalProgress = Ne), xe.invalidate().restart()))
                : t && t.totalProgress(Ne, !!(nn && (te || de)))),
            u)
          ) {
            if ((de && h && (P.style[h + M.os2] = U), !N)) ue(Eo(he + me * Ne));
            else if (Pn) {
              if (
                ((q = !de && Ne > tt && be + 1 > Re && Re + 1 >= tr(x, M)), y)
              )
                if (!de && (Dt || q)) {
                  let V = Ji(u, !0),
                    ee = Re - re;
                  jm(
                    u,
                    St,
                    V.top + (M === Bt ? ee : 0) + Kt,
                    V.left + (M === Bt ? 0 : ee) + Kt
                  );
                } else jm(u, P);
              Ca(Dt || q ? st : Et),
                (ge && Ne < 1 && Dt) || ue(he + (Ne === 1 && !q ? me : 0));
            }
          }
          d && !le.tween && !nn && !nc && B.restart(!0),
            i &&
              (R || (_ && Ne && (Ne < 1 || !_h))) &&
              Wc(i.targets).forEach((V) =>
                V.classList[Dt || _ ? "add" : "remove"](i.className)
              ),
            n && !C && !de && n(A),
            Pn && !nn
              ? (C &&
                  (ie &&
                    (ht === "complete"
                      ? t.pause().totalProgress(1)
                      : ht === "reset"
                      ? t.restart(!0).pause()
                      : ht === "restart"
                      ? t.restart(!0)
                      : t[ht]()),
                  n && n(A)),
                (R || !_h) &&
                  (a && R && vh(A, a),
                  L[vt] && vh(A, L[vt]),
                  _ && (Ne === 1 ? A.kill(!1, 1) : (L[vt] = 0)),
                  R || ((vt = Ne === 1 ? 1 : 3), L[vt] && vh(A, L[vt]))),
                E &&
                  !Dt &&
                  Math.abs(A.getVelocity()) > (yc(E) ? E : 2500) &&
                  (ho(A.callbackAnimation),
                  xe ? xe.progress(1) : ho(t, ht === "reverse" ? 1 : !Ne, 1)))
              : C && n && !nn && n(A);
        }
        if (Te) {
          let V = S ? (Re / S.duration()) * (S._caScrollDist || 0) : Re;
          J(V + (_e._isFlipped ? 1 : 0)), Te(V);
        }
        Se && Se((-Re / S.duration()) * (S._caScrollDist || 0));
      }),
      (A.enable = (de, se) => {
        A.enabled ||
          ((A.enabled = !0),
          Yt(x, "resize", So),
          Yt(D ? yt : x, "scroll", aa),
          k && Yt(He, "refreshInit", k),
          de !== !1 && ((A.progress = X = 0), (Me = ve = oe = Y())),
          se !== !1 && A.refresh());
      }),
      (A.getTween = (de) => (de && le ? le.tween : xe)),
      (A.setPositions = (de, se, pe, Re) => {
        if (S) {
          let Oe = S.scrollTrigger,
            Ne = S.duration(),
            tt = Oe.end - Oe.start;
          (de = Oe.start + (tt * de) / Ne), (se = Oe.start + (tt * se) / Ne);
        }
        A.refresh(
          !1,
          !1,
          {
            start: zm(de, pe && !!A._startClamp),
            end: zm(se, pe && !!A._endClamp),
          },
          Re
        ),
          A.update();
      }),
      (A.adjustPinSpacing = (de) => {
        if (ne && de) {
          let se = ne.indexOf(M.d) + 1;
          (ne[se] = parseFloat(ne[se]) + de + Kt),
            (ne[1] = parseFloat(ne[1]) + de + Kt),
            Ca(ne);
        }
      }),
      (A.disable = (de, se) => {
        if (
          A.enabled &&
          (de !== !1 && A.revert(!0, !0),
          (A.enabled = A.isActive = !1),
          se || (xe && xe.pause()),
          (Q = 0),
          W && (W.uncache = 1),
          k && Xt(He, "refreshInit", k),
          B && (B.pause(), le.tween && le.tween.kill() && (le.tween = 0)),
          !D)
        ) {
          let pe = Je.length;
          for (; pe--; ) if (Je[pe].scroller === x && Je[pe] !== A) return;
          Xt(x, "resize", So), Xt(x, "scroll", aa);
        }
      }),
      (A.kill = (de, se) => {
        A.disable(de, se), xe && !se && xe.kill(), s && delete uf[s];
        let pe = Je.indexOf(A);
        pe >= 0 && Je.splice(pe, 1),
          pe === fn && Mc > 0 && fn--,
          (pe = 0),
          Je.forEach((Re) => Re.scroller === A.scroller && (pe = 1)),
          pe || dn || (A.scroll.rec = 0),
          t &&
            ((t.scrollTrigger = null),
            de && t.revert({ kill: !1 }),
            se || t.kill()),
          Fe &&
            [Fe, ae, _e, K].forEach(
              (Re) => Re.parentNode && Re.parentNode.removeChild(Re)
            ),
          Fo === A && (Fo = 0),
          u &&
            (W && (W.uncache = 1),
            (pe = 0),
            Je.forEach((Re) => Re.pin === u && pe++),
            pe || (W.spacer = 0)),
          e.onKill && e.onKill(A);
      }),
      Je.push(A),
      A.enable(!1, !1),
      we && we(A),
      t && t.add && !Ge)
    ) {
      let de = A.update;
      (A.update = () => {
        (A.update = de), re || be || A.refresh();
      }),
        Pe.delayedCall(0.01, A.update),
        (Ge = 0.01),
        (re = be = 0);
    } else A.refresh();
    u && ow();
  }
  static register(e) {
    return (
      ca ||
        ((Pe = e || L0()), P0() && window.document && He.enable(), (ca = yo)),
      ca
    );
  }
  static defaults(e) {
    if (e) for (let t in e) ac[t] = e[t];
    return ac;
  }
  static disable(e, t) {
    (yo = 0),
      Je.forEach((n) => n[t ? "kill" : "disable"](e)),
      Xt(nt, "wheel", aa),
      Xt(yt, "scroll", aa),
      clearInterval(tc),
      Xt(yt, "touchcancel", Ti),
      Xt(St, "touchstart", Ti),
      rc(Xt, yt, "pointerdown,touchstart,mousedown", Hm),
      rc(Xt, yt, "pointerup,touchend,mouseup", Vm),
      Gc.kill(),
      ic(Xt);
    for (let n = 0; n < Qe.length; n += 3)
      sc(Xt, Qe[n], Qe[n + 1]), sc(Xt, Qe[n], Qe[n + 2]);
  }
  static enable() {
    if (
      ((nt = window),
      (yt = document),
      (pi = yt.documentElement),
      (St = yt.body),
      Pe &&
        ((Wc = Pe.utils.toArray),
        (xa = Pe.utils.clamp),
        (lf = Pe.core.context || Ti),
        (mh = Pe.core.suppressOverwrites || Ti),
        (id = nt.history.scrollRestoration || "auto"),
        (hf = nt.pageYOffset),
        Pe.core.globals("ScrollTrigger", He),
        St))
    ) {
      (yo = 1),
        C0(),
        Ft.register(Pe),
        (He.isTouch = Ft.isTouch),
        (xr =
          Ft.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent)),
        Yt(nt, "wheel", aa),
        (M0 = [nt, yt, pi, St]),
        Pe.matchMedia
          ? ((He.matchMedia = (a) => {
              let o = Pe.matchMedia(),
                l;
              for (l in a) o.add(l, a[l]);
              return o;
            }),
            Pe.addEventListener("matchMediaInit", () => cd()),
            Pe.addEventListener("matchMediaRevert", () => U0()),
            Pe.addEventListener("matchMedia", () => {
              us(0, 1), Cs("matchMedia");
            }),
            Pe.matchMedia("(orientation: portrait)", () => (xh(), xh)))
          : console.warn("Requires GSAP 3.11.0 or later"),
        xh(),
        Yt(yt, "scroll", aa);
      let e = St.style,
        t = e.borderTopStyle,
        n = Pe.core.Animation.prototype,
        i,
        s;
      for (
        n.revert ||
          Object.defineProperty(n, "revert", {
            value: function () {
              return this.time(-0.01, !0);
            },
          }),
          e.borderTopStyle = "solid",
          i = Ji(St),
          Bt.m = Math.round(i.top + Bt.sc()) || 0,
          gn.m = Math.round(i.left + gn.sc()) || 0,
          t ? (e.borderTopStyle = t) : e.removeProperty("border-top-style"),
          tc = setInterval(Xm, 250),
          Pe.delayedCall(0.5, () => (nc = 0)),
          Yt(yt, "touchcancel", Ti),
          Yt(St, "touchstart", Ti),
          rc(Yt, yt, "pointerdown,touchstart,mousedown", Hm),
          rc(Yt, yt, "pointerup,touchend,mouseup", Vm),
          of = Pe.utils.checkPrefix("transform"),
          bc.push(of),
          ca = pn(),
          Gc = Pe.delayedCall(0.2, us).pause(),
          ua = [
            yt,
            "visibilitychange",
            () => {
              let a = nt.innerWidth,
                o = nt.innerHeight;
              yt.hidden ? ((Fm = a), (Bm = o)) : (Fm !== a || Bm !== o) && So();
            },
            yt,
            "DOMContentLoaded",
            us,
            nt,
            "load",
            us,
            nt,
            "resize",
            So,
          ],
          ic(Yt),
          Je.forEach((a) => a.enable(0, 1)),
          s = 0;
        s < Qe.length;
        s += 3
      )
        sc(Xt, Qe[s], Qe[s + 1]), sc(Xt, Qe[s], Qe[s + 2]);
    }
  }
  static config(e) {
    "limitCallbacks" in e && (_h = !!e.limitCallbacks);
    let t = e.syncInterval;
    (t && clearInterval(tc)) || ((tc = t) && setInterval(Xm, t)),
      "ignoreMobileResize" in e &&
        (A0 = He.isTouch === 1 && e.ignoreMobileResize),
      "autoRefreshEvents" in e &&
        (ic(Xt) || ic(Yt, e.autoRefreshEvents || "none"),
        (T0 = (e.autoRefreshEvents + "").indexOf("resize") === -1));
  }
  static scrollerProxy(e, t) {
    let n = En(e),
      i = Qe.indexOf(n),
      s = ws(n);
    ~i && Qe.splice(i, s ? 6 : 2),
      t && (s ? Di.unshift(nt, t, St, t, pi, t) : Di.unshift(n, t));
  }
  static clearMatchMedia(e) {
    Je.forEach((t) => t._ctx && t._ctx.query === e && t._ctx.kill(!0, !0));
  }
  static isInViewport(e, t, n) {
    let i = (Bn(e) ? En(e) : e).getBoundingClientRect(),
      s = i[n ? vs : xs] * t || 0;
    return n
      ? i.right - s > 0 && i.left + s < nt.innerWidth
      : i.bottom - s > 0 && i.top + s < nt.innerHeight;
  }
  static positionInViewport(e, t, n) {
    Bn(e) && (e = En(e));
    let i = e.getBoundingClientRect(),
      s = i[n ? vs : xs],
      a =
        t == null
          ? s / 2
          : t in Xc
          ? Xc[t] * s
          : ~t.indexOf("%")
          ? (parseFloat(t) * s) / 100
          : parseFloat(t) || 0;
    return n ? (i.left + a) / nt.innerWidth : (i.top + a) / nt.innerHeight;
  }
  static killAll(e) {
    if (
      (Je.slice(0).forEach((t) => t.vars.id !== "ScrollSmoother" && t.kill()),
      e !== !0)
    ) {
      let t = Rs.killAll || [];
      (Rs = {}), t.forEach((n) => n());
    }
  }
}
He.version = "3.12.1";
He.saveStyles = (r) =>
  r
    ? Wc(r).forEach((e) => {
        if (e && e.style) {
          let t = Fn.indexOf(e);
          t >= 0 && Fn.splice(t, 5),
            Fn.push(
              e,
              e.style.cssText,
              e.getBBox && e.getAttribute("transform"),
              Pe.core.getCache(e),
              lf()
            );
        }
      })
    : Fn;
He.revert = (r, e) => cd(!r, e);
He.create = (r, e) => new He(r, e);
He.refresh = (r) => (r ? So() : (ca || He.register()) && us(!0));
He.update = (r) => ++Qe.cache && sr(r === !0 ? 2 : 0);
He.clearScrollMemory = F0;
He.maxScroll = (r, e) => tr(r, e ? gn : Bt);
He.getScrollFunc = (r, e) => Ur(En(r), e ? gn : Bt);
He.getById = (r) => uf[r];
He.getAll = () => Je.filter((r) => r.vars.id !== "ScrollSmoother");
He.isScrolling = () => !!si;
He.snapDirectional = od;
He.addEventListener = (r, e) => {
  let t = Rs[r] || (Rs[r] = []);
  ~t.indexOf(e) || t.push(e);
};
He.removeEventListener = (r, e) => {
  let t = Rs[r],
    n = t && t.indexOf(e);
  n >= 0 && t.splice(n, 1);
};
He.batch = (r, e) => {
  let t = [],
    n = {},
    i = e.interval || 0.016,
    s = e.batchMax || 1e9,
    a = (l, c) => {
      let u = [],
        h = [],
        f = Pe.delayedCall(i, () => {
          c(u, h), (u = []), (h = []);
        }).pause();
      return (p) => {
        u.length || f.restart(!0),
          u.push(p.trigger),
          h.push(p),
          s <= u.length && f.progress(1);
      };
    },
    o;
  for (o in e)
    n[o] =
      o.substr(0, 2) === "on" && vn(e[o]) && o !== "onRefreshInit"
        ? a(o, e[o])
        : e[o];
  return (
    vn(s) && ((s = s()), Yt(He, "refresh", () => (s = e.batchMax()))),
    Wc(r).forEach((l) => {
      let c = {};
      for (o in n) c[o] = n[o];
      (c.trigger = l), t.push(He.create(c));
    }),
    t
  );
};
let $m = (r, e, t, n) => (
    e > n ? r(n) : e < 0 && r(0),
    t > n ? (n - e) / (t - e) : t < 0 ? e / (e - t) : 1
  ),
  Ac = (r, e) => {
    e === !0
      ? r.style.removeProperty("touch-action")
      : (r.style.touchAction =
          e === !0
            ? "auto"
            : e
            ? "pan-" + e + (Ft.isTouch ? " pinch-zoom" : "")
            : "none"),
      r === pi && Ac(St, e);
  },
  uc = { auto: 1, scroll: 1 },
  fw = ({ event: r, target: e, axis: t }) => {
    let n = (r.changedTouches ? r.changedTouches[0] : r).target,
      i = n._gsap || Pe.core.getCache(n),
      s = pn(),
      a;
    if (!i._isScrollT || s - i._isScrollT > 2e3) {
      for (
        ;
        n &&
        n !== St &&
        ((n.scrollHeight <= n.clientHeight && n.scrollWidth <= n.clientWidth) ||
          !(uc[(a = $n(n)).overflowY] || uc[a.overflowX]));

      )
        n = n.parentNode;
      (i._isScroll =
        n &&
        n !== e &&
        !ws(n) &&
        (uc[(a = $n(n)).overflowY] || uc[a.overflowX])),
        (i._isScrollT = s);
    }
    (i._isScroll || t === "x") && (r.stopPropagation(), (r._gsapAllow = !0));
  },
  k0 = (r, e, t, n) =>
    Ft.create({
      target: r,
      capture: !0,
      debounce: !1,
      lockAxis: !0,
      type: e,
      onWheel: (n = n && fw),
      onPress: n,
      onDrag: n,
      onScroll: n,
      onEnable: () => t && Yt(yt, Ft.eventTypes[0], Jm, !1, !0),
      onDisable: () => Xt(yt, Ft.eventTypes[0], Jm, !0),
    }),
  dw = /(input|label|select|textarea)/i,
  Zm,
  Jm = (r) => {
    let e = dw.test(r.target.tagName);
    (e || Zm) && ((r._gsapAllow = !0), (Zm = e));
  },
  pw = (r) => {
    ss(r) || (r = {}),
      (r.preventDefault = r.isNormalizer = r.allowClicks = !0),
      r.type || (r.type = "wheel,touch"),
      (r.debounce = !!r.debounce),
      (r.id = r.id || "normalizer");
    let {
        normalizeScrollX: e,
        momentum: t,
        allowNestedScroll: n,
        onRelease: i,
      } = r,
      s,
      a,
      o = En(r.target) || pi,
      l = Pe.core.globals().ScrollSmoother,
      c = l && l.get(),
      u =
        xr &&
        ((r.content && En(r.content)) ||
          (c && r.content !== !1 && !c.smooth() && c.content())),
      h = Ur(o, Bt),
      f = Ur(o, gn),
      p = 1,
      g =
        (Ft.isTouch && nt.visualViewport
          ? nt.visualViewport.scale * nt.visualViewport.width
          : nt.outerWidth) / nt.innerWidth,
      m = 0,
      _ = vn(t) ? () => t(s) : () => t || 2.8,
      d,
      y,
      v = k0(o, r.type, !0, n),
      S = () => (y = !1),
      E = Ti,
      b = Ti,
      M = () => {
        (a = tr(o, Bt)),
          (b = xa(xr ? 1 : 0, a)),
          e && (E = xa(0, tr(o, gn))),
          (d = ys);
      },
      C = () => {
        (u._gsap.y = Eo(parseFloat(u._gsap.y) + h.offset) + "px"),
          (u.style.transform =
            "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " +
            parseFloat(u._gsap.y) +
            ", 0, 1)"),
          (h.offset = h.cacheID = 0);
      },
      x = () => {
        if (y) {
          requestAnimationFrame(S);
          let I = Eo(s.deltaY / 2),
            j = b(h.v - I);
          if (u && j !== h.v + h.offset) {
            h.offset = j - h.v;
            let A = Eo((parseFloat(u && u._gsap.y) || 0) - h.offset);
            (u.style.transform =
              "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " +
              A +
              ", 0, 1)"),
              (u._gsap.y = A + "px"),
              (h.cacheID = Qe.cache),
              sr();
          }
          return !0;
        }
        h.offset && C(), (y = !0);
      },
      T,
      D,
      N,
      L,
      F = () => {
        M(),
          T.isActive() &&
            T.vars.scrollY > a &&
            (h() > a ? T.progress(1) && h(a) : T.resetTo("scrollY", a));
      };
    return (
      u && Pe.set(u, { y: "+=0" }),
      (r.ignoreCheck = (I) =>
        (xr && I.type === "touchmove" && x()) ||
        (p > 1.05 && I.type !== "touchstart") ||
        s.isGesturing ||
        (I.touches && I.touches.length > 1)),
      (r.onPress = () => {
        y = !1;
        let I = p;
        (p = Eo(((nt.visualViewport && nt.visualViewport.scale) || 1) / g)),
          T.pause(),
          I !== p && Ac(o, p > 1.01 ? !0 : e ? !1 : "x"),
          (D = f()),
          (N = h()),
          M(),
          (d = ys);
      }),
      (r.onRelease = r.onGestureStart =
        (I, j) => {
          if ((h.offset && C(), !j)) L.restart(!0);
          else {
            Qe.cache++;
            let A = _(),
              k,
              G;
            e &&
              ((k = f()),
              (G = k + (A * 0.05 * -I.velocityX) / 0.227),
              (A *= $m(f, k, G, tr(o, gn))),
              (T.vars.scrollX = E(G))),
              (k = h()),
              (G = k + (A * 0.05 * -I.velocityY) / 0.227),
              (A *= $m(h, k, G, tr(o, Bt))),
              (T.vars.scrollY = b(G)),
              T.invalidate().duration(A).play(0.01),
              ((xr && T.vars.scrollY >= a) || k >= a - 1) &&
                Pe.to({}, { onUpdate: F, duration: A });
          }
          i && i(I);
        }),
      (r.onWheel = () => {
        T._ts && T.pause(), pn() - m > 1e3 && ((d = 0), (m = pn()));
      }),
      (r.onChange = (I, j, A, k, G) => {
        if (
          (ys !== d && M(),
          j && e && f(E(k[2] === j ? D + (I.startX - I.x) : f() + j - k[1])),
          A)
        ) {
          h.offset && C();
          let z = G[2] === A,
            oe = z ? N + I.startY - I.y : h() + A - G[1],
            te = b(oe);
          z && oe !== te && (N += te - oe), h(te);
        }
        (A || j) && sr();
      }),
      (r.onEnable = () => {
        Ac(o, e ? !1 : "x"),
          He.addEventListener("refresh", F),
          Yt(nt, "resize", F),
          h.smooth &&
            ((h.target.style.scrollBehavior = "auto"),
            (h.smooth = f.smooth = !1)),
          v.enable();
      }),
      (r.onDisable = () => {
        Ac(o, !0),
          Xt(nt, "resize", F),
          He.removeEventListener("refresh", F),
          v.kill();
      }),
      (r.lockAxis = r.lockAxis !== !1),
      (s = new Ft(r)),
      (s.iOS = xr),
      xr && !h() && h(1),
      xr && Pe.ticker.add(Ti),
      (L = s._dc),
      (T = Pe.to(s, {
        ease: "power4",
        paused: !0,
        scrollX: e ? "+=0.1" : "+=0",
        scrollY: "+=0.1",
        modifiers: { scrollY: B0(h, h(), () => T.pause()) },
        onUpdate: sr,
        onComplete: L.vars.onComplete,
      })),
      s
    );
  };
He.sort = (r) =>
  Je.sort(
    r ||
      ((e, t) =>
        (e.vars.refreshPriority || 0) * -1e6 +
        e.start -
        (t.start + (t.vars.refreshPriority || 0) * -1e6))
  );
He.observe = (r) => new Ft(r);
He.normalizeScroll = (r) => {
  if (typeof r > "u") return Un;
  if (r === !0 && Un) return Un.enable();
  if (r === !1) return Un && Un.kill();
  let e = r instanceof Ft ? r : pw(r);
  return Un && Un.target === e.target && Un.kill(), ws(e.target) && (Un = e), e;
};
He.core = {
  _getVelocityProp: af,
  _inputObserver: k0,
  _scrollers: Qe,
  _proxies: Di,
  bridge: {
    ss: () => {
      si || Cs("scrollStart"), (si = pn());
    },
    ref: () => nn,
  },
};
L0() && Pe.registerPlugin(He);
function Qm(r, e) {
  if (e === wx)
    return (
      console.warn(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
      ),
      r
    );
  if (e === Dh || e === z_) {
    let t = r.getIndex();
    if (t === null) {
      const a = [],
        o = r.getAttribute("position");
      if (o !== void 0) {
        for (let l = 0; l < o.count; l++) a.push(l);
        r.setIndex(a), (t = r.getIndex());
      } else
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
          ),
          r
        );
    }
    const n = t.count - 2,
      i = [];
    if (e === Dh)
      for (let a = 1; a <= n; a++)
        i.push(t.getX(0)), i.push(t.getX(a)), i.push(t.getX(a + 1));
    else
      for (let a = 0; a < n; a++)
        a % 2 === 0
          ? (i.push(t.getX(a)), i.push(t.getX(a + 1)), i.push(t.getX(a + 2)))
          : (i.push(t.getX(a + 2)), i.push(t.getX(a + 1)), i.push(t.getX(a)));
    i.length / 3 !== n &&
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
      );
    const s = r.clone();
    return s.setIndex(i), s.clearGroups(), s;
  } else
    return (
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
        e
      ),
      r
    );
}
class mw extends pl {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (t) {
        return new yw(t);
      }),
      this.register(function (t) {
        return new ww(t);
      }),
      this.register(function (t) {
        return new Rw(t);
      }),
      this.register(function (t) {
        return new Cw(t);
      }),
      this.register(function (t) {
        return new Sw(t);
      }),
      this.register(function (t) {
        return new Mw(t);
      }),
      this.register(function (t) {
        return new bw(t);
      }),
      this.register(function (t) {
        return new Tw(t);
      }),
      this.register(function (t) {
        return new xw(t);
      }),
      this.register(function (t) {
        return new Aw(t);
      }),
      this.register(function (t) {
        return new Ew(t);
      }),
      this.register(function (t) {
        return new gw(t);
      }),
      this.register(function (t) {
        return new Pw(t);
      }),
      this.register(function (t) {
        return new Lw(t);
      });
  }
  load(e, t, n, i) {
    const s = this;
    let a;
    this.resourcePath !== ""
      ? (a = this.resourcePath)
      : this.path !== ""
      ? (a = this.path)
      : (a = Bh.extractUrlBase(e)),
      this.manager.itemStart(e);
    const o = function (c) {
        i ? i(c) : console.error(c),
          s.manager.itemError(e),
          s.manager.itemEnd(e);
      },
      l = new mg(this.manager);
    l.setPath(this.path),
      l.setResponseType("arraybuffer"),
      l.setRequestHeader(this.requestHeader),
      l.setWithCredentials(this.withCredentials),
      l.load(
        e,
        function (c) {
          try {
            s.parse(
              c,
              a,
              function (u) {
                t(u), s.manager.itemEnd(e);
              },
              o
            );
          } catch (u) {
            o(u);
          }
        },
        n,
        o
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return (
      this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      this.pluginCallbacks.indexOf(e) !== -1 &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, n, i) {
    let s;
    const a = {},
      o = {},
      l = new TextDecoder();
    if (typeof e == "string") s = JSON.parse(e);
    else if (e instanceof ArrayBuffer)
      if (l.decode(new Uint8Array(e, 0, 4)) === z0) {
        try {
          a[at.KHR_BINARY_GLTF] = new Dw(e);
        } catch (h) {
          i && i(h);
          return;
        }
        s = JSON.parse(a[at.KHR_BINARY_GLTF].content);
      } else s = JSON.parse(l.decode(e));
    else s = e;
    if (s.asset === void 0 || s.asset.version[0] < 2) {
      i &&
        i(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        );
      return;
    }
    const c = new Xw(s, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    c.fileLoader.setRequestHeader(this.requestHeader);
    for (let u = 0; u < this.pluginCallbacks.length; u++) {
      const h = this.pluginCallbacks[u](c);
      (o[h.name] = h), (a[h.name] = !0);
    }
    if (s.extensionsUsed)
      for (let u = 0; u < s.extensionsUsed.length; ++u) {
        const h = s.extensionsUsed[u],
          f = s.extensionsRequired || [];
        switch (h) {
          case at.KHR_MATERIALS_UNLIT:
            a[h] = new vw();
            break;
          case at.KHR_DRACO_MESH_COMPRESSION:
            a[h] = new Iw(s, this.dracoLoader);
            break;
          case at.KHR_TEXTURE_TRANSFORM:
            a[h] = new Nw();
            break;
          case at.KHR_MESH_QUANTIZATION:
            a[h] = new Ow();
            break;
          default:
            f.indexOf(h) >= 0 &&
              o[h] === void 0 &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + h + '".');
        }
      }
    c.setExtensions(a), c.setPlugins(o), c.parse(n, i);
  }
  parseAsync(e, t) {
    const n = this;
    return new Promise(function (i, s) {
      n.parse(e, t, i, s);
    });
  }
}
function _w() {
  let r = {};
  return {
    get: function (e) {
      return r[e];
    },
    add: function (e, t) {
      r[e] = t;
    },
    remove: function (e) {
      delete r[e];
    },
    removeAll: function () {
      r = {};
    },
  };
}
const at = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
};
class gw {
  constructor(e) {
    (this.parser = e),
      (this.name = at.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || [];
    for (let n = 0, i = t.length; n < i; n++) {
      const s = t[n];
      s.extensions &&
        s.extensions[this.name] &&
        s.extensions[this.name].light !== void 0 &&
        e._addNodeRef(this.cache, s.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser,
      n = "light:" + e;
    let i = t.cache.get(n);
    if (i) return i;
    const s = t.json,
      l = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[e];
    let c;
    const u = new Ke(16777215);
    l.color !== void 0 && u.fromArray(l.color);
    const h = l.range !== void 0 ? l.range : 0;
    switch (l.type) {
      case "directional":
        (c = new yT(u)), c.target.position.set(0, 0, -1), c.add(c.target);
        break;
      case "point":
        (c = new vT(u)), (c.distance = h);
        break;
      case "spot":
        (c = new _T(u)),
          (c.distance = h),
          (l.spot = l.spot || {}),
          (l.spot.innerConeAngle =
            l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0),
          (l.spot.outerConeAngle =
            l.spot.outerConeAngle !== void 0
              ? l.spot.outerConeAngle
              : Math.PI / 4),
          (c.angle = l.spot.outerConeAngle),
          (c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle),
          c.target.position.set(0, 0, -1),
          c.add(c.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type);
    }
    return (
      c.position.set(0, 0, 0),
      (c.decay = 2),
      yr(c, l),
      l.intensity !== void 0 && (c.intensity = l.intensity),
      (c.name = t.createUniqueName(l.name || "light_" + e)),
      (i = Promise.resolve(c)),
      t.cache.add(n, i),
      i
    );
  }
  getDependency(e, t) {
    if (e === "light") return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this,
      n = this.parser,
      s = n.json.nodes[e],
      o = ((s.extensions && s.extensions[this.name]) || {}).light;
    return o === void 0
      ? null
      : this._loadLight(o).then(function (l) {
          return n._getNodeRef(t.cache, o, l);
        });
  }
}
class vw {
  constructor() {
    this.name = at.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Sr;
  }
  extendParams(e, t, n) {
    const i = [];
    (e.color = new Ke(1, 1, 1)), (e.opacity = 1);
    const s = t.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const a = s.baseColorFactor;
        e.color.fromArray(a), (e.opacity = a[3]);
      }
      s.baseColorTexture !== void 0 &&
        i.push(n.assignTexture(e, "map", s.baseColorTexture, Ve));
    }
    return Promise.all(i);
  }
}
class xw {
  constructor(e) {
    (this.parser = e), (this.name = at.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = i.extensions[this.name].emissiveStrength;
    return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve();
  }
}
class yw {
  constructor(e) {
    (this.parser = e), (this.name = at.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Is;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = i.extensions[this.name];
    if (
      (a.clearcoatFactor !== void 0 && (t.clearcoat = a.clearcoatFactor),
      a.clearcoatTexture !== void 0 &&
        s.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)),
      a.clearcoatRoughnessFactor !== void 0 &&
        (t.clearcoatRoughness = a.clearcoatRoughnessFactor),
      a.clearcoatRoughnessTexture !== void 0 &&
        s.push(
          n.assignTexture(
            t,
            "clearcoatRoughnessMap",
            a.clearcoatRoughnessTexture
          )
        ),
      a.clearcoatNormalTexture !== void 0 &&
        (s.push(
          n.assignTexture(t, "clearcoatNormalMap", a.clearcoatNormalTexture)
        ),
        a.clearcoatNormalTexture.scale !== void 0))
    ) {
      const o = a.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new We(o, o);
    }
    return Promise.all(s);
  }
}
class Ew {
  constructor(e) {
    (this.parser = e), (this.name = at.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Is;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = i.extensions[this.name];
    return (
      a.iridescenceFactor !== void 0 && (t.iridescence = a.iridescenceFactor),
      a.iridescenceTexture !== void 0 &&
        s.push(n.assignTexture(t, "iridescenceMap", a.iridescenceTexture)),
      a.iridescenceIor !== void 0 && (t.iridescenceIOR = a.iridescenceIor),
      t.iridescenceThicknessRange === void 0 &&
        (t.iridescenceThicknessRange = [100, 400]),
      a.iridescenceThicknessMinimum !== void 0 &&
        (t.iridescenceThicknessRange[0] = a.iridescenceThicknessMinimum),
      a.iridescenceThicknessMaximum !== void 0 &&
        (t.iridescenceThicknessRange[1] = a.iridescenceThicknessMaximum),
      a.iridescenceThicknessTexture !== void 0 &&
        s.push(
          n.assignTexture(
            t,
            "iridescenceThicknessMap",
            a.iridescenceThicknessTexture
          )
        ),
      Promise.all(s)
    );
  }
}
class Sw {
  constructor(e) {
    (this.parser = e), (this.name = at.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Is;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [];
    (t.sheenColor = new Ke(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
    const a = i.extensions[this.name];
    return (
      a.sheenColorFactor !== void 0 &&
        t.sheenColor.fromArray(a.sheenColorFactor),
      a.sheenRoughnessFactor !== void 0 &&
        (t.sheenRoughness = a.sheenRoughnessFactor),
      a.sheenColorTexture !== void 0 &&
        s.push(n.assignTexture(t, "sheenColorMap", a.sheenColorTexture, Ve)),
      a.sheenRoughnessTexture !== void 0 &&
        s.push(
          n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)
        ),
      Promise.all(s)
    );
  }
}
class Mw {
  constructor(e) {
    (this.parser = e), (this.name = at.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Is;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = i.extensions[this.name];
    return (
      a.transmissionFactor !== void 0 &&
        (t.transmission = a.transmissionFactor),
      a.transmissionTexture !== void 0 &&
        s.push(n.assignTexture(t, "transmissionMap", a.transmissionTexture)),
      Promise.all(s)
    );
  }
}
class bw {
  constructor(e) {
    (this.parser = e), (this.name = at.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Is;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = i.extensions[this.name];
    (t.thickness = a.thicknessFactor !== void 0 ? a.thicknessFactor : 0),
      a.thicknessTexture !== void 0 &&
        s.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)),
      (t.attenuationDistance = a.attenuationDistance || 1 / 0);
    const o = a.attenuationColor || [1, 1, 1];
    return (t.attenuationColor = new Ke(o[0], o[1], o[2])), Promise.all(s);
  }
}
class Tw {
  constructor(e) {
    (this.parser = e), (this.name = at.KHR_MATERIALS_IOR);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Is;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = i.extensions[this.name];
    return (t.ior = s.ior !== void 0 ? s.ior : 1.5), Promise.resolve();
  }
}
class Aw {
  constructor(e) {
    (this.parser = e), (this.name = at.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(e) {
    const n = this.parser.json.materials[e];
    return !n.extensions || !n.extensions[this.name] ? null : Is;
  }
  extendMaterialParams(e, t) {
    const n = this.parser,
      i = n.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const s = [],
      a = i.extensions[this.name];
    (t.specularIntensity = a.specularFactor !== void 0 ? a.specularFactor : 1),
      a.specularTexture !== void 0 &&
        s.push(n.assignTexture(t, "specularIntensityMap", a.specularTexture));
    const o = a.specularColorFactor || [1, 1, 1];
    return (
      (t.specularColor = new Ke(o[0], o[1], o[2])),
      a.specularColorTexture !== void 0 &&
        s.push(
          n.assignTexture(t, "specularColorMap", a.specularColorTexture, Ve)
        ),
      Promise.all(s)
    );
  }
}
class ww {
  constructor(e) {
    (this.parser = e), (this.name = at.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    const t = this.parser,
      n = t.json,
      i = n.textures[e];
    if (!i.extensions || !i.extensions[this.name]) return null;
    const s = i.extensions[this.name],
      a = t.options.ktx2Loader;
    if (!a) {
      if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        );
      return null;
    }
    return t.loadTextureImage(e, s.source, a);
  }
}
class Rw {
  constructor(e) {
    (this.parser = e),
      (this.name = at.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      n = this.parser,
      i = n.json,
      s = i.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const a = s.extensions[t],
      o = i.images[a.source];
    let l = n.textureLoader;
    if (o.uri) {
      const c = n.options.manager.getHandler(o.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function (c) {
      if (c) return n.loadTextureImage(e, a.source, l);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        );
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class Cw {
  constructor(e) {
    (this.parser = e),
      (this.name = at.EXT_TEXTURE_AVIF),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      n = this.parser,
      i = n.json,
      s = i.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const a = s.extensions[t],
      o = i.images[a.source];
    let l = n.textureLoader;
    if (o.uri) {
      const c = n.options.manager.getHandler(o.uri);
      c !== null && (l = c);
    }
    return this.detectSupport().then(function (c) {
      if (c) return n.loadTextureImage(e, a.source, l);
      if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: AVIF required by asset but unsupported."
        );
      return n.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
            (t.onload = t.onerror =
              function () {
                e(t.height === 1);
              });
        })),
      this.isSupported
    );
  }
}
class Pw {
  constructor(e) {
    (this.name = at.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    const t = this.parser.json,
      n = t.bufferViews[e];
    if (n.extensions && n.extensions[this.name]) {
      const i = n.extensions[this.name],
        s = this.parser.getDependency("buffer", i.buffer),
        a = this.parser.options.meshoptDecoder;
      if (!a || !a.supported) {
        if (
          t.extensionsRequired &&
          t.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          );
        return null;
      }
      return s.then(function (o) {
        const l = i.byteOffset || 0,
          c = i.byteLength || 0,
          u = i.count,
          h = i.byteStride,
          f = new Uint8Array(o, l, c);
        return a.decodeGltfBufferAsync
          ? a
              .decodeGltfBufferAsync(u, h, f, i.mode, i.filter)
              .then(function (p) {
                return p.buffer;
              })
          : a.ready.then(function () {
              const p = new ArrayBuffer(u * h);
              return (
                a.decodeGltfBuffer(
                  new Uint8Array(p),
                  u,
                  h,
                  f,
                  i.mode,
                  i.filter
                ),
                p
              );
            });
      });
    } else return null;
  }
}
class Lw {
  constructor(e) {
    (this.name = at.EXT_MESH_GPU_INSTANCING), (this.parser = e);
  }
  createNodeMesh(e) {
    const t = this.parser.json,
      n = t.nodes[e];
    if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
      return null;
    const i = t.meshes[n.mesh];
    for (const c of i.primitives)
      if (
        c.mode !== jn.TRIANGLES &&
        c.mode !== jn.TRIANGLE_STRIP &&
        c.mode !== jn.TRIANGLE_FAN &&
        c.mode !== void 0
      )
        return null;
    const a = n.extensions[this.name].attributes,
      o = [],
      l = {};
    for (const c in a)
      o.push(
        this.parser
          .getDependency("accessor", a[c])
          .then((u) => ((l[c] = u), l[c]))
      );
    return o.length < 1
      ? null
      : (o.push(this.parser.createNodeMesh(e)),
        Promise.all(o).then((c) => {
          const u = c.pop(),
            h = u.isGroup ? u.children : [u],
            f = c[0].count,
            p = [];
          for (const g of h) {
            const m = new et(),
              _ = new H(),
              d = new Ni(),
              y = new H(1, 1, 1),
              v = new eT(g.geometry, g.material, f);
            for (let S = 0; S < f; S++)
              l.TRANSLATION && _.fromBufferAttribute(l.TRANSLATION, S),
                l.ROTATION && d.fromBufferAttribute(l.ROTATION, S),
                l.SCALE && y.fromBufferAttribute(l.SCALE, S),
                v.setMatrixAt(S, m.compose(_, d, y));
            for (const S in l)
              S !== "TRANSLATION" &&
                S !== "ROTATION" &&
                S !== "SCALE" &&
                g.geometry.setAttribute(S, l[S]);
            Tt.prototype.copy.call(v, g),
              this.parser.assignFinalMaterial(v),
              p.push(v);
          }
          return u.isGroup ? (u.clear(), u.add(...p), u) : p[0];
        }));
  }
}
const z0 = "glTF",
  fo = 12,
  e_ = { JSON: 1313821514, BIN: 5130562 };
class Dw {
  constructor(e) {
    (this.name = at.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
    const t = new DataView(e, 0, fo),
      n = new TextDecoder();
    if (
      ((this.header = {
        magic: n.decode(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== z0)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const i = this.header.length - fo,
      s = new DataView(e, fo);
    let a = 0;
    for (; a < i; ) {
      const o = s.getUint32(a, !0);
      a += 4;
      const l = s.getUint32(a, !0);
      if (((a += 4), l === e_.JSON)) {
        const c = new Uint8Array(e, fo + a, o);
        this.content = n.decode(c);
      } else if (l === e_.BIN) {
        const c = fo + a;
        this.body = e.slice(c, c + o);
      }
      a += o;
    }
    if (this.content === null)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class Iw {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = at.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const n = this.json,
      i = this.dracoLoader,
      s = e.extensions[this.name].bufferView,
      a = e.extensions[this.name].attributes,
      o = {},
      l = {},
      c = {};
    for (const u in a) {
      const h = df[u] || u.toLowerCase();
      o[h] = a[u];
    }
    for (const u in e.attributes) {
      const h = df[u] || u.toLowerCase();
      if (a[u] !== void 0) {
        const f = n.accessors[e.attributes[u]],
          p = Pa[f.componentType];
        (c[h] = p.name), (l[h] = f.normalized === !0);
      }
    }
    return t.getDependency("bufferView", s).then(function (u) {
      return new Promise(function (h) {
        i.decodeDracoFile(
          u,
          function (f) {
            for (const p in f.attributes) {
              const g = f.attributes[p],
                m = l[p];
              m !== void 0 && (g.normalized = m);
            }
            h(f);
          },
          o,
          c
        );
      });
    });
  }
}
class Nw {
  constructor() {
    this.name = at.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (
      ((t.texCoord === void 0 || t.texCoord === e.channel) &&
        t.offset === void 0 &&
        t.rotation === void 0 &&
        t.scale === void 0) ||
        ((e = e.clone()),
        t.texCoord !== void 0 && (e.channel = t.texCoord),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0)),
      e
    );
  }
}
class Ow {
  constructor() {
    this.name = at.KHR_MESH_QUANTIZATION;
  }
}
class H0 extends dl {
  constructor(e, t, n, i) {
    super(e, t, n, i);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      n = this.sampleValues,
      i = this.valueSize,
      s = e * i * 3 + i;
    for (let a = 0; a !== i; a++) t[a] = n[s + a];
    return t;
  }
  interpolate_(e, t, n, i) {
    const s = this.resultBuffer,
      a = this.sampleValues,
      o = this.valueSize,
      l = o * 2,
      c = o * 3,
      u = i - t,
      h = (n - t) / u,
      f = h * h,
      p = f * h,
      g = e * c,
      m = g - c,
      _ = -2 * p + 3 * f,
      d = p - f,
      y = 1 - _,
      v = d - f + h;
    for (let S = 0; S !== o; S++) {
      const E = a[m + S + o],
        b = a[m + S + l] * u,
        M = a[g + S + o],
        C = a[g + S] * u;
      s[S] = y * E + v * b + _ * M + d * C;
    }
    return s;
  }
}
const Uw = new Ni();
class Fw extends H0 {
  interpolate_(e, t, n, i) {
    const s = super.interpolate_(e, t, n, i);
    return Uw.fromArray(s).normalize().toArray(s), s;
  }
}
const jn = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  Pa = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  t_ = { 9728: qt, 9729: Sn, 9984: Lh, 9985: B_, 9986: pc, 9987: Ss },
  n_ = { 33071: Jn, 33648: Lc, 10497: Oa },
  Eh = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  df = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  vr = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  Bw = { CUBICSPLINE: void 0, LINEAR: Fa, STEP: Go },
  Sh = { OPAQUE: "OPAQUE", MASK: "MASK", BLEND: "BLEND" };
function kw(r) {
  return (
    r.DefaultMaterial === void 0 &&
      (r.DefaultMaterial = new Of({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: or,
      })),
    r.DefaultMaterial
  );
}
function po(r, e, t) {
  for (const n in t.extensions)
    r[n] === void 0 &&
      ((e.userData.gltfExtensions = e.userData.gltfExtensions || {}),
      (e.userData.gltfExtensions[n] = t.extensions[n]));
}
function yr(r, e) {
  e.extras !== void 0 &&
    (typeof e.extras == "object"
      ? Object.assign(r.userData, e.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras
        ));
}
function zw(r, e, t) {
  let n = !1,
    i = !1,
    s = !1;
  for (let c = 0, u = e.length; c < u; c++) {
    const h = e[c];
    if (
      (h.POSITION !== void 0 && (n = !0),
      h.NORMAL !== void 0 && (i = !0),
      h.COLOR_0 !== void 0 && (s = !0),
      n && i && s)
    )
      break;
  }
  if (!n && !i && !s) return Promise.resolve(r);
  const a = [],
    o = [],
    l = [];
  for (let c = 0, u = e.length; c < u; c++) {
    const h = e[c];
    if (n) {
      const f =
        h.POSITION !== void 0
          ? t.getDependency("accessor", h.POSITION)
          : r.attributes.position;
      a.push(f);
    }
    if (i) {
      const f =
        h.NORMAL !== void 0
          ? t.getDependency("accessor", h.NORMAL)
          : r.attributes.normal;
      o.push(f);
    }
    if (s) {
      const f =
        h.COLOR_0 !== void 0
          ? t.getDependency("accessor", h.COLOR_0)
          : r.attributes.color;
      l.push(f);
    }
  }
  return Promise.all([Promise.all(a), Promise.all(o), Promise.all(l)]).then(
    function (c) {
      const u = c[0],
        h = c[1],
        f = c[2];
      return (
        n && (r.morphAttributes.position = u),
        i && (r.morphAttributes.normal = h),
        s && (r.morphAttributes.color = f),
        (r.morphTargetsRelative = !0),
        r
      );
    }
  );
}
function Hw(r, e) {
  if ((r.updateMorphTargets(), e.weights !== void 0))
    for (let t = 0, n = e.weights.length; t < n; t++)
      r.morphTargetInfluences[t] = e.weights[t];
  if (e.extras && Array.isArray(e.extras.targetNames)) {
    const t = e.extras.targetNames;
    if (r.morphTargetInfluences.length === t.length) {
      r.morphTargetDictionary = {};
      for (let n = 0, i = t.length; n < i; n++)
        r.morphTargetDictionary[t[n]] = n;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
      );
  }
}
function Vw(r) {
  const e = r.extensions && r.extensions[at.KHR_DRACO_MESH_COMPRESSION];
  let t;
  return (
    e
      ? (t = "draco:" + e.bufferView + ":" + e.indices + ":" + i_(e.attributes))
      : (t = r.indices + ":" + i_(r.attributes) + ":" + r.mode),
    t
  );
}
function i_(r) {
  let e = "";
  const t = Object.keys(r).sort();
  for (let n = 0, i = t.length; n < i; n++) e += t[n] + ":" + r[t[n]] + ";";
  return e;
}
function pf(r) {
  switch (r) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
function Gw(r) {
  return r.search(/\.jpe?g($|\?)/i) > 0 || r.search(/^data\:image\/jpeg/) === 0
    ? "image/jpeg"
    : r.search(/\.webp($|\?)/i) > 0 || r.search(/^data\:image\/webp/) === 0
    ? "image/webp"
    : "image/png";
}
const Ww = new et();
class Xw {
  constructor(e = {}, t = {}) {
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new _w()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    let n = !1,
      i = !1,
      s = -1;
    typeof navigator < "u" &&
      ((n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0),
      (i = navigator.userAgent.indexOf("Firefox") > -1),
      (s = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
      typeof createImageBitmap > "u" || n || (i && s < 98)
        ? (this.textureLoader = new _g(this.options.manager))
        : (this.textureLoader = new ET(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new mg(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      this.options.crossOrigin === "use-credentials" &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const n = this,
      i = this.json,
      s = this.extensions;
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (a) {
        return a._markDefs && a._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (a) {
          return a.beforeRoot && a.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            n.getDependencies("scene"),
            n.getDependencies("animation"),
            n.getDependencies("camera"),
          ]);
        })
        .then(function (a) {
          const o = {
            scene: a[0][i.scene || 0],
            scenes: a[0],
            animations: a[1],
            cameras: a[2],
            asset: i.asset,
            parser: n,
            userData: {},
          };
          po(s, o, i),
            yr(o, i),
            Promise.all(
              n._invokeAll(function (l) {
                return l.afterRoot && l.afterRoot(o);
              })
            ).then(function () {
              e(o);
            });
        })
        .catch(t);
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      n = this.json.meshes || [];
    for (let i = 0, s = t.length; i < s; i++) {
      const a = t[i].joints;
      for (let o = 0, l = a.length; o < l; o++) e[a[o]].isBone = !0;
    }
    for (let i = 0, s = e.length; i < s; i++) {
      const a = e[i];
      a.mesh !== void 0 &&
        (this._addNodeRef(this.meshCache, a.mesh),
        a.skin !== void 0 && (n[a.mesh].isSkinnedMesh = !0)),
        a.camera !== void 0 && this._addNodeRef(this.cameraCache, a.camera);
    }
  }
  _addNodeRef(e, t) {
    t !== void 0 &&
      (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, n) {
    if (e.refs[t] <= 1) return n;
    const i = n.clone(),
      s = (a, o) => {
        const l = this.associations.get(a);
        l != null && this.associations.set(o, l);
        for (const [c, u] of a.children.entries()) s(u, o.children[c]);
      };
    return s(n, i), (i.name += "_instance_" + e.uses[t]++), i;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let n = 0; n < t.length; n++) {
      const i = e(t[n]);
      if (i) return i;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const n = [];
    for (let i = 0; i < t.length; i++) {
      const s = e(t[i]);
      s && n.push(s);
    }
    return n;
  }
  getDependency(e, t) {
    const n = e + ":" + t;
    let i = this.cache.get(n);
    if (!i) {
      switch (e) {
        case "scene":
          i = this.loadScene(t);
          break;
        case "node":
          i = this._invokeOne(function (s) {
            return s.loadNode && s.loadNode(t);
          });
          break;
        case "mesh":
          i = this._invokeOne(function (s) {
            return s.loadMesh && s.loadMesh(t);
          });
          break;
        case "accessor":
          i = this.loadAccessor(t);
          break;
        case "bufferView":
          i = this._invokeOne(function (s) {
            return s.loadBufferView && s.loadBufferView(t);
          });
          break;
        case "buffer":
          i = this.loadBuffer(t);
          break;
        case "material":
          i = this._invokeOne(function (s) {
            return s.loadMaterial && s.loadMaterial(t);
          });
          break;
        case "texture":
          i = this._invokeOne(function (s) {
            return s.loadTexture && s.loadTexture(t);
          });
          break;
        case "skin":
          i = this.loadSkin(t);
          break;
        case "animation":
          i = this._invokeOne(function (s) {
            return s.loadAnimation && s.loadAnimation(t);
          });
          break;
        case "camera":
          i = this.loadCamera(t);
          break;
        default:
          if (
            ((i = this._invokeOne(function (s) {
              return s != this && s.getDependency && s.getDependency(e, t);
            })),
            !i)
          )
            throw new Error("Unknown type: " + e);
          break;
      }
      this.cache.add(n, i);
    }
    return i;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const n = this,
        i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
      (t = Promise.all(
        i.map(function (s, a) {
          return n.getDependency(e, a);
        })
      )),
        this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      n = this.fileLoader;
    if (t.type && t.type !== "arraybuffer")
      throw new Error(
        "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
      );
    if (t.uri === void 0 && e === 0)
      return Promise.resolve(this.extensions[at.KHR_BINARY_GLTF].body);
    const i = this.options;
    return new Promise(function (s, a) {
      n.load(Bh.resolveURL(t.uri, i.path), s, void 0, function () {
        a(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')
        );
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function (n) {
      const i = t.byteLength || 0,
        s = t.byteOffset || 0;
      return n.slice(s, s + i);
    });
  }
  loadAccessor(e) {
    const t = this,
      n = this.json,
      i = this.json.accessors[e];
    if (i.bufferView === void 0 && i.sparse === void 0) {
      const a = Eh[i.type],
        o = Pa[i.componentType],
        l = i.normalized === !0,
        c = new o(i.count * a);
      return Promise.resolve(new xn(c, a, l));
    }
    const s = [];
    return (
      i.bufferView !== void 0
        ? s.push(this.getDependency("bufferView", i.bufferView))
        : s.push(null),
      i.sparse !== void 0 &&
        (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
        s.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
      Promise.all(s).then(function (a) {
        const o = a[0],
          l = Eh[i.type],
          c = Pa[i.componentType],
          u = c.BYTES_PER_ELEMENT,
          h = u * l,
          f = i.byteOffset || 0,
          p =
            i.bufferView !== void 0
              ? n.bufferViews[i.bufferView].byteStride
              : void 0,
          g = i.normalized === !0;
        let m, _;
        if (p && p !== h) {
          const d = Math.floor(f / p),
            y =
              "InterleavedBuffer:" +
              i.bufferView +
              ":" +
              i.componentType +
              ":" +
              d +
              ":" +
              i.count;
          let v = t.cache.get(y);
          v ||
            ((m = new c(o, d * p, (i.count * p) / u)),
            (v = new jb(m, p / u)),
            t.cache.add(y, v)),
            (_ = new Df(v, l, (f % p) / u, g));
        } else o === null ? (m = new c(i.count * l)) : (m = new c(o, f, i.count * l)), (_ = new xn(m, l, g));
        if (i.sparse !== void 0) {
          const d = Eh.SCALAR,
            y = Pa[i.sparse.indices.componentType],
            v = i.sparse.indices.byteOffset || 0,
            S = i.sparse.values.byteOffset || 0,
            E = new y(a[1], v, i.sparse.count * d),
            b = new c(a[2], S, i.sparse.count * l);
          o !== null && (_ = new xn(_.array.slice(), _.itemSize, _.normalized));
          for (let M = 0, C = E.length; M < C; M++) {
            const x = E[M];
            if (
              (_.setX(x, b[M * l]),
              l >= 2 && _.setY(x, b[M * l + 1]),
              l >= 3 && _.setZ(x, b[M * l + 2]),
              l >= 4 && _.setW(x, b[M * l + 3]),
              l >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
        }
        return _;
      })
    );
  }
  loadTexture(e) {
    const t = this.json,
      n = this.options,
      s = t.textures[e].source,
      a = t.images[s];
    let o = this.textureLoader;
    if (a.uri) {
      const l = n.manager.getHandler(a.uri);
      l !== null && (o = l);
    }
    return this.loadTextureImage(e, s, o);
  }
  loadTextureImage(e, t, n) {
    const i = this,
      s = this.json,
      a = s.textures[e],
      o = s.images[t],
      l = (o.uri || o.bufferView) + ":" + a.sampler;
    if (this.textureCache[l]) return this.textureCache[l];
    const c = this.loadImageSource(t, n)
      .then(function (u) {
        (u.flipY = !1),
          (u.name = a.name || o.name || ""),
          u.name === "" &&
            typeof o.uri == "string" &&
            o.uri.startsWith("data:image/") === !1 &&
            (u.name = o.uri);
        const f = (s.samplers || {})[a.sampler] || {};
        return (
          (u.magFilter = t_[f.magFilter] || Sn),
          (u.minFilter = t_[f.minFilter] || Ss),
          (u.wrapS = n_[f.wrapS] || Oa),
          (u.wrapT = n_[f.wrapT] || Oa),
          i.associations.set(u, { textures: e }),
          u
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[l] = c), c;
  }
  loadImageSource(e, t) {
    const n = this,
      i = this.json,
      s = this.options;
    if (this.sourceCache[e] !== void 0)
      return this.sourceCache[e].then((h) => h.clone());
    const a = i.images[e],
      o = self.URL || self.webkitURL;
    let l = a.uri || "",
      c = !1;
    if (a.bufferView !== void 0)
      l = n.getDependency("bufferView", a.bufferView).then(function (h) {
        c = !0;
        const f = new Blob([h], { type: a.mimeType });
        return (l = o.createObjectURL(f)), l;
      });
    else if (a.uri === void 0)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
      );
    const u = Promise.resolve(l)
      .then(function (h) {
        return new Promise(function (f, p) {
          let g = f;
          t.isImageBitmapLoader === !0 &&
            (g = function (m) {
              const _ = new Qt(m);
              (_.needsUpdate = !0), f(_);
            }),
            t.load(Bh.resolveURL(h, s.path), g, void 0, p);
        });
      })
      .then(function (h) {
        return (
          c === !0 && o.revokeObjectURL(l),
          (h.userData.mimeType = a.mimeType || Gw(a.uri)),
          h
        );
      })
      .catch(function (h) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", l), h);
      });
    return (this.sourceCache[e] = u), u;
  }
  assignTexture(e, t, n, i) {
    const s = this;
    return this.getDependency("texture", n.index).then(function (a) {
      if (!a) return null;
      if (
        (n.texCoord !== void 0 &&
          n.texCoord > 0 &&
          ((a = a.clone()), (a.channel = n.texCoord)),
        s.extensions[at.KHR_TEXTURE_TRANSFORM])
      ) {
        const o =
          n.extensions !== void 0
            ? n.extensions[at.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (o) {
          const l = s.associations.get(a);
          (a = s.extensions[at.KHR_TEXTURE_TRANSFORM].extendTexture(a, o)),
            s.associations.set(a, l);
        }
      }
      return i !== void 0 && (a.colorSpace = i), (e[t] = a), a;
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let n = e.material;
    const i = t.attributes.tangent === void 0,
      s = t.attributes.color !== void 0,
      a = t.attributes.normal === void 0;
    if (e.isPoints) {
      const o = "PointsMaterial:" + n.uuid;
      let l = this.cache.get(o);
      l ||
        ((l = new ug()),
        Pi.prototype.copy.call(l, n),
        l.color.copy(n.color),
        (l.map = n.map),
        (l.sizeAttenuation = !1),
        this.cache.add(o, l)),
        (n = l);
    } else if (e.isLine) {
      const o = "LineBasicMaterial:" + n.uuid;
      let l = this.cache.get(o);
      l ||
        ((l = new cg()),
        Pi.prototype.copy.call(l, n),
        l.color.copy(n.color),
        (l.map = n.map),
        this.cache.add(o, l)),
        (n = l);
    }
    if (i || s || a) {
      let o = "ClonedMaterial:" + n.uuid + ":";
      i && (o += "derivative-tangents:"),
        s && (o += "vertex-colors:"),
        a && (o += "flat-shading:");
      let l = this.cache.get(o);
      l ||
        ((l = n.clone()),
        s && (l.vertexColors = !0),
        a && (l.flatShading = !0),
        i &&
          (l.normalScale && (l.normalScale.y *= -1),
          l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
        this.cache.add(o, l),
        this.associations.set(l, this.associations.get(n))),
        (n = l);
    }
    e.material = n;
  }
  getMaterialType() {
    return Of;
  }
  loadMaterial(e) {
    const t = this,
      n = this.json,
      i = this.extensions,
      s = n.materials[e];
    let a;
    const o = {},
      l = s.extensions || {},
      c = [];
    if (l[at.KHR_MATERIALS_UNLIT]) {
      const h = i[at.KHR_MATERIALS_UNLIT];
      (a = h.getMaterialType()), c.push(h.extendParams(o, s, t));
    } else {
      const h = s.pbrMetallicRoughness || {};
      if (
        ((o.color = new Ke(1, 1, 1)),
        (o.opacity = 1),
        Array.isArray(h.baseColorFactor))
      ) {
        const f = h.baseColorFactor;
        o.color.fromArray(f), (o.opacity = f[3]);
      }
      h.baseColorTexture !== void 0 &&
        c.push(t.assignTexture(o, "map", h.baseColorTexture, Ve)),
        (o.metalness = h.metallicFactor !== void 0 ? h.metallicFactor : 1),
        (o.roughness = h.roughnessFactor !== void 0 ? h.roughnessFactor : 1),
        h.metallicRoughnessTexture !== void 0 &&
          (c.push(
            t.assignTexture(o, "metalnessMap", h.metallicRoughnessTexture)
          ),
          c.push(
            t.assignTexture(o, "roughnessMap", h.metallicRoughnessTexture)
          )),
        (a = this._invokeOne(function (f) {
          return f.getMaterialType && f.getMaterialType(e);
        })),
        c.push(
          Promise.all(
            this._invokeAll(function (f) {
              return f.extendMaterialParams && f.extendMaterialParams(e, o);
            })
          )
        );
    }
    s.doubleSided === !0 && (o.side = wi);
    const u = s.alphaMode || Sh.OPAQUE;
    if (
      (u === Sh.BLEND
        ? ((o.transparent = !0), (o.depthWrite = !1))
        : ((o.transparent = !1),
          u === Sh.MASK &&
            (o.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : 0.5)),
      s.normalTexture !== void 0 &&
        a !== Sr &&
        (c.push(t.assignTexture(o, "normalMap", s.normalTexture)),
        (o.normalScale = new We(1, 1)),
        s.normalTexture.scale !== void 0))
    ) {
      const h = s.normalTexture.scale;
      o.normalScale.set(h, h);
    }
    return (
      s.occlusionTexture !== void 0 &&
        a !== Sr &&
        (c.push(t.assignTexture(o, "aoMap", s.occlusionTexture)),
        s.occlusionTexture.strength !== void 0 &&
          (o.aoMapIntensity = s.occlusionTexture.strength)),
      s.emissiveFactor !== void 0 &&
        a !== Sr &&
        (o.emissive = new Ke().fromArray(s.emissiveFactor)),
      s.emissiveTexture !== void 0 &&
        a !== Sr &&
        c.push(t.assignTexture(o, "emissiveMap", s.emissiveTexture, Ve)),
      Promise.all(c).then(function () {
        const h = new a(o);
        return (
          s.name && (h.name = s.name),
          yr(h, s),
          t.associations.set(h, { materials: e }),
          s.extensions && po(i, h, s),
          h
        );
      })
    );
  }
  createUniqueName(e) {
    const t = ut.sanitizeNodeName(e || "");
    let n = t;
    for (let i = 1; this.nodeNamesUsed[n]; ++i) n = t + "_" + i;
    return (this.nodeNamesUsed[n] = !0), n;
  }
  loadGeometries(e) {
    const t = this,
      n = this.extensions,
      i = this.primitiveCache;
    function s(o) {
      return n[at.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(o, t)
        .then(function (l) {
          return r_(l, o, t);
        });
    }
    const a = [];
    for (let o = 0, l = e.length; o < l; o++) {
      const c = e[o],
        u = Vw(c),
        h = i[u];
      if (h) a.push(h.promise);
      else {
        let f;
        c.extensions && c.extensions[at.KHR_DRACO_MESH_COMPRESSION]
          ? (f = s(c))
          : (f = r_(new xi(), c, t)),
          (i[u] = { primitive: c, promise: f }),
          a.push(f);
      }
    }
    return Promise.all(a);
  }
  loadMesh(e) {
    const t = this,
      n = this.json,
      i = this.extensions,
      s = n.meshes[e],
      a = s.primitives,
      o = [];
    for (let l = 0, c = a.length; l < c; l++) {
      const u =
        a[l].material === void 0
          ? kw(this.cache)
          : this.getDependency("material", a[l].material);
      o.push(u);
    }
    return (
      o.push(t.loadGeometries(a)),
      Promise.all(o).then(function (l) {
        const c = l.slice(0, l.length - 1),
          u = l[l.length - 1],
          h = [];
        for (let p = 0, g = u.length; p < g; p++) {
          const m = u[p],
            _ = a[p];
          let d;
          const y = c[p];
          if (
            _.mode === jn.TRIANGLES ||
            _.mode === jn.TRIANGLE_STRIP ||
            _.mode === jn.TRIANGLE_FAN ||
            _.mode === void 0
          )
            (d = s.isSkinnedMesh === !0 ? new $b(m, y) : new Vn(m, y)),
              d.isSkinnedMesh === !0 && d.normalizeSkinWeights(),
              _.mode === jn.TRIANGLE_STRIP
                ? (d.geometry = Qm(d.geometry, z_))
                : _.mode === jn.TRIANGLE_FAN &&
                  (d.geometry = Qm(d.geometry, Dh));
          else if (_.mode === jn.LINES) d = new tT(m, y);
          else if (_.mode === jn.LINE_STRIP) d = new Nf(m, y);
          else if (_.mode === jn.LINE_LOOP) d = new nT(m, y);
          else if (_.mode === jn.POINTS) d = new hg(m, y);
          else
            throw new Error(
              "THREE.GLTFLoader: Primitive mode unsupported: " + _.mode
            );
          Object.keys(d.geometry.morphAttributes).length > 0 && Hw(d, s),
            (d.name = t.createUniqueName(s.name || "mesh_" + e)),
            yr(d, s),
            _.extensions && po(i, d, _),
            t.assignFinalMaterial(d),
            h.push(d);
        }
        for (let p = 0, g = h.length; p < g; p++)
          t.associations.set(h[p], { meshes: e, primitives: p });
        if (h.length === 1) return h[0];
        const f = new ls();
        t.associations.set(f, { meshes: e });
        for (let p = 0, g = h.length; p < g; p++) f.add(h[p]);
        return f;
      })
    );
  }
  loadCamera(e) {
    let t;
    const n = this.json.cameras[e],
      i = n[n.type];
    if (!i) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    return (
      n.type === "perspective"
        ? (t = new mn(
            Dc.radToDeg(i.yfov),
            i.aspectRatio || 1,
            i.znear || 1,
            i.zfar || 2e6
          ))
        : n.type === "orthographic" &&
          (t = new Pf(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)),
      n.name && (t.name = this.createUniqueName(n.name)),
      yr(t, n),
      Promise.resolve(t)
    );
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      n = [];
    for (let i = 0, s = t.joints.length; i < s; i++)
      n.push(this._loadNodeShallow(t.joints[i]));
    return (
      t.inverseBindMatrices !== void 0
        ? n.push(this.getDependency("accessor", t.inverseBindMatrices))
        : n.push(null),
      Promise.all(n).then(function (i) {
        const s = i.pop(),
          a = i,
          o = [],
          l = [];
        for (let c = 0, u = a.length; c < u; c++) {
          const h = a[c];
          if (h) {
            o.push(h);
            const f = new et();
            s !== null && f.fromArray(s.array, c * 16), l.push(f);
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              t.joints[c]
            );
        }
        return new If(o, l);
      })
    );
  }
  loadAnimation(e) {
    const n = this.json.animations[e],
      i = n.name ? n.name : "animation_" + e,
      s = [],
      a = [],
      o = [],
      l = [],
      c = [];
    for (let u = 0, h = n.channels.length; u < h; u++) {
      const f = n.channels[u],
        p = n.samplers[f.sampler],
        g = f.target,
        m = g.node,
        _ = n.parameters !== void 0 ? n.parameters[p.input] : p.input,
        d = n.parameters !== void 0 ? n.parameters[p.output] : p.output;
      g.node !== void 0 &&
        (s.push(this.getDependency("node", m)),
        a.push(this.getDependency("accessor", _)),
        o.push(this.getDependency("accessor", d)),
        l.push(p),
        c.push(g));
    }
    return Promise.all([
      Promise.all(s),
      Promise.all(a),
      Promise.all(o),
      Promise.all(l),
      Promise.all(c),
    ]).then(function (u) {
      const h = u[0],
        f = u[1],
        p = u[2],
        g = u[3],
        m = u[4],
        _ = [];
      for (let d = 0, y = h.length; d < y; d++) {
        const v = h[d],
          S = f[d],
          E = p[d],
          b = g[d],
          M = m[d];
        if (v === void 0) continue;
        v.updateMatrix();
        let C;
        switch (vr[M.path]) {
          case vr.weights:
            C = Xo;
            break;
          case vr.rotation:
            C = Ts;
            break;
          case vr.position:
          case vr.scale:
          default:
            C = Yo;
            break;
        }
        const x = v.name ? v.name : v.uuid,
          T = b.interpolation !== void 0 ? Bw[b.interpolation] : Fa,
          D = [];
        vr[M.path] === vr.weights
          ? v.traverse(function (L) {
              L.morphTargetInfluences && D.push(L.name ? L.name : L.uuid);
            })
          : D.push(x);
        let N = E.array;
        if (E.normalized) {
          const L = pf(N.constructor),
            F = new Float32Array(N.length);
          for (let I = 0, j = N.length; I < j; I++) F[I] = N[I] * L;
          N = F;
        }
        for (let L = 0, F = D.length; L < F; L++) {
          const I = new C(D[L] + "." + vr[M.path], S.array, N, T);
          b.interpolation === "CUBICSPLINE" &&
            ((I.createInterpolant = function (A) {
              const k = this instanceof Ts ? Fw : H0;
              return new k(this.times, this.values, this.getValueSize() / 3, A);
            }),
            (I.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
              !0)),
            _.push(I);
        }
      }
      return new lT(i, void 0, _);
    });
  }
  createNodeMesh(e) {
    const t = this.json,
      n = this,
      i = t.nodes[e];
    return i.mesh === void 0
      ? null
      : n.getDependency("mesh", i.mesh).then(function (s) {
          const a = n._getNodeRef(n.meshCache, i.mesh, s);
          return (
            i.weights !== void 0 &&
              a.traverse(function (o) {
                if (o.isMesh)
                  for (let l = 0, c = i.weights.length; l < c; l++)
                    o.morphTargetInfluences[l] = i.weights[l];
              }),
            a
          );
        });
  }
  loadNode(e) {
    const t = this.json,
      n = this,
      i = t.nodes[e],
      s = n._loadNodeShallow(e),
      a = [],
      o = i.children || [];
    for (let c = 0, u = o.length; c < u; c++)
      a.push(n.getDependency("node", o[c]));
    const l =
      i.skin === void 0
        ? Promise.resolve(null)
        : n.getDependency("skin", i.skin);
    return Promise.all([s, Promise.all(a), l]).then(function (c) {
      const u = c[0],
        h = c[1],
        f = c[2];
      f !== null &&
        u.traverse(function (p) {
          p.isSkinnedMesh && p.bind(f, Ww);
        });
      for (let p = 0, g = h.length; p < g; p++) u.add(h[p]);
      return u;
    });
  }
  _loadNodeShallow(e) {
    const t = this.json,
      n = this.extensions,
      i = this;
    if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
    const s = t.nodes[e],
      a = s.name ? i.createUniqueName(s.name) : "",
      o = [],
      l = i._invokeOne(function (c) {
        return c.createNodeMesh && c.createNodeMesh(e);
      });
    return (
      l && o.push(l),
      s.camera !== void 0 &&
        o.push(
          i.getDependency("camera", s.camera).then(function (c) {
            return i._getNodeRef(i.cameraCache, s.camera, c);
          })
        ),
      i
        ._invokeAll(function (c) {
          return c.createNodeAttachment && c.createNodeAttachment(e);
        })
        .forEach(function (c) {
          o.push(c);
        }),
      (this.nodeCache[e] = Promise.all(o).then(function (c) {
        let u;
        if (
          (s.isBone === !0
            ? (u = new lg())
            : c.length > 1
            ? (u = new ls())
            : c.length === 1
            ? (u = c[0])
            : (u = new Tt()),
          u !== c[0])
        )
          for (let h = 0, f = c.length; h < f; h++) u.add(c[h]);
        if (
          (s.name && ((u.userData.name = s.name), (u.name = a)),
          yr(u, s),
          s.extensions && po(n, u, s),
          s.matrix !== void 0)
        ) {
          const h = new et();
          h.fromArray(s.matrix), u.applyMatrix4(h);
        } else s.translation !== void 0 && u.position.fromArray(s.translation), s.rotation !== void 0 && u.quaternion.fromArray(s.rotation), s.scale !== void 0 && u.scale.fromArray(s.scale);
        return (
          i.associations.has(u) || i.associations.set(u, {}),
          (i.associations.get(u).nodes = e),
          u
        );
      })),
      this.nodeCache[e]
    );
  }
  loadScene(e) {
    const t = this.extensions,
      n = this.json.scenes[e],
      i = this,
      s = new ls();
    n.name && (s.name = i.createUniqueName(n.name)),
      yr(s, n),
      n.extensions && po(t, s, n);
    const a = n.nodes || [],
      o = [];
    for (let l = 0, c = a.length; l < c; l++)
      o.push(i.getDependency("node", a[l]));
    return Promise.all(o).then(function (l) {
      for (let u = 0, h = l.length; u < h; u++) s.add(l[u]);
      const c = (u) => {
        const h = new Map();
        for (const [f, p] of i.associations)
          (f instanceof Pi || f instanceof Qt) && h.set(f, p);
        return (
          u.traverse((f) => {
            const p = i.associations.get(f);
            p != null && h.set(f, p);
          }),
          h
        );
      };
      return (i.associations = c(s)), s;
    });
  }
}
function Yw(r, e, t) {
  const n = e.attributes,
    i = new hr();
  if (n.POSITION !== void 0) {
    const o = t.json.accessors[n.POSITION],
      l = o.min,
      c = o.max;
    if (l !== void 0 && c !== void 0) {
      if (
        (i.set(new H(l[0], l[1], l[2]), new H(c[0], c[1], c[2])), o.normalized)
      ) {
        const u = pf(Pa[o.componentType]);
        i.min.multiplyScalar(u), i.max.multiplyScalar(u);
      }
    } else {
      console.warn(
        "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
      );
      return;
    }
  } else return;
  const s = e.targets;
  if (s !== void 0) {
    const o = new H(),
      l = new H();
    for (let c = 0, u = s.length; c < u; c++) {
      const h = s[c];
      if (h.POSITION !== void 0) {
        const f = t.json.accessors[h.POSITION],
          p = f.min,
          g = f.max;
        if (p !== void 0 && g !== void 0) {
          if (
            (l.setX(Math.max(Math.abs(p[0]), Math.abs(g[0]))),
            l.setY(Math.max(Math.abs(p[1]), Math.abs(g[1]))),
            l.setZ(Math.max(Math.abs(p[2]), Math.abs(g[2]))),
            f.normalized)
          ) {
            const m = pf(Pa[f.componentType]);
            l.multiplyScalar(m);
          }
          o.max(l);
        } else
          console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          );
      }
    }
    i.expandByVector(o);
  }
  r.boundingBox = i;
  const a = new fr();
  i.getCenter(a.center),
    (a.radius = i.min.distanceTo(i.max) / 2),
    (r.boundingSphere = a);
}
function r_(r, e, t) {
  const n = e.attributes,
    i = [];
  function s(a, o) {
    return t.getDependency("accessor", a).then(function (l) {
      r.setAttribute(o, l);
    });
  }
  for (const a in n) {
    const o = df[a] || a.toLowerCase();
    o in r.attributes || i.push(s(n[a], o));
  }
  if (e.indices !== void 0 && !r.index) {
    const a = t.getDependency("accessor", e.indices).then(function (o) {
      r.setIndex(o);
    });
    i.push(a);
  }
  return (
    yr(r, e),
    Yw(r, e, t),
    Promise.all(i).then(function () {
      return e.targets !== void 0 ? zw(r, e.targets, t) : r;
    })
  );
}
async function qw(r) {
  let e = null;
  try {
    e = await new mw().loadAsync(r);
  } catch (t) {
    console.log(t.message);
  }
  return e.scene.children[0];
}
var eu, V0, tu, G0;
class pu {
  constructor(e, t) {
    Us(this, eu);
    Us(this, tu);
    In(this, "geometry", null);
    In(this, "normal", null);
    In(this, "position", null);
    In(this, "color", null);
    In(this, "randomPosition", null);
    In(this, "uv", null);
    In(this, "maxVertices", 0);
    (this.meshPath = e), (this.maxVertices = t), (this.geometry = null);
  }
  async init() {
    await this._setGeometry(this.meshPath),
      this._setNormal(),
      this.setPosition(),
      Fs(this, tu, G0).call(this),
      Fs(this, eu, V0).call(this);
  }
  async _setGeometry(e) {
    const t = await qw(e);
    return (this.geometry = t.geometry), t;
  }
  _setNormal() {
    this.geometry &&
      this.geometry.attributes.normal.array.length < this.maxVertices * 3 &&
      ([
        ...this.geometry.attributes.normal.array,
        ...new Array(
          this.maxVertices * 3 - this.geometry.attributes.normal.array.length
        ).fill(0),
      ],
      (this.normal = new rn(this.geometry.attributes.normal.array, 3)));
  }
  setPosition() {
    this.geometry &&
      (this.geometry.attributes.position.array.length <
        this.maxVertices * 3 && [
        ...this.geometry.attributes.position.array,
        ...new Array(
          this.maxVertices * 3 - this.geometry.attributes.position.array.length
        ).fill(0),
      ],
      (this.position = new rn(this.geometry.attributes.position.array, 3)));
  }
}
(eu = new WeakSet()),
  (V0 = function () {
    this.geometry &&
      this.geometry.attributes.uv &&
      (this.uv = new rn(this.geometry.attributes.uv.array, 3));
  }),
  (tu = new WeakSet()),
  (G0 = function () {
    if (!this.position) return;
    const e = [],
      t = [],
      n = [
        "#FFFFFF",
        "#FFFFFF",
        "#FFFFFF",
        "#FFFFFF",
        "#875500",
        "#875500",
        "#875500",
      ],
      i = new Ke();
    for (let s = 0; s < this.position.array.length; s++)
      e.push(Math.random(), Math.random(), Math.random()),
        i.set(n[Dc.randInt(0, n.length - 1)]),
        t.push(i.r, i.g, i.b);
    (this.color = new rn(t, 3)), (this.randomPosition = new rn(e, 3));
  });
class jw extends pu {
  async _setGeometry(e) {
    const n = (await super._setGeometry(e)).children[0],
      i = 2e3;
    n.geometry.scale(i, i, i), (this.geometry = n.geometry);
  }
}
class Kw extends pu {
  async _setGeometry(e) {
    const { geometry: t } = await super._setGeometry(e),
      n = 200;
    t.scale(n, n, n), t.translate(0, 0, 10), (this.geometry = t);
  }
}
class $w extends pu {
  async _setGeometry(e) {
    const t = await super._setGeometry(e);
    this.geometry &&
      (t.geometry.scale(100, 100, 100),
      t.geometry.rotateZ(-Math.PI / 2),
      t.geometry.rotateX(-Math.PI / 2),
      (this.geometry = t.geometry));
  }
}
class Zw extends pu {
  async _setGeometry(e) {
    const t = await super._setGeometry(e);
    this.geometry = t.geometry;
    const n = 0.2;
    this.geometry.scale(n, n, n);
  }
  setPosition() {
    let e = [];
    this.geometry.attributes.position.array.length < this.maxVertices * 3 &&
      ((e = [
        ...this.geometry.attributes.position.array,
        ...new Array(
          this.maxVertices * 3 - this.geometry.attributes.position.array.length
        ).fill(0),
      ]),
      (this.position = new rn(e, 3)));
  }
  _setNormal() {
    this.normal = new rn(new Array(this.maxVertices * 3).fill(0), 3);
  }
}
function Jw() {
  const r = document.querySelector("#nav-toggle-button"),
    e = document.querySelector(".nav");
  r.addEventListener("click", () => {
    Hc.to(e, {
      duration: 0.2,
      height: () => (e.getBoundingClientRect().height ? 0 : "auto"),
    });
  });
}
var Qw = `uniform sampler2D uTexture;
uniform vec3 uColor;

varying vec3 vColor;
varying float vVisible;

void main() {
	if ( floor(vVisible + 0.1) == 0.0 ) discard;

	vec2 uv = vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y);
	vec4 textureColor = texture2D(uTexture, uv);

	gl_FragColor = vec4(vColor, textureColor.a);
}`,
  e1 = `attribute vec3 position2;
attribute vec3 position3;
attribute vec3 position4;

attribute vec3 normal2;
attribute vec3 normal3;
attribute vec3 normal4;

attribute vec3 aRand;
attribute vec3 aRandSecondary;
attribute vec3 aColor;

uniform float uMorph2;
uniform float uMorph3;
uniform float uMorph4;

uniform float uSize;
uniform float uDestruction;

uniform vec3 uPoint;

varying vec3 vColor;
varying float vVisible;

void main() {

	vec4 modelPosition1 = modelMatrix * vec4(position, 1.0);
	vec4 modelPosition2 = modelMatrix * vec4(position2, 1.0);
	vec4 modelPosition3 = modelMatrix * vec4(position3, 1.0);
	vec4 modelPosition4 = modelMatrix * vec4(position4, 1.0);

	vec4 modelPosition = mix(modelPosition1, modelPosition2, uMorph2); 
	modelPosition = mix(modelPosition, modelPosition3, uMorph3); 
	modelPosition = mix(modelPosition, modelPosition4, uMorph4); 

	modelPosition.xyz += aRand.xyz * 850.0 * uDestruction;

	vec4 viewPosition = viewMatrix * modelPosition;
	vec4 projectedPosition = projectionMatrix * viewPosition;

	gl_Position = projectedPosition;

	vec3 currentNormal = mix(normal, normal2 , uMorph2);
	currentNormal = mix(currentNormal, normal3 , uMorph3);
	currentNormal = mix(currentNormal, normal4 , uMorph4);

	vec3 vNormal = normalize( normalMatrix * currentNormal);

	vec3 vDir = vec3(0, 0, 1);
	vVisible = step( 0., dot( vDir, vNormal ) );

	if(currentNormal == vec3(0.0, 0.0, 0.0))
	vVisible = -1.0;
	
	float hoverRadius = 65.0;
	float hoveredParticleScale = 200.0;
	float distanceToMouse =  length(uPoint.xy - modelPosition.xy);
	float normalizedDistanceToMouse = clamp(distanceToMouse / hoverRadius, 0.0, 1.0);

	gl_PointSize = mix(uSize * hoveredParticleScale, uSize * hoverRadius, normalizedDistanceToMouse);
  gl_PointSize *= (1.0 / -viewPosition.z);

	vColor = mix(vec3(1.0, 1.0, 1.0), aColor, normalizedDistanceToMouse);

}`;
function t1(r) {
  if (r && !(typeof window > "u")) {
    var e = document.createElement("style");
    return (
      e.setAttribute("type", "text/css"),
      (e.innerHTML = r),
      document.head.appendChild(e),
      r
    );
  }
}
function ya(r, e) {
  var t = r.__state.conversionName.toString(),
    n = Math.round(r.r),
    i = Math.round(r.g),
    s = Math.round(r.b),
    a = r.a,
    o = Math.round(r.h),
    l = r.s.toFixed(1),
    c = r.v.toFixed(1);
  if (e || t === "THREE_CHAR_HEX" || t === "SIX_CHAR_HEX") {
    for (var u = r.hex.toString(16); u.length < 6; ) u = "0" + u;
    return "#" + u;
  } else {
    if (t === "CSS_RGB") return "rgb(" + n + "," + i + "," + s + ")";
    if (t === "CSS_RGBA")
      return "rgba(" + n + "," + i + "," + s + "," + a + ")";
    if (t === "HEX") return "0x" + r.hex.toString(16);
    if (t === "RGB_ARRAY") return "[" + n + "," + i + "," + s + "]";
    if (t === "RGBA_ARRAY") return "[" + n + "," + i + "," + s + "," + a + "]";
    if (t === "RGB_OBJ") return "{r:" + n + ",g:" + i + ",b:" + s + "}";
    if (t === "RGBA_OBJ")
      return "{r:" + n + ",g:" + i + ",b:" + s + ",a:" + a + "}";
    if (t === "HSV_OBJ") return "{h:" + o + ",s:" + l + ",v:" + c + "}";
    if (t === "HSVA_OBJ")
      return "{h:" + o + ",s:" + l + ",v:" + c + ",a:" + a + "}";
  }
  return "unknown format";
}
var s_ = Array.prototype.forEach,
  mo = Array.prototype.slice,
  ce = {
    BREAK: {},
    extend: function (e) {
      return (
        this.each(
          mo.call(arguments, 1),
          function (t) {
            var n = this.isObject(t) ? Object.keys(t) : [];
            n.forEach(
              function (i) {
                this.isUndefined(t[i]) || (e[i] = t[i]);
              }.bind(this)
            );
          },
          this
        ),
        e
      );
    },
    defaults: function (e) {
      return (
        this.each(
          mo.call(arguments, 1),
          function (t) {
            var n = this.isObject(t) ? Object.keys(t) : [];
            n.forEach(
              function (i) {
                this.isUndefined(e[i]) && (e[i] = t[i]);
              }.bind(this)
            );
          },
          this
        ),
        e
      );
    },
    compose: function () {
      var e = mo.call(arguments);
      return function () {
        for (var t = mo.call(arguments), n = e.length - 1; n >= 0; n--)
          t = [e[n].apply(this, t)];
        return t[0];
      };
    },
    each: function (e, t, n) {
      if (e) {
        if (s_ && e.forEach && e.forEach === s_) e.forEach(t, n);
        else if (e.length === e.length + 0) {
          var i = void 0,
            s = void 0;
          for (i = 0, s = e.length; i < s; i++)
            if (i in e && t.call(n, e[i], i) === this.BREAK) return;
        } else for (var a in e) if (t.call(n, e[a], a) === this.BREAK) return;
      }
    },
    defer: function (e) {
      setTimeout(e, 0);
    },
    debounce: function (e, t, n) {
      var i = void 0;
      return function () {
        var s = this,
          a = arguments;
        function o() {
          (i = null), n || e.apply(s, a);
        }
        var l = n || !i;
        clearTimeout(i), (i = setTimeout(o, t)), l && e.apply(s, a);
      };
    },
    toArray: function (e) {
      return e.toArray ? e.toArray() : mo.call(e);
    },
    isUndefined: function (e) {
      return e === void 0;
    },
    isNull: function (e) {
      return e === null;
    },
    isNaN: (function (r) {
      function e(t) {
        return r.apply(this, arguments);
      }
      return (
        (e.toString = function () {
          return r.toString();
        }),
        e
      );
    })(function (r) {
      return isNaN(r);
    }),
    isArray:
      Array.isArray ||
      function (r) {
        return r.constructor === Array;
      },
    isObject: function (e) {
      return e === Object(e);
    },
    isNumber: function (e) {
      return e === e + 0;
    },
    isString: function (e) {
      return e === e + "";
    },
    isBoolean: function (e) {
      return e === !1 || e === !0;
    },
    isFunction: function (e) {
      return e instanceof Function;
    },
  },
  n1 = [
    {
      litmus: ce.isString,
      conversions: {
        THREE_CHAR_HEX: {
          read: function (e) {
            var t = e.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i);
            return t === null
              ? !1
              : {
                  space: "HEX",
                  hex: parseInt(
                    "0x" +
                      t[1].toString() +
                      t[1].toString() +
                      t[2].toString() +
                      t[2].toString() +
                      t[3].toString() +
                      t[3].toString(),
                    0
                  ),
                };
          },
          write: ya,
        },
        SIX_CHAR_HEX: {
          read: function (e) {
            var t = e.match(/^#([A-F0-9]{6})$/i);
            return t === null
              ? !1
              : { space: "HEX", hex: parseInt("0x" + t[1].toString(), 0) };
          },
          write: ya,
        },
        CSS_RGB: {
          read: function (e) {
            var t = e.match(/^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/);
            return t === null
              ? !1
              : {
                  space: "RGB",
                  r: parseFloat(t[1]),
                  g: parseFloat(t[2]),
                  b: parseFloat(t[3]),
                };
          },
          write: ya,
        },
        CSS_RGBA: {
          read: function (e) {
            var t = e.match(
              /^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/
            );
            return t === null
              ? !1
              : {
                  space: "RGB",
                  r: parseFloat(t[1]),
                  g: parseFloat(t[2]),
                  b: parseFloat(t[3]),
                  a: parseFloat(t[4]),
                };
          },
          write: ya,
        },
      },
    },
    {
      litmus: ce.isNumber,
      conversions: {
        HEX: {
          read: function (e) {
            return { space: "HEX", hex: e, conversionName: "HEX" };
          },
          write: function (e) {
            return e.hex;
          },
        },
      },
    },
    {
      litmus: ce.isArray,
      conversions: {
        RGB_ARRAY: {
          read: function (e) {
            return e.length !== 3
              ? !1
              : { space: "RGB", r: e[0], g: e[1], b: e[2] };
          },
          write: function (e) {
            return [e.r, e.g, e.b];
          },
        },
        RGBA_ARRAY: {
          read: function (e) {
            return e.length !== 4
              ? !1
              : { space: "RGB", r: e[0], g: e[1], b: e[2], a: e[3] };
          },
          write: function (e) {
            return [e.r, e.g, e.b, e.a];
          },
        },
      },
    },
    {
      litmus: ce.isObject,
      conversions: {
        RGBA_OBJ: {
          read: function (e) {
            return ce.isNumber(e.r) &&
              ce.isNumber(e.g) &&
              ce.isNumber(e.b) &&
              ce.isNumber(e.a)
              ? { space: "RGB", r: e.r, g: e.g, b: e.b, a: e.a }
              : !1;
          },
          write: function (e) {
            return { r: e.r, g: e.g, b: e.b, a: e.a };
          },
        },
        RGB_OBJ: {
          read: function (e) {
            return ce.isNumber(e.r) && ce.isNumber(e.g) && ce.isNumber(e.b)
              ? { space: "RGB", r: e.r, g: e.g, b: e.b }
              : !1;
          },
          write: function (e) {
            return { r: e.r, g: e.g, b: e.b };
          },
        },
        HSVA_OBJ: {
          read: function (e) {
            return ce.isNumber(e.h) &&
              ce.isNumber(e.s) &&
              ce.isNumber(e.v) &&
              ce.isNumber(e.a)
              ? { space: "HSV", h: e.h, s: e.s, v: e.v, a: e.a }
              : !1;
          },
          write: function (e) {
            return { h: e.h, s: e.s, v: e.v, a: e.a };
          },
        },
        HSV_OBJ: {
          read: function (e) {
            return ce.isNumber(e.h) && ce.isNumber(e.s) && ce.isNumber(e.v)
              ? { space: "HSV", h: e.h, s: e.s, v: e.v }
              : !1;
          },
          write: function (e) {
            return { h: e.h, s: e.s, v: e.v };
          },
        },
      },
    },
  ],
  _o = void 0,
  hc = void 0,
  Yc = function () {
    hc = !1;
    var e = arguments.length > 1 ? ce.toArray(arguments) : arguments[0];
    return (
      ce.each(n1, function (t) {
        if (t.litmus(e))
          return (
            ce.each(t.conversions, function (n, i) {
              if (((_o = n.read(e)), hc === !1 && _o !== !1))
                return (
                  (hc = _o),
                  (_o.conversionName = i),
                  (_o.conversion = n),
                  ce.BREAK
                );
            }),
            ce.BREAK
          );
      }),
      hc
    );
  },
  a_ = void 0,
  tl = {
    hsv_to_rgb: function (e, t, n) {
      var i = Math.floor(e / 60) % 6,
        s = e / 60 - Math.floor(e / 60),
        a = n * (1 - t),
        o = n * (1 - s * t),
        l = n * (1 - (1 - s) * t),
        c = [
          [n, l, a],
          [o, n, a],
          [a, n, l],
          [a, o, n],
          [l, a, n],
          [n, a, o],
        ][i];
      return { r: c[0] * 255, g: c[1] * 255, b: c[2] * 255 };
    },
    rgb_to_hsv: function (e, t, n) {
      var i = Math.min(e, t, n),
        s = Math.max(e, t, n),
        a = s - i,
        o = void 0,
        l = void 0;
      if (s !== 0) l = a / s;
      else return { h: NaN, s: 0, v: 0 };
      return (
        e === s
          ? (o = (t - n) / a)
          : t === s
          ? (o = 2 + (n - e) / a)
          : (o = 4 + (e - t) / a),
        (o /= 6),
        o < 0 && (o += 1),
        { h: o * 360, s: l, v: s / 255 }
      );
    },
    rgb_to_hex: function (e, t, n) {
      var i = this.hex_with_component(0, 2, e);
      return (
        (i = this.hex_with_component(i, 1, t)),
        (i = this.hex_with_component(i, 0, n)),
        i
      );
    },
    component_from_hex: function (e, t) {
      return (e >> (t * 8)) & 255;
    },
    hex_with_component: function (e, t, n) {
      return (n << (a_ = t * 8)) | (e & ~(255 << a_));
    },
  },
  i1 =
    typeof Symbol == "function" && typeof Symbol.iterator == "symbol"
      ? function (r) {
          return typeof r;
        }
      : function (r) {
          return r &&
            typeof Symbol == "function" &&
            r.constructor === Symbol &&
            r !== Symbol.prototype
            ? "symbol"
            : typeof r;
        },
  yi = function (r, e) {
    if (!(r instanceof e))
      throw new TypeError("Cannot call a class as a function");
  },
  Ei = (function () {
    function r(e, t) {
      for (var n = 0; n < t.length; n++) {
        var i = t[n];
        (i.enumerable = i.enumerable || !1),
          (i.configurable = !0),
          "value" in i && (i.writable = !0),
          Object.defineProperty(e, i.key, i);
      }
    }
    return function (e, t, n) {
      return t && r(e.prototype, t), n && r(e, n), e;
    };
  })(),
  Fr = function r(e, t, n) {
    e === null && (e = Function.prototype);
    var i = Object.getOwnPropertyDescriptor(e, t);
    if (i === void 0) {
      var s = Object.getPrototypeOf(e);
      return s === null ? void 0 : r(s, t, n);
    } else {
      if ("value" in i) return i.value;
      var a = i.get;
      return a === void 0 ? void 0 : a.call(n);
    }
  },
  Vr = function (r, e) {
    if (typeof e != "function" && e !== null)
      throw new TypeError(
        "Super expression must either be null or a function, not " + typeof e
      );
    (r.prototype = Object.create(e && e.prototype, {
      constructor: { value: r, enumerable: !1, writable: !0, configurable: !0 },
    })),
      e &&
        (Object.setPrototypeOf
          ? Object.setPrototypeOf(r, e)
          : (r.__proto__ = e));
  },
  Gr = function (r, e) {
    if (!r)
      throw new ReferenceError(
        "this hasn't been initialised - super() hasn't been called"
      );
    return e && (typeof e == "object" || typeof e == "function") ? e : r;
  },
  zt = (function () {
    function r() {
      if (
        (yi(this, r),
        (this.__state = Yc.apply(this, arguments)),
        this.__state === !1)
      )
        throw new Error("Failed to interpret color arguments");
      this.__state.a = this.__state.a || 1;
    }
    return (
      Ei(r, [
        {
          key: "toString",
          value: function () {
            return ya(this);
          },
        },
        {
          key: "toHexString",
          value: function () {
            return ya(this, !0);
          },
        },
        {
          key: "toOriginal",
          value: function () {
            return this.__state.conversion.write(this);
          },
        },
      ]),
      r
    );
  })();
function ud(r, e, t) {
  Object.defineProperty(r, e, {
    get: function () {
      return this.__state.space === "RGB"
        ? this.__state[e]
        : (zt.recalculateRGB(this, e, t), this.__state[e]);
    },
    set: function (i) {
      this.__state.space !== "RGB" &&
        (zt.recalculateRGB(this, e, t), (this.__state.space = "RGB")),
        (this.__state[e] = i);
    },
  });
}
function hd(r, e) {
  Object.defineProperty(r, e, {
    get: function () {
      return this.__state.space === "HSV"
        ? this.__state[e]
        : (zt.recalculateHSV(this), this.__state[e]);
    },
    set: function (n) {
      this.__state.space !== "HSV" &&
        (zt.recalculateHSV(this), (this.__state.space = "HSV")),
        (this.__state[e] = n);
    },
  });
}
zt.recalculateRGB = function (r, e, t) {
  if (r.__state.space === "HEX")
    r.__state[e] = tl.component_from_hex(r.__state.hex, t);
  else if (r.__state.space === "HSV")
    ce.extend(r.__state, tl.hsv_to_rgb(r.__state.h, r.__state.s, r.__state.v));
  else throw new Error("Corrupted color state");
};
zt.recalculateHSV = function (r) {
  var e = tl.rgb_to_hsv(r.r, r.g, r.b);
  ce.extend(r.__state, { s: e.s, v: e.v }),
    ce.isNaN(e.h)
      ? ce.isUndefined(r.__state.h) && (r.__state.h = 0)
      : (r.__state.h = e.h);
};
zt.COMPONENTS = ["r", "g", "b", "h", "s", "v", "hex", "a"];
ud(zt.prototype, "r", 2);
ud(zt.prototype, "g", 1);
ud(zt.prototype, "b", 0);
hd(zt.prototype, "h");
hd(zt.prototype, "s");
hd(zt.prototype, "v");
Object.defineProperty(zt.prototype, "a", {
  get: function () {
    return this.__state.a;
  },
  set: function (e) {
    this.__state.a = e;
  },
});
Object.defineProperty(zt.prototype, "hex", {
  get: function () {
    return (
      this.__state.space !== "HEX" &&
        ((this.__state.hex = tl.rgb_to_hex(this.r, this.g, this.b)),
        (this.__state.space = "HEX")),
      this.__state.hex
    );
  },
  set: function (e) {
    (this.__state.space = "HEX"), (this.__state.hex = e);
  },
});
var Wr = (function () {
    function r(e, t) {
      yi(this, r),
        (this.initialValue = e[t]),
        (this.domElement = document.createElement("div")),
        (this.object = e),
        (this.property = t),
        (this.__onChange = void 0),
        (this.__onFinishChange = void 0);
    }
    return (
      Ei(r, [
        {
          key: "onChange",
          value: function (t) {
            return (this.__onChange = t), this;
          },
        },
        {
          key: "onFinishChange",
          value: function (t) {
            return (this.__onFinishChange = t), this;
          },
        },
        {
          key: "setValue",
          value: function (t) {
            return (
              (this.object[this.property] = t),
              this.__onChange && this.__onChange.call(this, t),
              this.updateDisplay(),
              this
            );
          },
        },
        {
          key: "getValue",
          value: function () {
            return this.object[this.property];
          },
        },
        {
          key: "updateDisplay",
          value: function () {
            return this;
          },
        },
        {
          key: "isModified",
          value: function () {
            return this.initialValue !== this.getValue();
          },
        },
      ]),
      r
    );
  })(),
  r1 = {
    HTMLEvents: ["change"],
    MouseEvents: ["click", "mousemove", "mousedown", "mouseup", "mouseover"],
    KeyboardEvents: ["keydown"],
  },
  W0 = {};
ce.each(r1, function (r, e) {
  ce.each(r, function (t) {
    W0[t] = e;
  });
});
var s1 = /(\d+(\.\d+)?)px/;
function bi(r) {
  if (r === "0" || ce.isUndefined(r)) return 0;
  var e = r.match(s1);
  return ce.isNull(e) ? 0 : parseFloat(e[1]);
}
var Z = {
    makeSelectable: function (e, t) {
      e === void 0 ||
        e.style === void 0 ||
        ((e.onselectstart = t
          ? function () {
              return !1;
            }
          : function () {}),
        (e.style.MozUserSelect = t ? "auto" : "none"),
        (e.style.KhtmlUserSelect = t ? "auto" : "none"),
        (e.unselectable = t ? "on" : "off"));
    },
    makeFullscreen: function (e, t, n) {
      var i = n,
        s = t;
      ce.isUndefined(s) && (s = !0),
        ce.isUndefined(i) && (i = !0),
        (e.style.position = "absolute"),
        s && ((e.style.left = 0), (e.style.right = 0)),
        i && ((e.style.top = 0), (e.style.bottom = 0));
    },
    fakeEvent: function (e, t, n, i) {
      var s = n || {},
        a = W0[t];
      if (!a) throw new Error("Event type " + t + " not supported.");
      var o = document.createEvent(a);
      switch (a) {
        case "MouseEvents": {
          var l = s.x || s.clientX || 0,
            c = s.y || s.clientY || 0;
          o.initMouseEvent(
            t,
            s.bubbles || !1,
            s.cancelable || !0,
            window,
            s.clickCount || 1,
            0,
            0,
            l,
            c,
            !1,
            !1,
            !1,
            !1,
            0,
            null
          );
          break;
        }
        case "KeyboardEvents": {
          var u = o.initKeyboardEvent || o.initKeyEvent;
          ce.defaults(s, {
            cancelable: !0,
            ctrlKey: !1,
            altKey: !1,
            shiftKey: !1,
            metaKey: !1,
            keyCode: void 0,
            charCode: void 0,
          }),
            u(
              t,
              s.bubbles || !1,
              s.cancelable,
              window,
              s.ctrlKey,
              s.altKey,
              s.shiftKey,
              s.metaKey,
              s.keyCode,
              s.charCode
            );
          break;
        }
        default: {
          o.initEvent(t, s.bubbles || !1, s.cancelable || !0);
          break;
        }
      }
      ce.defaults(o, i), e.dispatchEvent(o);
    },
    bind: function (e, t, n, i) {
      var s = i || !1;
      return (
        e.addEventListener
          ? e.addEventListener(t, n, s)
          : e.attachEvent && e.attachEvent("on" + t, n),
        Z
      );
    },
    unbind: function (e, t, n, i) {
      var s = i || !1;
      return (
        e.removeEventListener
          ? e.removeEventListener(t, n, s)
          : e.detachEvent && e.detachEvent("on" + t, n),
        Z
      );
    },
    addClass: function (e, t) {
      if (e.className === void 0) e.className = t;
      else if (e.className !== t) {
        var n = e.className.split(/ +/);
        n.indexOf(t) === -1 &&
          (n.push(t),
          (e.className = n.join(" ").replace(/^\s+/, "").replace(/\s+$/, "")));
      }
      return Z;
    },
    removeClass: function (e, t) {
      if (t)
        if (e.className === t) e.removeAttribute("class");
        else {
          var n = e.className.split(/ +/),
            i = n.indexOf(t);
          i !== -1 && (n.splice(i, 1), (e.className = n.join(" ")));
        }
      else e.className = void 0;
      return Z;
    },
    hasClass: function (e, t) {
      return (
        new RegExp("(?:^|\\s+)" + t + "(?:\\s+|$)").test(e.className) || !1
      );
    },
    getWidth: function (e) {
      var t = getComputedStyle(e);
      return (
        bi(t["border-left-width"]) +
        bi(t["border-right-width"]) +
        bi(t["padding-left"]) +
        bi(t["padding-right"]) +
        bi(t.width)
      );
    },
    getHeight: function (e) {
      var t = getComputedStyle(e);
      return (
        bi(t["border-top-width"]) +
        bi(t["border-bottom-width"]) +
        bi(t["padding-top"]) +
        bi(t["padding-bottom"]) +
        bi(t.height)
      );
    },
    getOffset: function (e) {
      var t = e,
        n = { left: 0, top: 0 };
      if (t.offsetParent)
        do
          (n.left += t.offsetLeft),
            (n.top += t.offsetTop),
            (t = t.offsetParent);
        while (t);
      return n;
    },
    isActive: function (e) {
      return e === document.activeElement && (e.type || e.href);
    },
  },
  fd = (function (r) {
    Vr(e, r);
    function e(t, n) {
      yi(this, e);
      var i = Gr(
          this,
          (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)
        ),
        s = i;
      (i.__prev = i.getValue()),
        (i.__checkbox = document.createElement("input")),
        i.__checkbox.setAttribute("type", "checkbox");
      function a() {
        s.setValue(!s.__prev);
      }
      return (
        Z.bind(i.__checkbox, "change", a, !1),
        i.domElement.appendChild(i.__checkbox),
        i.updateDisplay(),
        i
      );
    }
    return (
      Ei(e, [
        {
          key: "setValue",
          value: function (n) {
            var i = Fr(
              e.prototype.__proto__ || Object.getPrototypeOf(e.prototype),
              "setValue",
              this
            ).call(this, n);
            return (
              this.__onFinishChange &&
                this.__onFinishChange.call(this, this.getValue()),
              (this.__prev = this.getValue()),
              i
            );
          },
        },
        {
          key: "updateDisplay",
          value: function () {
            return (
              this.getValue() === !0
                ? (this.__checkbox.setAttribute("checked", "checked"),
                  (this.__checkbox.checked = !0),
                  (this.__prev = !0))
                : ((this.__checkbox.checked = !1), (this.__prev = !1)),
              Fr(
                e.prototype.__proto__ || Object.getPrototypeOf(e.prototype),
                "updateDisplay",
                this
              ).call(this)
            );
          },
        },
      ]),
      e
    );
  })(Wr),
  X0 = (function (r) {
    Vr(e, r);
    function e(t, n, i) {
      yi(this, e);
      var s = Gr(
          this,
          (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)
        ),
        a = i,
        o = s;
      if (((s.__select = document.createElement("select")), ce.isArray(a))) {
        var l = {};
        ce.each(a, function (c) {
          l[c] = c;
        }),
          (a = l);
      }
      return (
        ce.each(a, function (c, u) {
          var h = document.createElement("option");
          (h.innerHTML = u),
            h.setAttribute("value", c),
            o.__select.appendChild(h);
        }),
        s.updateDisplay(),
        Z.bind(s.__select, "change", function () {
          var c = this.options[this.selectedIndex].value;
          o.setValue(c);
        }),
        s.domElement.appendChild(s.__select),
        s
      );
    }
    return (
      Ei(e, [
        {
          key: "setValue",
          value: function (n) {
            var i = Fr(
              e.prototype.__proto__ || Object.getPrototypeOf(e.prototype),
              "setValue",
              this
            ).call(this, n);
            return (
              this.__onFinishChange &&
                this.__onFinishChange.call(this, this.getValue()),
              i
            );
          },
        },
        {
          key: "updateDisplay",
          value: function () {
            return Z.isActive(this.__select)
              ? this
              : ((this.__select.value = this.getValue()),
                Fr(
                  e.prototype.__proto__ || Object.getPrototypeOf(e.prototype),
                  "updateDisplay",
                  this
                ).call(this));
          },
        },
      ]),
      e
    );
  })(Wr),
  Y0 = (function (r) {
    Vr(e, r);
    function e(t, n) {
      yi(this, e);
      var i = Gr(
          this,
          (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)
        ),
        s = i;
      function a() {
        s.setValue(s.__input.value);
      }
      function o() {
        s.__onFinishChange && s.__onFinishChange.call(s, s.getValue());
      }
      return (
        (i.__input = document.createElement("input")),
        i.__input.setAttribute("type", "text"),
        Z.bind(i.__input, "keyup", a),
        Z.bind(i.__input, "change", a),
        Z.bind(i.__input, "blur", o),
        Z.bind(i.__input, "keydown", function (l) {
          l.keyCode === 13 && this.blur();
        }),
        i.updateDisplay(),
        i.domElement.appendChild(i.__input),
        i
      );
    }
    return (
      Ei(e, [
        {
          key: "updateDisplay",
          value: function () {
            return (
              Z.isActive(this.__input) ||
                (this.__input.value = this.getValue()),
              Fr(
                e.prototype.__proto__ || Object.getPrototypeOf(e.prototype),
                "updateDisplay",
                this
              ).call(this)
            );
          },
        },
      ]),
      e
    );
  })(Wr);
function o_(r) {
  var e = r.toString();
  return e.indexOf(".") > -1 ? e.length - e.indexOf(".") - 1 : 0;
}
var dd = (function (r) {
  Vr(e, r);
  function e(t, n, i) {
    yi(this, e);
    var s = Gr(
        this,
        (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)
      ),
      a = i || {};
    return (
      (s.__min = a.min),
      (s.__max = a.max),
      (s.__step = a.step),
      ce.isUndefined(s.__step)
        ? s.initialValue === 0
          ? (s.__impliedStep = 1)
          : (s.__impliedStep =
              Math.pow(
                10,
                Math.floor(Math.log(Math.abs(s.initialValue)) / Math.LN10)
              ) / 10)
        : (s.__impliedStep = s.__step),
      (s.__precision = o_(s.__impliedStep)),
      s
    );
  }
  return (
    Ei(e, [
      {
        key: "setValue",
        value: function (n) {
          var i = n;
          return (
            this.__min !== void 0 && i < this.__min
              ? (i = this.__min)
              : this.__max !== void 0 && i > this.__max && (i = this.__max),
            this.__step !== void 0 &&
              i % this.__step !== 0 &&
              (i = Math.round(i / this.__step) * this.__step),
            Fr(
              e.prototype.__proto__ || Object.getPrototypeOf(e.prototype),
              "setValue",
              this
            ).call(this, i)
          );
        },
      },
      {
        key: "min",
        value: function (n) {
          return (this.__min = n), this;
        },
      },
      {
        key: "max",
        value: function (n) {
          return (this.__max = n), this;
        },
      },
      {
        key: "step",
        value: function (n) {
          return (
            (this.__step = n),
            (this.__impliedStep = n),
            (this.__precision = o_(n)),
            this
          );
        },
      },
    ]),
    e
  );
})(Wr);
function a1(r, e) {
  var t = Math.pow(10, e);
  return Math.round(r * t) / t;
}
var nl = (function (r) {
  Vr(e, r);
  function e(t, n, i) {
    yi(this, e);
    var s = Gr(
      this,
      (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, i)
    );
    s.__truncationSuspended = !1;
    var a = s,
      o = void 0;
    function l() {
      var g = parseFloat(a.__input.value);
      ce.isNaN(g) || a.setValue(g);
    }
    function c() {
      a.__onFinishChange && a.__onFinishChange.call(a, a.getValue());
    }
    function u() {
      c();
    }
    function h(g) {
      var m = o - g.clientY;
      a.setValue(a.getValue() + m * a.__impliedStep), (o = g.clientY);
    }
    function f() {
      Z.unbind(window, "mousemove", h), Z.unbind(window, "mouseup", f), c();
    }
    function p(g) {
      Z.bind(window, "mousemove", h),
        Z.bind(window, "mouseup", f),
        (o = g.clientY);
    }
    return (
      (s.__input = document.createElement("input")),
      s.__input.setAttribute("type", "text"),
      Z.bind(s.__input, "change", l),
      Z.bind(s.__input, "blur", u),
      Z.bind(s.__input, "mousedown", p),
      Z.bind(s.__input, "keydown", function (g) {
        g.keyCode === 13 &&
          ((a.__truncationSuspended = !0),
          this.blur(),
          (a.__truncationSuspended = !1),
          c());
      }),
      s.updateDisplay(),
      s.domElement.appendChild(s.__input),
      s
    );
  }
  return (
    Ei(e, [
      {
        key: "updateDisplay",
        value: function () {
          return (
            (this.__input.value = this.__truncationSuspended
              ? this.getValue()
              : a1(this.getValue(), this.__precision)),
            Fr(
              e.prototype.__proto__ || Object.getPrototypeOf(e.prototype),
              "updateDisplay",
              this
            ).call(this)
          );
        },
      },
    ]),
    e
  );
})(dd);
function l_(r, e, t, n, i) {
  return n + (i - n) * ((r - e) / (t - e));
}
var qc = (function (r) {
    Vr(e, r);
    function e(t, n, i, s, a) {
      yi(this, e);
      var o = Gr(
          this,
          (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n, {
            min: i,
            max: s,
            step: a,
          })
        ),
        l = o;
      (o.__background = document.createElement("div")),
        (o.__foreground = document.createElement("div")),
        Z.bind(o.__background, "mousedown", c),
        Z.bind(o.__background, "touchstart", f),
        Z.addClass(o.__background, "slider"),
        Z.addClass(o.__foreground, "slider-fg");
      function c(m) {
        document.activeElement.blur(),
          Z.bind(window, "mousemove", u),
          Z.bind(window, "mouseup", h),
          u(m);
      }
      function u(m) {
        m.preventDefault();
        var _ = l.__background.getBoundingClientRect();
        return l.setValue(l_(m.clientX, _.left, _.right, l.__min, l.__max)), !1;
      }
      function h() {
        Z.unbind(window, "mousemove", u),
          Z.unbind(window, "mouseup", h),
          l.__onFinishChange && l.__onFinishChange.call(l, l.getValue());
      }
      function f(m) {
        m.touches.length === 1 &&
          (Z.bind(window, "touchmove", p), Z.bind(window, "touchend", g), p(m));
      }
      function p(m) {
        var _ = m.touches[0].clientX,
          d = l.__background.getBoundingClientRect();
        l.setValue(l_(_, d.left, d.right, l.__min, l.__max));
      }
      function g() {
        Z.unbind(window, "touchmove", p),
          Z.unbind(window, "touchend", g),
          l.__onFinishChange && l.__onFinishChange.call(l, l.getValue());
      }
      return (
        o.updateDisplay(),
        o.__background.appendChild(o.__foreground),
        o.domElement.appendChild(o.__background),
        o
      );
    }
    return (
      Ei(e, [
        {
          key: "updateDisplay",
          value: function () {
            var n = (this.getValue() - this.__min) / (this.__max - this.__min);
            return (
              (this.__foreground.style.width = n * 100 + "%"),
              Fr(
                e.prototype.__proto__ || Object.getPrototypeOf(e.prototype),
                "updateDisplay",
                this
              ).call(this)
            );
          },
        },
      ]),
      e
    );
  })(dd),
  pd = (function (r) {
    Vr(e, r);
    function e(t, n, i) {
      yi(this, e);
      var s = Gr(
          this,
          (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)
        ),
        a = s;
      return (
        (s.__button = document.createElement("div")),
        (s.__button.innerHTML = i === void 0 ? "Fire" : i),
        Z.bind(s.__button, "click", function (o) {
          return o.preventDefault(), a.fire(), !1;
        }),
        Z.addClass(s.__button, "button"),
        s.domElement.appendChild(s.__button),
        s
      );
    }
    return (
      Ei(e, [
        {
          key: "fire",
          value: function () {
            this.__onChange && this.__onChange.call(this),
              this.getValue().call(this.object),
              this.__onFinishChange &&
                this.__onFinishChange.call(this, this.getValue());
          },
        },
      ]),
      e
    );
  })(Wr),
  jc = (function (r) {
    Vr(e, r);
    function e(t, n) {
      yi(this, e);
      var i = Gr(
        this,
        (e.__proto__ || Object.getPrototypeOf(e)).call(this, t, n)
      );
      (i.__color = new zt(i.getValue())), (i.__temp = new zt(0));
      var s = i;
      (i.domElement = document.createElement("div")),
        Z.makeSelectable(i.domElement, !1),
        (i.__selector = document.createElement("div")),
        (i.__selector.className = "selector"),
        (i.__saturation_field = document.createElement("div")),
        (i.__saturation_field.className = "saturation-field"),
        (i.__field_knob = document.createElement("div")),
        (i.__field_knob.className = "field-knob"),
        (i.__field_knob_border = "2px solid "),
        (i.__hue_knob = document.createElement("div")),
        (i.__hue_knob.className = "hue-knob"),
        (i.__hue_field = document.createElement("div")),
        (i.__hue_field.className = "hue-field"),
        (i.__input = document.createElement("input")),
        (i.__input.type = "text"),
        (i.__input_textShadow = "0 1px 1px "),
        Z.bind(i.__input, "keydown", function (m) {
          m.keyCode === 13 && h.call(this);
        }),
        Z.bind(i.__input, "blur", h),
        Z.bind(i.__selector, "mousedown", function () {
          Z.addClass(this, "drag").bind(window, "mouseup", function () {
            Z.removeClass(s.__selector, "drag");
          });
        }),
        Z.bind(i.__selector, "touchstart", function () {
          Z.addClass(this, "drag").bind(window, "touchend", function () {
            Z.removeClass(s.__selector, "drag");
          });
        });
      var a = document.createElement("div");
      ce.extend(i.__selector.style, {
        width: "122px",
        height: "102px",
        padding: "3px",
        backgroundColor: "#222",
        boxShadow: "0px 1px 3px rgba(0,0,0,0.3)",
      }),
        ce.extend(i.__field_knob.style, {
          position: "absolute",
          width: "12px",
          height: "12px",
          border: i.__field_knob_border + (i.__color.v < 0.5 ? "#fff" : "#000"),
          boxShadow: "0px 1px 3px rgba(0,0,0,0.5)",
          borderRadius: "12px",
          zIndex: 1,
        }),
        ce.extend(i.__hue_knob.style, {
          position: "absolute",
          width: "15px",
          height: "2px",
          borderRight: "4px solid #fff",
          zIndex: 1,
        }),
        ce.extend(i.__saturation_field.style, {
          width: "100px",
          height: "100px",
          border: "1px solid #555",
          marginRight: "3px",
          display: "inline-block",
          cursor: "pointer",
        }),
        ce.extend(a.style, {
          width: "100%",
          height: "100%",
          background: "none",
        }),
        c_(a, "top", "rgba(0,0,0,0)", "#000"),
        ce.extend(i.__hue_field.style, {
          width: "15px",
          height: "100px",
          border: "1px solid #555",
          cursor: "ns-resize",
          position: "absolute",
          top: "3px",
          right: "3px",
        }),
        l1(i.__hue_field),
        ce.extend(i.__input.style, {
          outline: "none",
          textAlign: "center",
          color: "#fff",
          border: 0,
          fontWeight: "bold",
          textShadow: i.__input_textShadow + "rgba(0,0,0,0.7)",
        }),
        Z.bind(i.__saturation_field, "mousedown", o),
        Z.bind(i.__saturation_field, "touchstart", o),
        Z.bind(i.__field_knob, "mousedown", o),
        Z.bind(i.__field_knob, "touchstart", o),
        Z.bind(i.__hue_field, "mousedown", l),
        Z.bind(i.__hue_field, "touchstart", l);
      function o(m) {
        p(m),
          Z.bind(window, "mousemove", p),
          Z.bind(window, "touchmove", p),
          Z.bind(window, "mouseup", c),
          Z.bind(window, "touchend", c);
      }
      function l(m) {
        g(m),
          Z.bind(window, "mousemove", g),
          Z.bind(window, "touchmove", g),
          Z.bind(window, "mouseup", u),
          Z.bind(window, "touchend", u);
      }
      function c() {
        Z.unbind(window, "mousemove", p),
          Z.unbind(window, "touchmove", p),
          Z.unbind(window, "mouseup", c),
          Z.unbind(window, "touchend", c),
          f();
      }
      function u() {
        Z.unbind(window, "mousemove", g),
          Z.unbind(window, "touchmove", g),
          Z.unbind(window, "mouseup", u),
          Z.unbind(window, "touchend", u),
          f();
      }
      function h() {
        var m = Yc(this.value);
        m !== !1
          ? ((s.__color.__state = m), s.setValue(s.__color.toOriginal()))
          : (this.value = s.__color.toString());
      }
      function f() {
        s.__onFinishChange &&
          s.__onFinishChange.call(s, s.__color.toOriginal());
      }
      i.__saturation_field.appendChild(a),
        i.__selector.appendChild(i.__field_knob),
        i.__selector.appendChild(i.__saturation_field),
        i.__selector.appendChild(i.__hue_field),
        i.__hue_field.appendChild(i.__hue_knob),
        i.domElement.appendChild(i.__input),
        i.domElement.appendChild(i.__selector),
        i.updateDisplay();
      function p(m) {
        m.type.indexOf("touch") === -1 && m.preventDefault();
        var _ = s.__saturation_field.getBoundingClientRect(),
          d = (m.touches && m.touches[0]) || m,
          y = d.clientX,
          v = d.clientY,
          S = (y - _.left) / (_.right - _.left),
          E = 1 - (v - _.top) / (_.bottom - _.top);
        return (
          E > 1 ? (E = 1) : E < 0 && (E = 0),
          S > 1 ? (S = 1) : S < 0 && (S = 0),
          (s.__color.v = E),
          (s.__color.s = S),
          s.setValue(s.__color.toOriginal()),
          !1
        );
      }
      function g(m) {
        m.type.indexOf("touch") === -1 && m.preventDefault();
        var _ = s.__hue_field.getBoundingClientRect(),
          d = (m.touches && m.touches[0]) || m,
          y = d.clientY,
          v = 1 - (y - _.top) / (_.bottom - _.top);
        return (
          v > 1 ? (v = 1) : v < 0 && (v = 0),
          (s.__color.h = v * 360),
          s.setValue(s.__color.toOriginal()),
          !1
        );
      }
      return i;
    }
    return (
      Ei(e, [
        {
          key: "updateDisplay",
          value: function () {
            var n = Yc(this.getValue());
            if (n !== !1) {
              var i = !1;
              ce.each(
                zt.COMPONENTS,
                function (o) {
                  if (
                    !ce.isUndefined(n[o]) &&
                    !ce.isUndefined(this.__color.__state[o]) &&
                    n[o] !== this.__color.__state[o]
                  )
                    return (i = !0), {};
                },
                this
              ),
                i && ce.extend(this.__color.__state, n);
            }
            ce.extend(this.__temp.__state, this.__color.__state),
              (this.__temp.a = 1);
            var s = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0,
              a = 255 - s;
            ce.extend(this.__field_knob.style, {
              marginLeft: 100 * this.__color.s - 7 + "px",
              marginTop: 100 * (1 - this.__color.v) - 7 + "px",
              backgroundColor: this.__temp.toHexString(),
              border:
                this.__field_knob_border + "rgb(" + s + "," + s + "," + s + ")",
            }),
              (this.__hue_knob.style.marginTop =
                (1 - this.__color.h / 360) * 100 + "px"),
              (this.__temp.s = 1),
              (this.__temp.v = 1),
              c_(
                this.__saturation_field,
                "left",
                "#fff",
                this.__temp.toHexString()
              ),
              (this.__input.value = this.__color.toString()),
              ce.extend(this.__input.style, {
                backgroundColor: this.__color.toHexString(),
                color: "rgb(" + s + "," + s + "," + s + ")",
                textShadow:
                  this.__input_textShadow +
                  "rgba(" +
                  a +
                  "," +
                  a +
                  "," +
                  a +
                  ",.7)",
              });
          },
        },
      ]),
      e
    );
  })(Wr),
  o1 = ["-moz-", "-o-", "-webkit-", "-ms-", ""];
function c_(r, e, t, n) {
  (r.style.background = ""),
    ce.each(o1, function (i) {
      r.style.cssText +=
        "background: " +
        i +
        "linear-gradient(" +
        e +
        ", " +
        t +
        " 0%, " +
        n +
        " 100%); ";
    });
}
function l1(r) {
  (r.style.background = ""),
    (r.style.cssText +=
      "background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);"),
    (r.style.cssText +=
      "background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
    (r.style.cssText +=
      "background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
    (r.style.cssText +=
      "background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);"),
    (r.style.cssText +=
      "background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);");
}
var c1 = {
    load: function (e, t) {
      var n = t || document,
        i = n.createElement("link");
      (i.type = "text/css"),
        (i.rel = "stylesheet"),
        (i.href = e),
        n.getElementsByTagName("head")[0].appendChild(i);
    },
    inject: function (e, t) {
      var n = t || document,
        i = document.createElement("style");
      (i.type = "text/css"), (i.innerHTML = e);
      var s = n.getElementsByTagName("head")[0];
      try {
        s.appendChild(i);
      } catch {}
    },
  },
  u1 = `<div id="dg-save" class="dg dialogue">

  Here's the new load parameter for your <code>GUI</code>'s constructor:

  <textarea id="dg-new-constructor"></textarea>

  <div id="dg-save-locally">

    <input id="dg-local-storage" type="checkbox"/> Automatically save
    values to <code>localStorage</code> on exit.

    <div id="dg-local-explain">The values saved to <code>localStorage</code> will
      override those passed to <code>dat.GUI</code>'s constructor. This makes it
      easier to work incrementally, but <code>localStorage</code> is fragile,
      and your friends may not see the same values you do.

    </div>

  </div>

</div>`,
  h1 = function (e, t) {
    var n = e[t];
    return ce.isArray(arguments[2]) || ce.isObject(arguments[2])
      ? new X0(e, t, arguments[2])
      : ce.isNumber(n)
      ? ce.isNumber(arguments[2]) && ce.isNumber(arguments[3])
        ? ce.isNumber(arguments[4])
          ? new qc(e, t, arguments[2], arguments[3], arguments[4])
          : new qc(e, t, arguments[2], arguments[3])
        : ce.isNumber(arguments[4])
        ? new nl(e, t, {
            min: arguments[2],
            max: arguments[3],
            step: arguments[4],
          })
        : new nl(e, t, { min: arguments[2], max: arguments[3] })
      : ce.isString(n)
      ? new Y0(e, t)
      : ce.isFunction(n)
      ? new pd(e, t, "")
      : ce.isBoolean(n)
      ? new fd(e, t)
      : null;
  };
function f1(r) {
  setTimeout(r, 1e3 / 60);
}
var d1 =
    window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.oRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    f1,
  p1 = (function () {
    function r() {
      yi(this, r),
        (this.backgroundElement = document.createElement("div")),
        ce.extend(this.backgroundElement.style, {
          backgroundColor: "rgba(0,0,0,0.8)",
          top: 0,
          left: 0,
          display: "none",
          zIndex: "1000",
          opacity: 0,
          WebkitTransition: "opacity 0.2s linear",
          transition: "opacity 0.2s linear",
        }),
        Z.makeFullscreen(this.backgroundElement),
        (this.backgroundElement.style.position = "fixed"),
        (this.domElement = document.createElement("div")),
        ce.extend(this.domElement.style, {
          position: "fixed",
          display: "none",
          zIndex: "1001",
          opacity: 0,
          WebkitTransition:
            "-webkit-transform 0.2s ease-out, opacity 0.2s linear",
          transition: "transform 0.2s ease-out, opacity 0.2s linear",
        }),
        document.body.appendChild(this.backgroundElement),
        document.body.appendChild(this.domElement);
      var e = this;
      Z.bind(this.backgroundElement, "click", function () {
        e.hide();
      });
    }
    return (
      Ei(r, [
        {
          key: "show",
          value: function () {
            var t = this;
            (this.backgroundElement.style.display = "block"),
              (this.domElement.style.display = "block"),
              (this.domElement.style.opacity = 0),
              (this.domElement.style.webkitTransform = "scale(1.1)"),
              this.layout(),
              ce.defer(function () {
                (t.backgroundElement.style.opacity = 1),
                  (t.domElement.style.opacity = 1),
                  (t.domElement.style.webkitTransform = "scale(1)");
              });
          },
        },
        {
          key: "hide",
          value: function () {
            var t = this,
              n = function i() {
                (t.domElement.style.display = "none"),
                  (t.backgroundElement.style.display = "none"),
                  Z.unbind(t.domElement, "webkitTransitionEnd", i),
                  Z.unbind(t.domElement, "transitionend", i),
                  Z.unbind(t.domElement, "oTransitionEnd", i);
              };
            Z.bind(this.domElement, "webkitTransitionEnd", n),
              Z.bind(this.domElement, "transitionend", n),
              Z.bind(this.domElement, "oTransitionEnd", n),
              (this.backgroundElement.style.opacity = 0),
              (this.domElement.style.opacity = 0),
              (this.domElement.style.webkitTransform = "scale(1.1)");
          },
        },
        {
          key: "layout",
          value: function () {
            (this.domElement.style.left =
              window.innerWidth / 2 - Z.getWidth(this.domElement) / 2 + "px"),
              (this.domElement.style.top =
                window.innerHeight / 2 -
                Z.getHeight(this.domElement) / 2 +
                "px");
          },
        },
      ]),
      r
    );
  })(),
  m1 =
    t1(`.dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}
`);
c1.inject(m1);
var u_ = "dg",
  h_ = 72,
  f_ = 20,
  il = "Default",
  Mo = (function () {
    try {
      return !!window.localStorage;
    } catch {
      return !1;
    }
  })(),
  Bo = void 0,
  d_ = !0,
  ha = void 0,
  Mh = !1,
  q0 = [],
  _t = function r(e) {
    var t = this,
      n = e || {};
    (this.domElement = document.createElement("div")),
      (this.__ul = document.createElement("ul")),
      this.domElement.appendChild(this.__ul),
      Z.addClass(this.domElement, u_),
      (this.__folders = {}),
      (this.__controllers = []),
      (this.__rememberedObjects = []),
      (this.__rememberedObjectIndecesToControllers = []),
      (this.__listening = []),
      (n = ce.defaults(n, {
        closeOnTop: !1,
        autoPlace: !0,
        width: r.DEFAULT_WIDTH,
      })),
      (n = ce.defaults(n, { resizable: n.autoPlace, hideable: n.autoPlace })),
      ce.isUndefined(n.load)
        ? (n.load = { preset: il })
        : n.preset && (n.load.preset = n.preset),
      ce.isUndefined(n.parent) && n.hideable && q0.push(this),
      (n.resizable = ce.isUndefined(n.parent) && n.resizable),
      n.autoPlace && ce.isUndefined(n.scrollable) && (n.scrollable = !0);
    var i = Mo && localStorage.getItem(fa(this, "isLocal")) === "true",
      s = void 0,
      a = void 0;
    if (
      (Object.defineProperties(this, {
        parent: {
          get: function () {
            return n.parent;
          },
        },
        scrollable: {
          get: function () {
            return n.scrollable;
          },
        },
        autoPlace: {
          get: function () {
            return n.autoPlace;
          },
        },
        closeOnTop: {
          get: function () {
            return n.closeOnTop;
          },
        },
        preset: {
          get: function () {
            return t.parent ? t.getRoot().preset : n.load.preset;
          },
          set: function (f) {
            t.parent ? (t.getRoot().preset = f) : (n.load.preset = f),
              x1(this),
              t.revert();
          },
        },
        width: {
          get: function () {
            return n.width;
          },
          set: function (f) {
            (n.width = f), gf(t, f);
          },
        },
        name: {
          get: function () {
            return n.name;
          },
          set: function (f) {
            (n.name = f), a && (a.innerHTML = n.name);
          },
        },
        closed: {
          get: function () {
            return n.closed;
          },
          set: function (f) {
            (n.closed = f),
              n.closed
                ? Z.addClass(t.__ul, r.CLASS_CLOSED)
                : Z.removeClass(t.__ul, r.CLASS_CLOSED),
              this.onResize(),
              t.__closeButton &&
                (t.__closeButton.innerHTML = f ? r.TEXT_OPEN : r.TEXT_CLOSED);
          },
        },
        load: {
          get: function () {
            return n.load;
          },
        },
        useLocalStorage: {
          get: function () {
            return i;
          },
          set: function (f) {
            Mo &&
              ((i = f),
              f ? Z.bind(window, "unload", s) : Z.unbind(window, "unload", s),
              localStorage.setItem(fa(t, "isLocal"), f));
          },
        },
      }),
      ce.isUndefined(n.parent))
    ) {
      if (
        ((this.closed = n.closed || !1),
        Z.addClass(this.domElement, r.CLASS_MAIN),
        Z.makeSelectable(this.domElement, !1),
        Mo && i)
      ) {
        t.useLocalStorage = !0;
        var o = localStorage.getItem(fa(this, "gui"));
        o && (n.load = JSON.parse(o));
      }
      (this.__closeButton = document.createElement("div")),
        (this.__closeButton.innerHTML = r.TEXT_CLOSED),
        Z.addClass(this.__closeButton, r.CLASS_CLOSE_BUTTON),
        n.closeOnTop
          ? (Z.addClass(this.__closeButton, r.CLASS_CLOSE_TOP),
            this.domElement.insertBefore(
              this.__closeButton,
              this.domElement.childNodes[0]
            ))
          : (Z.addClass(this.__closeButton, r.CLASS_CLOSE_BOTTOM),
            this.domElement.appendChild(this.__closeButton)),
        Z.bind(this.__closeButton, "click", function () {
          t.closed = !t.closed;
        });
    } else {
      n.closed === void 0 && (n.closed = !0);
      var l = document.createTextNode(n.name);
      Z.addClass(l, "controller-name"), (a = md(t, l));
      var c = function (f) {
        return f.preventDefault(), (t.closed = !t.closed), !1;
      };
      Z.addClass(this.__ul, r.CLASS_CLOSED),
        Z.addClass(a, "title"),
        Z.bind(a, "click", c),
        n.closed || (this.closed = !1);
    }
    n.autoPlace &&
      (ce.isUndefined(n.parent) &&
        (d_ &&
          ((ha = document.createElement("div")),
          Z.addClass(ha, u_),
          Z.addClass(ha, r.CLASS_AUTO_PLACE_CONTAINER),
          document.body.appendChild(ha),
          (d_ = !1)),
        ha.appendChild(this.domElement),
        Z.addClass(this.domElement, r.CLASS_AUTO_PLACE)),
      this.parent || gf(t, n.width)),
      (this.__resizeHandler = function () {
        t.onResizeDebounced();
      }),
      Z.bind(window, "resize", this.__resizeHandler),
      Z.bind(this.__ul, "webkitTransitionEnd", this.__resizeHandler),
      Z.bind(this.__ul, "transitionend", this.__resizeHandler),
      Z.bind(this.__ul, "oTransitionEnd", this.__resizeHandler),
      this.onResize(),
      n.resizable && v1(this),
      (s = function () {
        Mo &&
          localStorage.getItem(fa(t, "isLocal")) === "true" &&
          localStorage.setItem(fa(t, "gui"), JSON.stringify(t.getSaveObject()));
      }),
      (this.saveToLocalStorageIfPossible = s);
    function u() {
      var h = t.getRoot();
      (h.width += 1),
        ce.defer(function () {
          h.width -= 1;
        });
    }
    n.parent || u();
  };
_t.toggleHide = function () {
  (Mh = !Mh),
    ce.each(q0, function (r) {
      r.domElement.style.display = Mh ? "none" : "";
    });
};
_t.CLASS_AUTO_PLACE = "a";
_t.CLASS_AUTO_PLACE_CONTAINER = "ac";
_t.CLASS_MAIN = "main";
_t.CLASS_CONTROLLER_ROW = "cr";
_t.CLASS_TOO_TALL = "taller-than-window";
_t.CLASS_CLOSED = "closed";
_t.CLASS_CLOSE_BUTTON = "close-button";
_t.CLASS_CLOSE_TOP = "close-top";
_t.CLASS_CLOSE_BOTTOM = "close-bottom";
_t.CLASS_DRAG = "drag";
_t.DEFAULT_WIDTH = 245;
_t.TEXT_CLOSED = "Close Controls";
_t.TEXT_OPEN = "Open Controls";
_t._keydownHandler = function (r) {
  document.activeElement.type !== "text" &&
    (r.which === h_ || r.keyCode === h_) &&
    _t.toggleHide();
};
Z.bind(window, "keydown", _t._keydownHandler, !1);
ce.extend(_t.prototype, {
  add: function (e, t) {
    return ko(this, e, t, {
      factoryArgs: Array.prototype.slice.call(arguments, 2),
    });
  },
  addColor: function (e, t) {
    return ko(this, e, t, { color: !0 });
  },
  remove: function (e) {
    this.__ul.removeChild(e.__li),
      this.__controllers.splice(this.__controllers.indexOf(e), 1);
    var t = this;
    ce.defer(function () {
      t.onResize();
    });
  },
  destroy: function () {
    if (this.parent)
      throw new Error(
        "Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead."
      );
    this.autoPlace && ha.removeChild(this.domElement);
    var e = this;
    ce.each(this.__folders, function (t) {
      e.removeFolder(t);
    }),
      Z.unbind(window, "keydown", _t._keydownHandler, !1),
      p_(this);
  },
  addFolder: function (e) {
    if (this.__folders[e] !== void 0)
      throw new Error(
        'You already have a folder in this GUI by the name "' + e + '"'
      );
    var t = { name: e, parent: this };
    (t.autoPlace = this.autoPlace),
      this.load &&
        this.load.folders &&
        this.load.folders[e] &&
        ((t.closed = this.load.folders[e].closed),
        (t.load = this.load.folders[e]));
    var n = new _t(t);
    this.__folders[e] = n;
    var i = md(this, n.domElement);
    return Z.addClass(i, "folder"), n;
  },
  removeFolder: function (e) {
    this.__ul.removeChild(e.domElement.parentElement),
      delete this.__folders[e.name],
      this.load &&
        this.load.folders &&
        this.load.folders[e.name] &&
        delete this.load.folders[e.name],
      p_(e);
    var t = this;
    ce.each(e.__folders, function (n) {
      e.removeFolder(n);
    }),
      ce.defer(function () {
        t.onResize();
      });
  },
  open: function () {
    this.closed = !1;
  },
  close: function () {
    this.closed = !0;
  },
  hide: function () {
    this.domElement.style.display = "none";
  },
  show: function () {
    this.domElement.style.display = "";
  },
  onResize: function () {
    var e = this.getRoot();
    if (e.scrollable) {
      var t = Z.getOffset(e.__ul).top,
        n = 0;
      ce.each(e.__ul.childNodes, function (i) {
        (e.autoPlace && i === e.__save_row) || (n += Z.getHeight(i));
      }),
        window.innerHeight - t - f_ < n
          ? (Z.addClass(e.domElement, _t.CLASS_TOO_TALL),
            (e.__ul.style.height = window.innerHeight - t - f_ + "px"))
          : (Z.removeClass(e.domElement, _t.CLASS_TOO_TALL),
            (e.__ul.style.height = "auto"));
    }
    e.__resize_handle &&
      ce.defer(function () {
        e.__resize_handle.style.height = e.__ul.offsetHeight + "px";
      }),
      e.__closeButton && (e.__closeButton.style.width = e.width + "px");
  },
  onResizeDebounced: ce.debounce(function () {
    this.onResize();
  }, 50),
  remember: function () {
    if (
      (ce.isUndefined(Bo) && ((Bo = new p1()), (Bo.domElement.innerHTML = u1)),
      this.parent)
    )
      throw new Error("You can only call remember on a top level GUI.");
    var e = this;
    ce.each(Array.prototype.slice.call(arguments), function (t) {
      e.__rememberedObjects.length === 0 && g1(e),
        e.__rememberedObjects.indexOf(t) === -1 &&
          e.__rememberedObjects.push(t);
    }),
      this.autoPlace && gf(this, this.width);
  },
  getRoot: function () {
    for (var e = this; e.parent; ) e = e.parent;
    return e;
  },
  getSaveObject: function () {
    var e = this.load;
    return (
      (e.closed = this.closed),
      this.__rememberedObjects.length > 0 &&
        ((e.preset = this.preset),
        e.remembered || (e.remembered = {}),
        (e.remembered[this.preset] = fc(this))),
      (e.folders = {}),
      ce.each(this.__folders, function (t, n) {
        e.folders[n] = t.getSaveObject();
      }),
      e
    );
  },
  save: function () {
    this.load.remembered || (this.load.remembered = {}),
      (this.load.remembered[this.preset] = fc(this)),
      mf(this, !1),
      this.saveToLocalStorageIfPossible();
  },
  saveAs: function (e) {
    this.load.remembered ||
      ((this.load.remembered = {}), (this.load.remembered[il] = fc(this, !0))),
      (this.load.remembered[e] = fc(this)),
      (this.preset = e),
      _f(this, e, !0),
      this.saveToLocalStorageIfPossible();
  },
  revert: function (e) {
    ce.each(
      this.__controllers,
      function (t) {
        this.getRoot().load.remembered
          ? j0(e || this.getRoot(), t)
          : t.setValue(t.initialValue),
          t.__onFinishChange && t.__onFinishChange.call(t, t.getValue());
      },
      this
    ),
      ce.each(this.__folders, function (t) {
        t.revert(t);
      }),
      e || mf(this.getRoot(), !1);
  },
  listen: function (e) {
    var t = this.__listening.length === 0;
    this.__listening.push(e), t && K0(this.__listening);
  },
  updateDisplay: function () {
    ce.each(this.__controllers, function (e) {
      e.updateDisplay();
    }),
      ce.each(this.__folders, function (e) {
        e.updateDisplay();
      });
  },
});
function md(r, e, t) {
  var n = document.createElement("li");
  return (
    e && n.appendChild(e),
    t ? r.__ul.insertBefore(n, t) : r.__ul.appendChild(n),
    r.onResize(),
    n
  );
}
function p_(r) {
  Z.unbind(window, "resize", r.__resizeHandler),
    r.saveToLocalStorageIfPossible &&
      Z.unbind(window, "unload", r.saveToLocalStorageIfPossible);
}
function mf(r, e) {
  var t = r.__preset_select[r.__preset_select.selectedIndex];
  e ? (t.innerHTML = t.value + "*") : (t.innerHTML = t.value);
}
function _1(r, e, t) {
  if (
    ((t.__li = e),
    (t.__gui = r),
    ce.extend(t, {
      options: function (a) {
        if (arguments.length > 1) {
          var o = t.__li.nextElementSibling;
          return (
            t.remove(),
            ko(r, t.object, t.property, {
              before: o,
              factoryArgs: [ce.toArray(arguments)],
            })
          );
        }
        if (ce.isArray(a) || ce.isObject(a)) {
          var l = t.__li.nextElementSibling;
          return (
            t.remove(),
            ko(r, t.object, t.property, { before: l, factoryArgs: [a] })
          );
        }
      },
      name: function (a) {
        return (t.__li.firstElementChild.firstElementChild.innerHTML = a), t;
      },
      listen: function () {
        return t.__gui.listen(t), t;
      },
      remove: function () {
        return t.__gui.remove(t), t;
      },
    }),
    t instanceof qc)
  ) {
    var n = new nl(t.object, t.property, {
      min: t.__min,
      max: t.__max,
      step: t.__step,
    });
    ce.each(
      ["updateDisplay", "onChange", "onFinishChange", "step", "min", "max"],
      function (s) {
        var a = t[s],
          o = n[s];
        t[s] = n[s] = function () {
          var l = Array.prototype.slice.call(arguments);
          return o.apply(n, l), a.apply(t, l);
        };
      }
    ),
      Z.addClass(e, "has-slider"),
      t.domElement.insertBefore(n.domElement, t.domElement.firstElementChild);
  } else if (t instanceof nl) {
    var i = function (a) {
      if (ce.isNumber(t.__min) && ce.isNumber(t.__max)) {
        var o = t.__li.firstElementChild.firstElementChild.innerHTML,
          l = t.__gui.__listening.indexOf(t) > -1;
        t.remove();
        var c = ko(r, t.object, t.property, {
          before: t.__li.nextElementSibling,
          factoryArgs: [t.__min, t.__max, t.__step],
        });
        return c.name(o), l && c.listen(), c;
      }
      return a;
    };
    (t.min = ce.compose(i, t.min)), (t.max = ce.compose(i, t.max));
  } else
    t instanceof fd
      ? (Z.bind(e, "click", function () {
          Z.fakeEvent(t.__checkbox, "click");
        }),
        Z.bind(t.__checkbox, "click", function (s) {
          s.stopPropagation();
        }))
      : t instanceof pd
      ? (Z.bind(e, "click", function () {
          Z.fakeEvent(t.__button, "click");
        }),
        Z.bind(e, "mouseover", function () {
          Z.addClass(t.__button, "hover");
        }),
        Z.bind(e, "mouseout", function () {
          Z.removeClass(t.__button, "hover");
        }))
      : t instanceof jc &&
        (Z.addClass(e, "color"),
        (t.updateDisplay = ce.compose(function (s) {
          return (e.style.borderLeftColor = t.__color.toString()), s;
        }, t.updateDisplay)),
        t.updateDisplay());
  t.setValue = ce.compose(function (s) {
    return (
      r.getRoot().__preset_select && t.isModified() && mf(r.getRoot(), !0), s
    );
  }, t.setValue);
}
function j0(r, e) {
  var t = r.getRoot(),
    n = t.__rememberedObjects.indexOf(e.object);
  if (n !== -1) {
    var i = t.__rememberedObjectIndecesToControllers[n];
    if (
      (i === void 0 &&
        ((i = {}), (t.__rememberedObjectIndecesToControllers[n] = i)),
      (i[e.property] = e),
      t.load && t.load.remembered)
    ) {
      var s = t.load.remembered,
        a = void 0;
      if (s[r.preset]) a = s[r.preset];
      else if (s[il]) a = s[il];
      else return;
      if (a[n] && a[n][e.property] !== void 0) {
        var o = a[n][e.property];
        (e.initialValue = o), e.setValue(o);
      }
    }
  }
}
function ko(r, e, t, n) {
  if (e[t] === void 0)
    throw new Error('Object "' + e + '" has no property "' + t + '"');
  var i = void 0;
  if (n.color) i = new jc(e, t);
  else {
    var s = [e, t].concat(n.factoryArgs);
    i = h1.apply(r, s);
  }
  n.before instanceof Wr && (n.before = n.before.__li),
    j0(r, i),
    Z.addClass(i.domElement, "c");
  var a = document.createElement("span");
  Z.addClass(a, "property-name"), (a.innerHTML = i.property);
  var o = document.createElement("div");
  o.appendChild(a), o.appendChild(i.domElement);
  var l = md(r, o, n.before);
  return (
    Z.addClass(l, _t.CLASS_CONTROLLER_ROW),
    i instanceof jc ? Z.addClass(l, "color") : Z.addClass(l, i1(i.getValue())),
    _1(r, l, i),
    r.__controllers.push(i),
    i
  );
}
function fa(r, e) {
  return document.location.href + "." + e;
}
function _f(r, e, t) {
  var n = document.createElement("option");
  (n.innerHTML = e),
    (n.value = e),
    r.__preset_select.appendChild(n),
    t && (r.__preset_select.selectedIndex = r.__preset_select.length - 1);
}
function m_(r, e) {
  e.style.display = r.useLocalStorage ? "block" : "none";
}
function g1(r) {
  var e = (r.__save_row = document.createElement("li"));
  Z.addClass(r.domElement, "has-save"),
    r.__ul.insertBefore(e, r.__ul.firstChild),
    Z.addClass(e, "save-row");
  var t = document.createElement("span");
  (t.innerHTML = "&nbsp;"), Z.addClass(t, "button gears");
  var n = document.createElement("span");
  (n.innerHTML = "Save"), Z.addClass(n, "button"), Z.addClass(n, "save");
  var i = document.createElement("span");
  (i.innerHTML = "New"), Z.addClass(i, "button"), Z.addClass(i, "save-as");
  var s = document.createElement("span");
  (s.innerHTML = "Revert"), Z.addClass(s, "button"), Z.addClass(s, "revert");
  var a = (r.__preset_select = document.createElement("select"));
  if (
    (r.load && r.load.remembered
      ? ce.each(r.load.remembered, function (h, f) {
          _f(r, f, f === r.preset);
        })
      : _f(r, il, !1),
    Z.bind(a, "change", function () {
      for (var h = 0; h < r.__preset_select.length; h++)
        r.__preset_select[h].innerHTML = r.__preset_select[h].value;
      r.preset = this.value;
    }),
    e.appendChild(a),
    e.appendChild(t),
    e.appendChild(n),
    e.appendChild(i),
    e.appendChild(s),
    Mo)
  ) {
    var o = document.getElementById("dg-local-explain"),
      l = document.getElementById("dg-local-storage"),
      c = document.getElementById("dg-save-locally");
    (c.style.display = "block"),
      localStorage.getItem(fa(r, "isLocal")) === "true" &&
        l.setAttribute("checked", "checked"),
      m_(r, o),
      Z.bind(l, "change", function () {
        (r.useLocalStorage = !r.useLocalStorage), m_(r, o);
      });
  }
  var u = document.getElementById("dg-new-constructor");
  Z.bind(u, "keydown", function (h) {
    h.metaKey && (h.which === 67 || h.keyCode === 67) && Bo.hide();
  }),
    Z.bind(t, "click", function () {
      (u.innerHTML = JSON.stringify(r.getSaveObject(), void 0, 2)),
        Bo.show(),
        u.focus(),
        u.select();
    }),
    Z.bind(n, "click", function () {
      r.save();
    }),
    Z.bind(i, "click", function () {
      var h = prompt("Enter a new preset name.");
      h && r.saveAs(h);
    }),
    Z.bind(s, "click", function () {
      r.revert();
    });
}
function v1(r) {
  var e = void 0;
  (r.__resize_handle = document.createElement("div")),
    ce.extend(r.__resize_handle.style, {
      width: "6px",
      marginLeft: "-3px",
      height: "200px",
      cursor: "ew-resize",
      position: "absolute",
    });
  function t(s) {
    return (
      s.preventDefault(),
      (r.width += e - s.clientX),
      r.onResize(),
      (e = s.clientX),
      !1
    );
  }
  function n() {
    Z.removeClass(r.__closeButton, _t.CLASS_DRAG),
      Z.unbind(window, "mousemove", t),
      Z.unbind(window, "mouseup", n);
  }
  function i(s) {
    return (
      s.preventDefault(),
      (e = s.clientX),
      Z.addClass(r.__closeButton, _t.CLASS_DRAG),
      Z.bind(window, "mousemove", t),
      Z.bind(window, "mouseup", n),
      !1
    );
  }
  Z.bind(r.__resize_handle, "mousedown", i),
    Z.bind(r.__closeButton, "mousedown", i),
    r.domElement.insertBefore(
      r.__resize_handle,
      r.domElement.firstElementChild
    );
}
function gf(r, e) {
  (r.domElement.style.width = e + "px"),
    r.__save_row && r.autoPlace && (r.__save_row.style.width = e + "px"),
    r.__closeButton && (r.__closeButton.style.width = e + "px");
}
function fc(r, e) {
  var t = {};
  return (
    ce.each(r.__rememberedObjects, function (n, i) {
      var s = {},
        a = r.__rememberedObjectIndecesToControllers[i];
      ce.each(a, function (o, l) {
        s[l] = e ? o.initialValue : o.getValue();
      }),
        (t[i] = s);
    }),
    t
  );
}
function x1(r) {
  for (var e = 0; e < r.__preset_select.length; e++)
    r.__preset_select[e].value === r.preset &&
      (r.__preset_select.selectedIndex = e);
}
function K0(r) {
  r.length !== 0 &&
    d1.call(window, function () {
      K0(r);
    }),
    ce.each(r, function (e) {
      e.updateDisplay();
    });
}
var y1 = { Color: zt, math: tl, interpret: Yc },
  E1 = {
    Controller: Wr,
    BooleanController: fd,
    OptionController: X0,
    StringController: Y0,
    NumberController: dd,
    NumberControllerBox: nl,
    NumberControllerSlider: qc,
    FunctionController: pd,
    ColorController: jc,
  },
  S1 = { dom: Z },
  M1 = { GUI: _t },
  b1 = _t,
  T1 = { color: y1, controllers: E1, dom: S1, gui: M1, GUI: b1 },
  nu,
  $0,
  iu,
  Z0,
  ru,
  J0;
class A1 {
  constructor(e) {
    Us(this, nu);
    Us(this, iu);
    Us(this, ru);
    In(this, "objects", []);
    In(this, "material", null);
    In(this, "geometry", null);
    In(this, "cloud", null);
    In(this, "debugger", null);
    (this.objects = e),
      (this.geometry = new xi()),
      (this.material = Fs(this, iu, Z0).call(this)),
      Fs(this, nu, $0).call(this),
      (this.cloud = new hg(this.geometry, this.material)),
      Fs(this, ru, J0).call(this);
  }
  showDebugger() {
    this.debugger.show();
  }
  hideDebugger() {
    this.debugger.hide();
  }
}
(nu = new WeakSet()),
  ($0 = function () {
    this.objects.forEach((e, t) => {
      if (!t) {
        this.geometry.setAttribute("position", e.position),
          this.geometry.setAttribute("normal", e.normal),
          this.geometry.setAttribute("aRand", e.randomPosition),
          this.geometry.setAttribute("aColor", e.color);
        return;
      }
      this.geometry.setAttribute(`normal${t + 1}`, e.normal),
        this.geometry.setAttribute(`position${t + 1}`, e.position),
        (this.material.uniforms[`uMorph${t + 1}`] = { value: 0 });
    });
  }),
  (iu = new WeakSet()),
  (Z0 = function () {
    return new Ir({
      extensions: {
        derivatives: "#extension GL_OES_standard_derivatives: enable",
      },
      depthWrite: !1,
      vertexShader: e1,
      fragmentShader: Qw,
      uniforms: {
        uSize: { value: 45 },
        uTexture: { value: new _g().load("/triangle.png") },
        uColor: { value: new H(1, 0, 0) },
        uDestruction: { value: 0 },
        uPoint: { value: { x: 0, y: 0, z: 0 } },
        uTouch: { value: null },
        uTime: { value: 0 },
      },
      depthTest: !1,
      transparent: !0,
    });
  }),
  (ru = new WeakSet()),
  (J0 = function () {
    this.debugger = new T1.GUI();
    for (let e = 2; e <= this.objects.length; e++)
      this.debugger
        .add(this.material.uniforms[`uMorph${e}`], "value")
        .max(1)
        .min(0)
        .step(0.01)
        .name(`Morph${e}`);
    this.debugger
      .add(this.material.uniforms.uDestruction, "value")
      .max(1)
      .min(0)
      .step(0.01)
      .name("Destruction"),
      this.debugger.hide();
  });
function __(r, e) {
  for (var t = 0; t < e.length; t++) {
    var n = e[t];
    (n.enumerable = n.enumerable || !1),
      (n.configurable = !0),
      "value" in n && (n.writable = !0),
      Object.defineProperty(r, n.key, n);
  }
}
function w1(r, e, t) {
  return (
    e && __(r.prototype, e),
    t && __(r, t),
    Object.defineProperty(r, "prototype", { writable: !1 }),
    r
  );
}
/*!
 * Splide.js
 * Version  : 4.1.4
 * License  : MIT
 * Copyright: 2022 Naotoshi Fujita
 */ var g_ = "(prefers-reduced-motion: reduce)",
  Ea = 1,
  R1 = 2,
  qa = 3,
  Ja = 4,
  vl = 5,
  wc = 6,
  Kc = 7,
  C1 = {
    CREATED: Ea,
    MOUNTED: R1,
    IDLE: qa,
    MOVING: Ja,
    SCROLLING: vl,
    DRAGGING: wc,
    DESTROYED: Kc,
  };
function ur(r) {
  r.length = 0;
}
function Xr(r, e, t) {
  return Array.prototype.slice.call(r, e, t);
}
function gt(r) {
  return r.bind.apply(r, [null].concat(Xr(arguments, 1)));
}
var Q0 = setTimeout,
  vf = function () {};
function v_(r) {
  return requestAnimationFrame(r);
}
function mu(r, e) {
  return typeof e === r;
}
function rl(r) {
  return !gd(r) && mu("object", r);
}
var _d = Array.isArray,
  ev = gt(mu, "function"),
  Br = gt(mu, "string"),
  xl = gt(mu, "undefined");
function gd(r) {
  return r === null;
}
function tv(r) {
  try {
    return r instanceof (r.ownerDocument.defaultView || window).HTMLElement;
  } catch {
    return !1;
  }
}
function yl(r) {
  return _d(r) ? r : [r];
}
function oi(r, e) {
  yl(r).forEach(e);
}
function vd(r, e) {
  return r.indexOf(e) > -1;
}
function Rc(r, e) {
  return r.push.apply(r, yl(e)), r;
}
function nr(r, e, t) {
  r &&
    oi(e, function (n) {
      n && r.classList[t ? "add" : "remove"](n);
    });
}
function Fi(r, e) {
  nr(r, Br(e) ? e.split(" ") : e, !0);
}
function El(r, e) {
  oi(e, r.appendChild.bind(r));
}
function xd(r, e) {
  oi(r, function (t) {
    var n = (e || t).parentNode;
    n && n.insertBefore(t, e);
  });
}
function sl(r, e) {
  return tv(r) && (r.msMatchesSelector || r.matches).call(r, e);
}
function nv(r, e) {
  var t = r ? Xr(r.children) : [];
  return e
    ? t.filter(function (n) {
        return sl(n, e);
      })
    : t;
}
function Sl(r, e) {
  return e ? nv(r, e)[0] : r.firstElementChild;
}
var al = Object.keys;
function Es(r, e, t) {
  return (
    r &&
      (t ? al(r).reverse() : al(r)).forEach(function (n) {
        n !== "__proto__" && e(r[n], n);
      }),
    r
  );
}
function ol(r) {
  return (
    Xr(arguments, 1).forEach(function (e) {
      Es(e, function (t, n) {
        r[n] = e[n];
      });
    }),
    r
  );
}
function Rr(r) {
  return (
    Xr(arguments, 1).forEach(function (e) {
      Es(e, function (t, n) {
        _d(t)
          ? (r[n] = t.slice())
          : rl(t)
          ? (r[n] = Rr({}, rl(r[n]) ? r[n] : {}, t))
          : (r[n] = t);
      });
    }),
    r
  );
}
function x_(r, e) {
  oi(e || al(r), function (t) {
    delete r[t];
  });
}
function Bi(r, e) {
  oi(r, function (t) {
    oi(e, function (n) {
      t && t.removeAttribute(n);
    });
  });
}
function Ye(r, e, t) {
  rl(e)
    ? Es(e, function (n, i) {
        Ye(r, i, n);
      })
    : oi(r, function (n) {
        gd(t) || t === "" ? Bi(n, e) : n.setAttribute(e, String(t));
      });
}
function La(r, e, t) {
  var n = document.createElement(r);
  return e && (Br(e) ? Fi(n, e) : Ye(n, e)), t && El(t, n), n;
}
function mi(r, e, t) {
  if (xl(t)) return getComputedStyle(r)[e];
  gd(t) || (r.style[e] = "" + t);
}
function ll(r, e) {
  mi(r, "display", e);
}
function iv(r) {
  (r.setActive && r.setActive()) || r.focus({ preventScroll: !0 });
}
function _i(r, e) {
  return r.getAttribute(e);
}
function y_(r, e) {
  return r && r.classList.contains(e);
}
function Zn(r) {
  return r.getBoundingClientRect();
}
function Ps(r) {
  oi(r, function (e) {
    e && e.parentNode && e.parentNode.removeChild(e);
  });
}
function rv(r) {
  return Sl(new DOMParser().parseFromString(r, "text/html").body);
}
function Zi(r, e) {
  r.preventDefault(), e && (r.stopPropagation(), r.stopImmediatePropagation());
}
function sv(r, e) {
  return r && r.querySelector(e);
}
function yd(r, e) {
  return e ? Xr(r.querySelectorAll(e)) : [];
}
function ir(r, e) {
  nr(r, e, !1);
}
function xf(r) {
  return r.timeStamp;
}
function es(r) {
  return Br(r) ? r : r ? r + "px" : "";
}
var Ml = "splide",
  Ed = "data-" + Ml;
function zo(r, e) {
  if (!r) throw new Error("[" + Ml + "] " + (e || ""));
}
var kr = Math.min,
  $c = Math.max,
  Zc = Math.floor,
  cl = Math.ceil,
  Mn = Math.abs;
function av(r, e, t) {
  return Mn(r - e) < t;
}
function Cc(r, e, t, n) {
  var i = kr(e, t),
    s = $c(e, t);
  return n ? i < r && r < s : i <= r && r <= s;
}
function da(r, e, t) {
  var n = kr(e, t),
    i = $c(e, t);
  return kr($c(n, r), i);
}
function yf(r) {
  return +(r > 0) - +(r < 0);
}
function Ef(r, e) {
  return (
    oi(e, function (t) {
      r = r.replace("%s", "" + t);
    }),
    r
  );
}
function Sd(r) {
  return r < 10 ? "0" + r : "" + r;
}
var E_ = {};
function P1(r) {
  return "" + r + Sd((E_[r] = (E_[r] || 0) + 1));
}
function ov() {
  var r = [];
  function e(a, o, l, c) {
    i(a, o, function (u, h, f) {
      var p = "addEventListener" in u,
        g = p
          ? u.removeEventListener.bind(u, h, l, c)
          : u.removeListener.bind(u, l);
      p ? u.addEventListener(h, l, c) : u.addListener(l),
        r.push([u, h, f, l, g]);
    });
  }
  function t(a, o, l) {
    i(a, o, function (c, u, h) {
      r = r.filter(function (f) {
        return f[0] === c && f[1] === u && f[2] === h && (!l || f[3] === l)
          ? (f[4](), !1)
          : !0;
      });
    });
  }
  function n(a, o, l) {
    var c,
      u = !0;
    return (
      typeof CustomEvent == "function"
        ? (c = new CustomEvent(o, { bubbles: u, detail: l }))
        : ((c = document.createEvent("CustomEvent")),
          c.initCustomEvent(o, u, !1, l)),
      a.dispatchEvent(c),
      c
    );
  }
  function i(a, o, l) {
    oi(a, function (c) {
      c &&
        oi(o, function (u) {
          u.split(" ").forEach(function (h) {
            var f = h.split(".");
            l(c, f[0], f[1]);
          });
        });
    });
  }
  function s() {
    r.forEach(function (a) {
      a[4]();
    }),
      ur(r);
  }
  return { bind: e, unbind: t, dispatch: n, destroy: s };
}
var Os = "mounted",
  S_ = "ready",
  zr = "move",
  bl = "moved",
  lv = "click",
  L1 = "active",
  D1 = "inactive",
  I1 = "visible",
  N1 = "hidden",
  kt = "refresh",
  Cn = "updated",
  ul = "resize",
  Md = "resized",
  O1 = "drag",
  U1 = "dragging",
  F1 = "dragged",
  bd = "scroll",
  Qa = "scrolled",
  B1 = "overflow",
  cv = "destroy",
  k1 = "arrows:mounted",
  z1 = "arrows:updated",
  H1 = "pagination:mounted",
  V1 = "pagination:updated",
  uv = "navigation:mounted",
  hv = "autoplay:play",
  G1 = "autoplay:playing",
  fv = "autoplay:pause",
  dv = "lazyload:loaded",
  pv = "sk",
  mv = "sh",
  Jc = "ei";
function At(r) {
  var e = r ? r.event.bus : document.createDocumentFragment(),
    t = ov();
  function n(s, a) {
    t.bind(e, yl(s).join(" "), function (o) {
      a.apply(a, _d(o.detail) ? o.detail : []);
    });
  }
  function i(s) {
    t.dispatch(e, s, Xr(arguments, 1));
  }
  return (
    r && r.event.on(cv, t.destroy),
    ol(t, { bus: e, on: n, off: gt(t.unbind, e), emit: i })
  );
}
function _u(r, e, t, n) {
  var i = Date.now,
    s,
    a = 0,
    o,
    l = !0,
    c = 0;
  function u() {
    if (!l) {
      if (
        ((a = r ? kr((i() - s) / r, 1) : 1),
        t && t(a),
        a >= 1 && (e(), (s = i()), n && ++c >= n))
      )
        return f();
      o = v_(u);
    }
  }
  function h(d) {
    d || g(), (s = i() - (d ? a * r : 0)), (l = !1), (o = v_(u));
  }
  function f() {
    l = !0;
  }
  function p() {
    (s = i()), (a = 0), t && t(a);
  }
  function g() {
    o && cancelAnimationFrame(o), (a = 0), (o = 0), (l = !0);
  }
  function m(d) {
    r = d;
  }
  function _() {
    return l;
  }
  return { start: h, rewind: p, pause: f, cancel: g, set: m, isPaused: _ };
}
function W1(r) {
  var e = r;
  function t(i) {
    e = i;
  }
  function n(i) {
    return vd(yl(i), e);
  }
  return { set: t, is: n };
}
function X1(r, e) {
  var t = _u(e || 0, r, null, 1);
  return function () {
    t.isPaused() && t.start();
  };
}
function Y1(r, e, t) {
  var n = r.state,
    i = t.breakpoints || {},
    s = t.reducedMotion || {},
    a = ov(),
    o = [];
  function l() {
    var g = t.mediaQuery === "min";
    al(i)
      .sort(function (m, _) {
        return g ? +m - +_ : +_ - +m;
      })
      .forEach(function (m) {
        u(i[m], "(" + (g ? "min" : "max") + "-width:" + m + "px)");
      }),
      u(s, g_),
      h();
  }
  function c(g) {
    g && a.destroy();
  }
  function u(g, m) {
    var _ = matchMedia(m);
    a.bind(_, "change", h), o.push([g, _]);
  }
  function h() {
    var g = n.is(Kc),
      m = t.direction,
      _ = o.reduce(function (d, y) {
        return Rr(d, y[1].matches ? y[0] : {});
      }, {});
    x_(t),
      p(_),
      t.destroy
        ? r.destroy(t.destroy === "completely")
        : g
        ? (c(!0), r.mount())
        : m !== t.direction && r.refresh();
  }
  function f(g) {
    matchMedia(g_).matches && (g ? Rr(t, s) : x_(t, al(s)));
  }
  function p(g, m, _) {
    Rr(t, g),
      m && Rr(Object.getPrototypeOf(t), g),
      (_ || !n.is(Ea)) && r.emit(Cn, t);
  }
  return { setup: l, destroy: c, reduce: f, set: p };
}
var gu = "Arrow",
  vu = gu + "Left",
  xu = gu + "Right",
  _v = gu + "Up",
  gv = gu + "Down",
  M_ = "rtl",
  yu = "ttb",
  bh = {
    width: ["height"],
    left: ["top", "right"],
    right: ["bottom", "left"],
    x: ["y"],
    X: ["Y"],
    Y: ["X"],
    ArrowLeft: [_v, xu],
    ArrowRight: [gv, vu],
  };
function q1(r, e, t) {
  function n(s, a, o) {
    o = o || t.direction;
    var l = o === M_ && !a ? 1 : o === yu ? 0 : -1;
    return (
      (bh[s] && bh[s][l]) ||
      s.replace(/width|left|right/i, function (c, u) {
        var h = bh[c.toLowerCase()][l] || c;
        return u > 0 ? h.charAt(0).toUpperCase() + h.slice(1) : h;
      })
    );
  }
  function i(s) {
    return s * (t.direction === M_ ? 1 : -1);
  }
  return { resolve: n, orient: i };
}
var ar = "role",
  Da = "tabindex",
  j1 = "disabled",
  Si = "aria-",
  Tl = Si + "controls",
  vv = Si + "current",
  b_ = Si + "selected",
  ri = Si + "label",
  Td = Si + "labelledby",
  xv = Si + "hidden",
  Ad = Si + "orientation",
  hl = Si + "roledescription",
  T_ = Si + "live",
  A_ = Si + "busy",
  w_ = Si + "atomic",
  wd = [ar, Da, j1, Tl, vv, ri, Td, xv, Ad, hl],
  zi = Ml + "__",
  Yr = "is-",
  Th = Ml,
  R_ = zi + "track",
  K1 = zi + "list",
  Eu = zi + "slide",
  yv = Eu + "--clone",
  $1 = Eu + "__container",
  Rd = zi + "arrows",
  Su = zi + "arrow",
  Ev = Su + "--prev",
  Sv = Su + "--next",
  Mu = zi + "pagination",
  Mv = Mu + "__page",
  Z1 = zi + "progress",
  J1 = Z1 + "__bar",
  Q1 = zi + "toggle",
  eR = zi + "spinner",
  tR = zi + "sr",
  nR = Yr + "initialized",
  Ls = Yr + "active",
  bv = Yr + "prev",
  Tv = Yr + "next",
  Sf = Yr + "visible",
  Mf = Yr + "loading",
  Av = Yr + "focus-in",
  wv = Yr + "overflow",
  iR = [Ls, Sf, bv, Tv, Mf, Av, wv],
  rR = {
    slide: Eu,
    clone: yv,
    arrows: Rd,
    arrow: Su,
    prev: Ev,
    next: Sv,
    pagination: Mu,
    page: Mv,
    spinner: eR,
  };
function sR(r, e) {
  if (ev(r.closest)) return r.closest(e);
  for (var t = r; t && t.nodeType === 1 && !sl(t, e); ) t = t.parentElement;
  return t;
}
var aR = 5,
  C_ = 200,
  Rv = "touchstart mousedown",
  Ah = "touchmove mousemove",
  wh = "touchend touchcancel mouseup click";
function oR(r, e, t) {
  var n = At(r),
    i = n.on,
    s = n.bind,
    a = r.root,
    o = t.i18n,
    l = {},
    c = [],
    u = [],
    h = [],
    f,
    p,
    g;
  function m() {
    v(), S(), y();
  }
  function _() {
    i(kt, d),
      i(kt, m),
      i(Cn, y),
      s(
        document,
        Rv + " keydown",
        function (M) {
          g = M.type === "keydown";
        },
        { capture: !0 }
      ),
      s(a, "focusin", function () {
        nr(a, Av, !!g);
      });
  }
  function d(M) {
    var C = wd.concat("style");
    ur(c), ir(a, u), ir(f, h), Bi([f, p], C), Bi(a, M ? C : ["style", hl]);
  }
  function y() {
    ir(a, u),
      ir(f, h),
      (u = b(Th)),
      (h = b(R_)),
      Fi(a, u),
      Fi(f, h),
      Ye(a, ri, t.label),
      Ye(a, Td, t.labelledby);
  }
  function v() {
    (f = E("." + R_)),
      (p = Sl(f, "." + K1)),
      zo(f && p, "A track/list element is missing."),
      Rc(c, nv(p, "." + Eu + ":not(." + yv + ")")),
      Es(
        { arrows: Rd, pagination: Mu, prev: Ev, next: Sv, bar: J1, toggle: Q1 },
        function (M, C) {
          l[C] = E("." + M);
        }
      ),
      ol(l, { root: a, track: f, list: p, slides: c });
  }
  function S() {
    var M = a.id || P1(Ml),
      C = t.role;
    (a.id = M),
      (f.id = f.id || M + "-track"),
      (p.id = p.id || M + "-list"),
      !_i(a, ar) && a.tagName !== "SECTION" && C && Ye(a, ar, C),
      Ye(a, hl, o.carousel),
      Ye(p, ar, "presentation");
  }
  function E(M) {
    var C = sv(a, M);
    return C && sR(C, "." + Th) === a ? C : void 0;
  }
  function b(M) {
    return [
      M + "--" + t.type,
      M + "--" + t.direction,
      t.drag && M + "--draggable",
      t.isNavigation && M + "--nav",
      M === Th && Ls,
    ];
  }
  return ol(l, { setup: m, mount: _, destroy: d });
}
var ja = "slide",
  eo = "loop",
  Al = "fade";
function lR(r, e, t, n) {
  var i = At(r),
    s = i.on,
    a = i.emit,
    o = i.bind,
    l = r.Components,
    c = r.root,
    u = r.options,
    h = u.isNavigation,
    f = u.updateOnMove,
    p = u.i18n,
    g = u.pagination,
    m = u.slideFocus,
    _ = l.Direction.resolve,
    d = _i(n, "style"),
    y = _i(n, ri),
    v = t > -1,
    S = Sl(n, "." + $1),
    E;
  function b() {
    v ||
      ((n.id = c.id + "-slide" + Sd(e + 1)),
      Ye(n, ar, g ? "tabpanel" : "group"),
      Ye(n, hl, p.slide),
      Ye(n, ri, y || Ef(p.slideLabel, [e + 1, r.length]))),
      M();
  }
  function M() {
    o(n, "click", gt(a, lv, k)),
      o(n, "keydown", gt(a, pv, k)),
      s([bl, mv, Qa], D),
      s(uv, x),
      f && s(zr, T);
  }
  function C() {
    (E = !0),
      i.destroy(),
      ir(n, iR),
      Bi(n, wd),
      Ye(n, "style", d),
      Ye(n, ri, y || "");
  }
  function x() {
    var G = r.splides
      .map(function (z) {
        var oe = z.splide.Components.Slides.getAt(e);
        return oe ? oe.slide.id : "";
      })
      .join(" ");
    Ye(n, ri, Ef(p.slideX, (v ? t : e) + 1)),
      Ye(n, Tl, G),
      Ye(n, ar, m ? "button" : ""),
      m && Bi(n, hl);
  }
  function T() {
    E || D();
  }
  function D() {
    if (!E) {
      var G = r.index;
      N(), L(), nr(n, bv, e === G - 1), nr(n, Tv, e === G + 1);
    }
  }
  function N() {
    var G = I();
    G !== y_(n, Ls) &&
      (nr(n, Ls, G), Ye(n, vv, (h && G) || ""), a(G ? L1 : D1, k));
  }
  function L() {
    var G = j(),
      z = !G && (!I() || v);
    if (
      (r.state.is([Ja, vl]) || Ye(n, xv, z || ""),
      Ye(yd(n, u.focusableNodes || ""), Da, z ? -1 : ""),
      m && Ye(n, Da, z ? -1 : 0),
      G !== y_(n, Sf) && (nr(n, Sf, G), a(G ? I1 : N1, k)),
      !G && document.activeElement === n)
    ) {
      var oe = l.Slides.getAt(r.index);
      oe && iv(oe.slide);
    }
  }
  function F(G, z, oe) {
    mi((oe && S) || n, G, z);
  }
  function I() {
    var G = r.index;
    return G === e || (u.cloneStatus && G === t);
  }
  function j() {
    if (r.is(Al)) return I();
    var G = Zn(l.Elements.track),
      z = Zn(n),
      oe = _("left", !0),
      te = _("right", !0);
    return Zc(G[oe]) <= cl(z[oe]) && Zc(z[te]) <= cl(G[te]);
  }
  function A(G, z) {
    var oe = Mn(G - e);
    return (
      !v && (u.rewind || r.is(eo)) && (oe = kr(oe, r.length - oe)), oe <= z
    );
  }
  var k = {
    index: e,
    slideIndex: t,
    slide: n,
    container: S,
    isClone: v,
    mount: b,
    destroy: C,
    update: D,
    style: F,
    isWithin: A,
  };
  return k;
}
function cR(r, e, t) {
  var n = At(r),
    i = n.on,
    s = n.emit,
    a = n.bind,
    o = e.Elements,
    l = o.slides,
    c = o.list,
    u = [];
  function h() {
    f(), i(kt, p), i(kt, f);
  }
  function f() {
    l.forEach(function (D, N) {
      m(D, N, -1);
    });
  }
  function p() {
    E(function (D) {
      D.destroy();
    }),
      ur(u);
  }
  function g() {
    E(function (D) {
      D.update();
    });
  }
  function m(D, N, L) {
    var F = lR(r, N, L, D);
    F.mount(),
      u.push(F),
      u.sort(function (I, j) {
        return I.index - j.index;
      });
  }
  function _(D) {
    return D
      ? b(function (N) {
          return !N.isClone;
        })
      : u;
  }
  function d(D) {
    var N = e.Controller,
      L = N.toIndex(D),
      F = N.hasFocus() ? 1 : t.perPage;
    return b(function (I) {
      return Cc(I.index, L, L + F - 1);
    });
  }
  function y(D) {
    return b(D)[0];
  }
  function v(D, N) {
    oi(D, function (L) {
      if ((Br(L) && (L = rv(L)), tv(L))) {
        var F = l[N];
        F ? xd(L, F) : El(c, L), Fi(L, t.classes.slide), C(L, gt(s, ul));
      }
    }),
      s(kt);
  }
  function S(D) {
    Ps(
      b(D).map(function (N) {
        return N.slide;
      })
    ),
      s(kt);
  }
  function E(D, N) {
    _(N).forEach(D);
  }
  function b(D) {
    return u.filter(
      ev(D)
        ? D
        : function (N) {
            return Br(D) ? sl(N.slide, D) : vd(yl(D), N.index);
          }
    );
  }
  function M(D, N, L) {
    E(function (F) {
      F.style(D, N, L);
    });
  }
  function C(D, N) {
    var L = yd(D, "img"),
      F = L.length;
    F
      ? L.forEach(function (I) {
          a(I, "load error", function () {
            --F || N();
          });
        })
      : N();
  }
  function x(D) {
    return D ? l.length : u.length;
  }
  function T() {
    return u.length > t.perPage;
  }
  return {
    mount: h,
    destroy: p,
    update: g,
    register: m,
    get: _,
    getIn: d,
    getAt: y,
    add: v,
    remove: S,
    forEach: E,
    filter: b,
    style: M,
    getLength: x,
    isEnough: T,
  };
}
function uR(r, e, t) {
  var n = At(r),
    i = n.on,
    s = n.bind,
    a = n.emit,
    o = e.Slides,
    l = e.Direction.resolve,
    c = e.Elements,
    u = c.root,
    h = c.track,
    f = c.list,
    p = o.getAt,
    g = o.style,
    m,
    _,
    d;
  function y() {
    v(), s(window, "resize load", X1(gt(a, ul))), i([Cn, kt], v), i(ul, S);
  }
  function v() {
    (m = t.direction === yu),
      mi(u, "maxWidth", es(t.width)),
      mi(h, l("paddingLeft"), E(!1)),
      mi(h, l("paddingRight"), E(!0)),
      S(!0);
  }
  function S(k) {
    var G = Zn(u);
    (k || _.width !== G.width || _.height !== G.height) &&
      (mi(h, "height", b()),
      g(l("marginRight"), es(t.gap)),
      g("width", C()),
      g("height", x(), !0),
      (_ = G),
      a(Md),
      d !== (d = A()) && (nr(u, wv, d), a(B1, d)));
  }
  function E(k) {
    var G = t.padding,
      z = l(k ? "right" : "left");
    return (G && es(G[z] || (rl(G) ? 0 : G))) || "0px";
  }
  function b() {
    var k = "";
    return (
      m &&
        ((k = M()),
        zo(k, "height or heightRatio is missing."),
        (k = "calc(" + k + " - " + E(!1) + " - " + E(!0) + ")")),
      k
    );
  }
  function M() {
    return es(t.height || Zn(f).width * t.heightRatio);
  }
  function C() {
    return t.autoWidth ? null : es(t.fixedWidth) || (m ? "" : T());
  }
  function x() {
    return es(t.fixedHeight) || (m ? (t.autoHeight ? null : T()) : M());
  }
  function T() {
    var k = es(t.gap);
    return (
      "calc((100%" +
      (k && " + " + k) +
      ")/" +
      (t.perPage || 1) +
      (k && " - " + k) +
      ")"
    );
  }
  function D() {
    return Zn(f)[l("width")];
  }
  function N(k, G) {
    var z = p(k || 0);
    return z ? Zn(z.slide)[l("width")] + (G ? 0 : I()) : 0;
  }
  function L(k, G) {
    var z = p(k);
    if (z) {
      var oe = Zn(z.slide)[l("right")],
        te = Zn(f)[l("left")];
      return Mn(oe - te) + (G ? 0 : I());
    }
    return 0;
  }
  function F(k) {
    return L(r.length - 1) - L(0) + N(0, k);
  }
  function I() {
    var k = p(0);
    return (k && parseFloat(mi(k.slide, l("marginRight")))) || 0;
  }
  function j(k) {
    return parseFloat(mi(h, l("padding" + (k ? "Right" : "Left")))) || 0;
  }
  function A() {
    return r.is(Al) || F(!0) > D();
  }
  return {
    mount: y,
    resize: S,
    listSize: D,
    slideSize: N,
    sliderSize: F,
    totalSize: L,
    getPadding: j,
    isOverflow: A,
  };
}
var hR = 2;
function fR(r, e, t) {
  var n = At(r),
    i = n.on,
    s = e.Elements,
    a = e.Slides,
    o = e.Direction.resolve,
    l = [],
    c;
  function u() {
    i(kt, h), i([Cn, ul], p), (c = _()) && (g(c), e.Layout.resize(!0));
  }
  function h() {
    f(), u();
  }
  function f() {
    Ps(l), ur(l), n.destroy();
  }
  function p() {
    var d = _();
    c !== d && (c < d || !d) && n.emit(kt);
  }
  function g(d) {
    var y = a.get().slice(),
      v = y.length;
    if (v) {
      for (; y.length < d; ) Rc(y, y);
      Rc(y.slice(-d), y.slice(0, d)).forEach(function (S, E) {
        var b = E < d,
          M = m(S.slide, E);
        b ? xd(M, y[0].slide) : El(s.list, M),
          Rc(l, M),
          a.register(M, E - d + (b ? 0 : v), S.index);
      });
    }
  }
  function m(d, y) {
    var v = d.cloneNode(!0);
    return Fi(v, t.classes.clone), (v.id = r.root.id + "-clone" + Sd(y + 1)), v;
  }
  function _() {
    var d = t.clones;
    if (!r.is(eo)) d = 0;
    else if (xl(d)) {
      var y = t[o("fixedWidth")] && e.Layout.slideSize(0),
        v = y && cl(Zn(s.track)[o("width")] / y);
      d = v || (t[o("autoWidth")] && r.length) || t.perPage * hR;
    }
    return d;
  }
  return { mount: u, destroy: f };
}
function dR(r, e, t) {
  var n = At(r),
    i = n.on,
    s = n.emit,
    a = r.state.set,
    o = e.Layout,
    l = o.slideSize,
    c = o.getPadding,
    u = o.totalSize,
    h = o.listSize,
    f = o.sliderSize,
    p = e.Direction,
    g = p.resolve,
    m = p.orient,
    _ = e.Elements,
    d = _.list,
    y = _.track,
    v;
  function S() {
    (v = e.Transition), i([Os, Md, Cn, kt], E);
  }
  function E() {
    e.Controller.isBusy() || (e.Scroll.cancel(), M(r.index), e.Slides.update());
  }
  function b(z, oe, te, X) {
    z !== oe && k(z > te) && (D(), C(T(F(), z > te), !0)),
      a(Ja),
      s(zr, oe, te, z),
      v.start(oe, function () {
        a(qa), s(bl, oe, te, z), X && X();
      });
  }
  function M(z) {
    C(L(z, !0));
  }
  function C(z, oe) {
    if (!r.is(Al)) {
      var te = oe ? z : x(z);
      mi(d, "transform", "translate" + g("X") + "(" + te + "px)"),
        z !== te && s(mv);
    }
  }
  function x(z) {
    if (r.is(eo)) {
      var oe = N(z),
        te = oe > e.Controller.getEnd(),
        X = oe < 0;
      (X || te) && (z = T(z, te));
    }
    return z;
  }
  function T(z, oe) {
    var te = z - A(oe),
      X = f();
    return (z -= m(X * (cl(Mn(te) / X) || 1)) * (oe ? 1 : -1)), z;
  }
  function D() {
    C(F(), !0), v.cancel();
  }
  function N(z) {
    for (
      var oe = e.Slides.get(), te = 0, X = 1 / 0, Y = 0;
      Y < oe.length;
      Y++
    ) {
      var le = oe[Y].index,
        W = Mn(L(le, !0) - z);
      if (W <= X) (X = W), (te = le);
      else break;
    }
    return te;
  }
  function L(z, oe) {
    var te = m(u(z - 1) - j(z));
    return oe ? I(te) : te;
  }
  function F() {
    var z = g("left");
    return Zn(d)[z] - Zn(y)[z] + m(c(!1));
  }
  function I(z) {
    return t.trimSpace && r.is(ja) && (z = da(z, 0, m(f(!0) - h()))), z;
  }
  function j(z) {
    var oe = t.focus;
    return oe === "center" ? (h() - l(z, !0)) / 2 : +oe * l(z) || 0;
  }
  function A(z) {
    return L(z ? e.Controller.getEnd() : 0, !!t.trimSpace);
  }
  function k(z) {
    var oe = m(T(F(), z));
    return z ? oe >= 0 : oe <= d[g("scrollWidth")] - Zn(y)[g("width")];
  }
  function G(z, oe) {
    oe = xl(oe) ? F() : oe;
    var te = z !== !0 && m(oe) < m(A(!1)),
      X = z !== !1 && m(oe) > m(A(!0));
    return te || X;
  }
  return {
    mount: S,
    move: b,
    jump: M,
    translate: C,
    shift: T,
    cancel: D,
    toIndex: N,
    toPosition: L,
    getPosition: F,
    getLimit: A,
    exceededLimit: G,
    reposition: E,
  };
}
function pR(r, e, t) {
  var n = At(r),
    i = n.on,
    s = n.emit,
    a = e.Move,
    o = a.getPosition,
    l = a.getLimit,
    c = a.toPosition,
    u = e.Slides,
    h = u.isEnough,
    f = u.getLength,
    p = t.omitEnd,
    g = r.is(eo),
    m = r.is(ja),
    _ = gt(F, !1),
    d = gt(F, !0),
    y = t.start || 0,
    v,
    S = y,
    E,
    b,
    M;
  function C() {
    x(), i([Cn, kt, Jc], x), i(Md, T);
  }
  function x() {
    (E = f(!0)), (b = t.perMove), (M = t.perPage), (v = k());
    var W = da(y, 0, p ? v : E - 1);
    W !== y && ((y = W), a.reposition());
  }
  function T() {
    v !== k() && s(Jc);
  }
  function D(W, O, Me) {
    if (!le()) {
      var ve = L(W),
        re = A(ve);
      re > -1 && (O || re !== y) && (te(re), a.move(ve, re, S, Me));
    }
  }
  function N(W, O, Me, ve) {
    e.Scroll.scroll(W, O, Me, function () {
      var re = A(a.toIndex(o()));
      te(p ? kr(re, v) : re), ve && ve();
    });
  }
  function L(W) {
    var O = y;
    if (Br(W)) {
      var Me = W.match(/([+\-<>])(\d+)?/) || [],
        ve = Me[1],
        re = Me[2];
      ve === "+" || ve === "-"
        ? (O = I(y + +("" + ve + (+re || 1)), y))
        : ve === ">"
        ? (O = re ? G(+re) : _(!0))
        : ve === "<" && (O = d(!0));
    } else O = g ? W : da(W, 0, v);
    return O;
  }
  function F(W, O) {
    var Me = b || (Y() ? 1 : M),
      ve = I(y + Me * (W ? -1 : 1), y, !(b || Y()));
    return ve === -1 && m && !av(o(), l(!W), 1) ? (W ? 0 : v) : O ? ve : A(ve);
  }
  function I(W, O, Me) {
    if (h() || Y()) {
      var ve = j(W);
      ve !== W && ((O = W), (W = ve), (Me = !1)),
        W < 0 || W > v
          ? !b && (Cc(0, W, O, !0) || Cc(v, O, W, !0))
            ? (W = G(z(W)))
            : g
            ? (W = Me ? (W < 0 ? -(E % M || M) : E) : W)
            : t.rewind
            ? (W = W < 0 ? v : 0)
            : (W = -1)
          : Me && W !== O && (W = G(z(O) + (W < O ? -1 : 1)));
    } else W = -1;
    return W;
  }
  function j(W) {
    if (m && t.trimSpace === "move" && W !== y)
      for (var O = o(); O === c(W, !0) && Cc(W, 0, r.length - 1, !t.rewind); )
        W < y ? --W : ++W;
    return W;
  }
  function A(W) {
    return g ? (W + E) % E || 0 : W;
  }
  function k() {
    for (var W = E - (Y() || (g && b) ? 1 : M); p && W-- > 0; )
      if (c(E - 1, !0) !== c(W, !0)) {
        W++;
        break;
      }
    return da(W, 0, E - 1);
  }
  function G(W) {
    return da(Y() ? W : M * W, 0, v);
  }
  function z(W) {
    return Y() ? kr(W, v) : Zc((W >= v ? E - 1 : W) / M);
  }
  function oe(W) {
    var O = a.toIndex(W);
    return m ? da(O, 0, v) : O;
  }
  function te(W) {
    W !== y && ((S = y), (y = W));
  }
  function X(W) {
    return W ? S : y;
  }
  function Y() {
    return !xl(t.focus) || t.isNavigation;
  }
  function le() {
    return r.state.is([Ja, vl]) && !!t.waitForTransition;
  }
  return {
    mount: C,
    go: D,
    scroll: N,
    getNext: _,
    getPrev: d,
    getAdjacent: F,
    getEnd: k,
    setIndex: te,
    getIndex: X,
    toIndex: G,
    toPage: z,
    toDest: oe,
    hasFocus: Y,
    isBusy: le,
  };
}
var mR = "http://www.w3.org/2000/svg",
  _R =
    "m15.5 0.932-4.3 4.38 14.5 14.6-14.5 14.5 4.3 4.4 14.6-14.6 4.4-4.3-4.4-4.4-14.6-14.6z",
  dc = 40;
function gR(r, e, t) {
  var n = At(r),
    i = n.on,
    s = n.bind,
    a = n.emit,
    o = t.classes,
    l = t.i18n,
    c = e.Elements,
    u = e.Controller,
    h = c.arrows,
    f = c.track,
    p = h,
    g = c.prev,
    m = c.next,
    _,
    d,
    y = {};
  function v() {
    E(), i(Cn, S);
  }
  function S() {
    b(), v();
  }
  function E() {
    var N = t.arrows;
    N && !(g && m) && x(),
      g &&
        m &&
        (ol(y, { prev: g, next: m }),
        ll(p, N ? "" : "none"),
        Fi(p, (d = Rd + "--" + t.direction)),
        N && (M(), D(), Ye([g, m], Tl, f.id), a(k1, g, m)));
  }
  function b() {
    n.destroy(),
      ir(p, d),
      _ ? (Ps(h ? [g, m] : p), (g = m = null)) : Bi([g, m], wd);
  }
  function M() {
    i([Os, bl, kt, Qa, Jc], D),
      s(m, "click", gt(C, ">")),
      s(g, "click", gt(C, "<"));
  }
  function C(N) {
    u.go(N, !0);
  }
  function x() {
    (p = h || La("div", o.arrows)),
      (g = T(!0)),
      (m = T(!1)),
      (_ = !0),
      El(p, [g, m]),
      !h && xd(p, f);
  }
  function T(N) {
    var L =
      '<button class="' +
      o.arrow +
      " " +
      (N ? o.prev : o.next) +
      '" type="button"><svg xmlns="' +
      mR +
      '" viewBox="0 0 ' +
      dc +
      " " +
      dc +
      '" width="' +
      dc +
      '" height="' +
      dc +
      '" focusable="false"><path d="' +
      (t.arrowPath || _R) +
      '" />';
    return rv(L);
  }
  function D() {
    if (g && m) {
      var N = r.index,
        L = u.getPrev(),
        F = u.getNext(),
        I = L > -1 && N < L ? l.last : l.prev,
        j = F > -1 && N > F ? l.first : l.next;
      (g.disabled = L < 0),
        (m.disabled = F < 0),
        Ye(g, ri, I),
        Ye(m, ri, j),
        a(z1, g, m, L, F);
    }
  }
  return { arrows: y, mount: v, destroy: b, update: D };
}
var vR = Ed + "-interval";
function xR(r, e, t) {
  var n = At(r),
    i = n.on,
    s = n.bind,
    a = n.emit,
    o = _u(t.interval, r.go.bind(r, ">"), M),
    l = o.isPaused,
    c = e.Elements,
    u = e.Elements,
    h = u.root,
    f = u.toggle,
    p = t.autoplay,
    g,
    m,
    _ = p === "pause";
  function d() {
    p && (y(), f && Ye(f, Tl, c.track.id), _ || v(), b());
  }
  function y() {
    t.pauseOnHover &&
      s(h, "mouseenter mouseleave", function (x) {
        (g = x.type === "mouseenter"), E();
      }),
      t.pauseOnFocus &&
        s(h, "focusin focusout", function (x) {
          (m = x.type === "focusin"), E();
        }),
      f &&
        s(f, "click", function () {
          _ ? v() : S(!0);
        }),
      i([zr, bd, kt], o.rewind),
      i(zr, C);
  }
  function v() {
    l() &&
      e.Slides.isEnough() &&
      (o.start(!t.resetProgress), (m = g = _ = !1), b(), a(hv));
  }
  function S(x) {
    x === void 0 && (x = !0), (_ = !!x), b(), l() || (o.pause(), a(fv));
  }
  function E() {
    _ || (g || m ? S(!1) : v());
  }
  function b() {
    f && (nr(f, Ls, !_), Ye(f, ri, t.i18n[_ ? "play" : "pause"]));
  }
  function M(x) {
    var T = c.bar;
    T && mi(T, "width", x * 100 + "%"), a(G1, x);
  }
  function C(x) {
    var T = e.Slides.getAt(x);
    o.set((T && +_i(T.slide, vR)) || t.interval);
  }
  return { mount: d, destroy: o.cancel, play: v, pause: S, isPaused: l };
}
function yR(r, e, t) {
  var n = At(r),
    i = n.on;
  function s() {
    t.cover && (i(dv, gt(o, !0)), i([Os, Cn, kt], gt(a, !0)));
  }
  function a(l) {
    e.Slides.forEach(function (c) {
      var u = Sl(c.container || c.slide, "img");
      u && u.src && o(l, u, c);
    });
  }
  function o(l, c, u) {
    u.style(
      "background",
      l ? 'center/cover no-repeat url("' + c.src + '")' : "",
      !0
    ),
      ll(c, l ? "none" : "");
  }
  return { mount: s, destroy: gt(a, !1) };
}
var ER = 10,
  SR = 600,
  MR = 0.6,
  bR = 1.5,
  TR = 800;
function AR(r, e, t) {
  var n = At(r),
    i = n.on,
    s = n.emit,
    a = r.state.set,
    o = e.Move,
    l = o.getPosition,
    c = o.getLimit,
    u = o.exceededLimit,
    h = o.translate,
    f = r.is(ja),
    p,
    g,
    m = 1;
  function _() {
    i(zr, S), i([Cn, kt], E);
  }
  function d(M, C, x, T, D) {
    var N = l();
    if ((S(), x && (!f || !u()))) {
      var L = e.Layout.sliderSize(),
        F = yf(M) * L * Zc(Mn(M) / L) || 0;
      M = o.toPosition(e.Controller.toDest(M % L)) + F;
    }
    var I = av(N, M, 1);
    (m = 1),
      (C = I ? 0 : C || $c(Mn(M - N) / bR, TR)),
      (g = T),
      (p = _u(C, y, gt(v, N, M, D), 1)),
      a(vl),
      s(bd),
      p.start();
  }
  function y() {
    a(qa), g && g(), s(Qa);
  }
  function v(M, C, x, T) {
    var D = l(),
      N = M + (C - M) * b(T),
      L = (N - D) * m;
    h(D + L),
      f && !x && u() && ((m *= MR), Mn(L) < ER && d(c(u(!0)), SR, !1, g, !0));
  }
  function S() {
    p && p.cancel();
  }
  function E() {
    p && !p.isPaused() && (S(), y());
  }
  function b(M) {
    var C = t.easingFunc;
    return C ? C(M) : 1 - Math.pow(1 - M, 4);
  }
  return { mount: _, destroy: S, scroll: d, cancel: E };
}
var pa = { passive: !1, capture: !0 };
function wR(r, e, t) {
  var n = At(r),
    i = n.on,
    s = n.emit,
    a = n.bind,
    o = n.unbind,
    l = r.state,
    c = e.Move,
    u = e.Scroll,
    h = e.Controller,
    f = e.Elements.track,
    p = e.Media.reduce,
    g = e.Direction,
    m = g.resolve,
    _ = g.orient,
    d = c.getPosition,
    y = c.exceededLimit,
    v,
    S,
    E,
    b,
    M,
    C = !1,
    x,
    T,
    D;
  function N() {
    a(f, Ah, vf, pa),
      a(f, wh, vf, pa),
      a(f, Rv, F, pa),
      a(f, "click", A, { capture: !0 }),
      a(f, "dragstart", Zi),
      i([Os, Cn], L);
  }
  function L() {
    var ae = t.drag;
    Fe(!ae), (b = ae === "free");
  }
  function F(ae) {
    if (((x = !1), !T)) {
      var _e = re(ae);
      ve(ae.target) &&
        (_e || !ae.button) &&
        (h.isBusy()
          ? Zi(ae, !0)
          : ((D = _e ? f : window),
            (M = l.is([Ja, vl])),
            (E = null),
            a(D, Ah, I, pa),
            a(D, wh, j, pa),
            c.cancel(),
            u.cancel(),
            k(ae)));
    }
  }
  function I(ae) {
    if ((l.is(wc) || (l.set(wc), s(O1)), ae.cancelable))
      if (M) {
        c.translate(v + Me(Y(ae)));
        var _e = le(ae) > C_,
          K = C !== (C = y());
        (_e || K) && k(ae), (x = !0), s(U1), Zi(ae);
      } else oe(ae) && ((M = z(ae)), Zi(ae));
  }
  function j(ae) {
    l.is(wc) && (l.set(qa), s(F1)),
      M && (G(ae), Zi(ae)),
      o(D, Ah, I),
      o(D, wh, j),
      (M = !1);
  }
  function A(ae) {
    !T && x && Zi(ae, !0);
  }
  function k(ae) {
    (E = S), (S = ae), (v = d());
  }
  function G(ae) {
    var _e = te(ae),
      K = X(_e),
      $e = t.rewind && t.rewindByDrag;
    p(!1),
      b
        ? h.scroll(K, 0, t.snap)
        : r.is(Al)
        ? h.go(_(yf(_e)) < 0 ? ($e ? "<" : "-") : $e ? ">" : "+")
        : r.is(ja) && C && $e
        ? h.go(y(!0) ? ">" : "<")
        : h.go(h.toDest(K), !0),
      p(!0);
  }
  function z(ae) {
    var _e = t.dragMinThreshold,
      K = rl(_e),
      $e = (K && _e.mouse) || 0,
      ct = (K ? _e.touch : +_e) || 10;
    return Mn(Y(ae)) > (re(ae) ? ct : $e);
  }
  function oe(ae) {
    return Mn(Y(ae)) > Mn(Y(ae, !0));
  }
  function te(ae) {
    if (r.is(eo) || !C) {
      var _e = le(ae);
      if (_e && _e < C_) return Y(ae) / _e;
    }
    return 0;
  }
  function X(ae) {
    return (
      d() +
      yf(ae) *
        kr(
          Mn(ae) * (t.flickPower || 600),
          b ? 1 / 0 : e.Layout.listSize() * (t.flickMaxPages || 1)
        )
    );
  }
  function Y(ae, _e) {
    return O(ae, _e) - O(W(ae), _e);
  }
  function le(ae) {
    return xf(ae) - xf(W(ae));
  }
  function W(ae) {
    return (S === ae && E) || S;
  }
  function O(ae, _e) {
    return (re(ae) ? ae.changedTouches[0] : ae)["page" + m(_e ? "Y" : "X")];
  }
  function Me(ae) {
    return ae / (C && r.is(ja) ? aR : 1);
  }
  function ve(ae) {
    var _e = t.noDrag;
    return !sl(ae, "." + Mv + ", ." + Su) && (!_e || !sl(ae, _e));
  }
  function re(ae) {
    return typeof TouchEvent < "u" && ae instanceof TouchEvent;
  }
  function be() {
    return M;
  }
  function Fe(ae) {
    T = ae;
  }
  return { mount: N, disable: Fe, isDragging: be };
}
var RR = { Spacebar: " ", Right: xu, Left: vu, Up: _v, Down: gv };
function Cd(r) {
  return (r = Br(r) ? r : r.key), RR[r] || r;
}
var P_ = "keydown";
function CR(r, e, t) {
  var n = At(r),
    i = n.on,
    s = n.bind,
    a = n.unbind,
    o = r.root,
    l = e.Direction.resolve,
    c,
    u;
  function h() {
    f(), i(Cn, p), i(Cn, f), i(zr, m);
  }
  function f() {
    var d = t.keyboard;
    d && ((c = d === "global" ? window : o), s(c, P_, _));
  }
  function p() {
    a(c, P_);
  }
  function g(d) {
    u = d;
  }
  function m() {
    var d = u;
    (u = !0),
      Q0(function () {
        u = d;
      });
  }
  function _(d) {
    if (!u) {
      var y = Cd(d);
      y === l(vu) ? r.go("<") : y === l(xu) && r.go(">");
    }
  }
  return { mount: h, destroy: p, disable: g };
}
var Ho = Ed + "-lazy",
  Pc = Ho + "-srcset",
  PR = "[" + Ho + "], [" + Pc + "]";
function LR(r, e, t) {
  var n = At(r),
    i = n.on,
    s = n.off,
    a = n.bind,
    o = n.emit,
    l = t.lazyLoad === "sequential",
    c = [bl, Qa],
    u = [];
  function h() {
    t.lazyLoad && (f(), i(kt, f));
  }
  function f() {
    ur(u), p(), l ? d() : (s(c), i(c, g), g());
  }
  function p() {
    e.Slides.forEach(function (y) {
      yd(y.slide, PR).forEach(function (v) {
        var S = _i(v, Ho),
          E = _i(v, Pc);
        if (S !== v.src || E !== v.srcset) {
          var b = t.classes.spinner,
            M = v.parentElement,
            C = Sl(M, "." + b) || La("span", b, M);
          u.push([v, y, C]), v.src || ll(v, "none");
        }
      });
    });
  }
  function g() {
    (u = u.filter(function (y) {
      var v = t.perPage * ((t.preloadPages || 1) + 1) - 1;
      return y[1].isWithin(r.index, v) ? m(y) : !0;
    })),
      u.length || s(c);
  }
  function m(y) {
    var v = y[0];
    Fi(y[1].slide, Mf),
      a(v, "load error", gt(_, y)),
      Ye(v, "src", _i(v, Ho)),
      Ye(v, "srcset", _i(v, Pc)),
      Bi(v, Ho),
      Bi(v, Pc);
  }
  function _(y, v) {
    var S = y[0],
      E = y[1];
    ir(E.slide, Mf),
      v.type !== "error" && (Ps(y[2]), ll(S, ""), o(dv, S, E), o(ul)),
      l && d();
  }
  function d() {
    u.length && m(u.shift());
  }
  return { mount: h, destroy: gt(ur, u), check: g };
}
function DR(r, e, t) {
  var n = At(r),
    i = n.on,
    s = n.emit,
    a = n.bind,
    o = e.Slides,
    l = e.Elements,
    c = e.Controller,
    u = c.hasFocus,
    h = c.getIndex,
    f = c.go,
    p = e.Direction.resolve,
    g = l.pagination,
    m = [],
    _,
    d;
  function y() {
    v(), i([Cn, kt, Jc], y);
    var T = t.pagination;
    g && ll(g, T ? "" : "none"),
      T &&
        (i([zr, bd, Qa], x),
        S(),
        x(),
        s(H1, { list: _, items: m }, C(r.index)));
  }
  function v() {
    _ && (Ps(g ? Xr(_.children) : _), ir(_, d), ur(m), (_ = null)), n.destroy();
  }
  function S() {
    var T = r.length,
      D = t.classes,
      N = t.i18n,
      L = t.perPage,
      F = u() ? c.getEnd() + 1 : cl(T / L);
    (_ = g || La("ul", D.pagination, l.track.parentElement)),
      Fi(_, (d = Mu + "--" + M())),
      Ye(_, ar, "tablist"),
      Ye(_, ri, N.select),
      Ye(_, Ad, M() === yu ? "vertical" : "");
    for (var I = 0; I < F; I++) {
      var j = La("li", null, _),
        A = La("button", { class: D.page, type: "button" }, j),
        k = o.getIn(I).map(function (z) {
          return z.slide.id;
        }),
        G = !u() && L > 1 ? N.pageX : N.slideX;
      a(A, "click", gt(E, I)),
        t.paginationKeyboard && a(A, "keydown", gt(b, I)),
        Ye(j, ar, "presentation"),
        Ye(A, ar, "tab"),
        Ye(A, Tl, k.join(" ")),
        Ye(A, ri, Ef(G, I + 1)),
        Ye(A, Da, -1),
        m.push({ li: j, button: A, page: I });
    }
  }
  function E(T) {
    f(">" + T, !0);
  }
  function b(T, D) {
    var N = m.length,
      L = Cd(D),
      F = M(),
      I = -1;
    L === p(xu, !1, F)
      ? (I = ++T % N)
      : L === p(vu, !1, F)
      ? (I = (--T + N) % N)
      : L === "Home"
      ? (I = 0)
      : L === "End" && (I = N - 1);
    var j = m[I];
    j && (iv(j.button), f(">" + I), Zi(D, !0));
  }
  function M() {
    return t.paginationDirection || t.direction;
  }
  function C(T) {
    return m[c.toPage(T)];
  }
  function x() {
    var T = C(h(!0)),
      D = C(h());
    if (T) {
      var N = T.button;
      ir(N, Ls), Bi(N, b_), Ye(N, Da, -1);
    }
    if (D) {
      var L = D.button;
      Fi(L, Ls), Ye(L, b_, !0), Ye(L, Da, "");
    }
    s(V1, { list: _, items: m }, T, D);
  }
  return { items: m, mount: y, destroy: v, getAt: C, update: x };
}
var IR = [" ", "Enter"];
function NR(r, e, t) {
  var n = t.isNavigation,
    i = t.slideFocus,
    s = [];
  function a() {
    r.splides.forEach(function (g) {
      g.isParent || (c(r, g.splide), c(g.splide, r));
    }),
      n && u();
  }
  function o() {
    s.forEach(function (g) {
      g.destroy();
    }),
      ur(s);
  }
  function l() {
    o(), a();
  }
  function c(g, m) {
    var _ = At(g);
    _.on(zr, function (d, y, v) {
      m.go(m.is(eo) ? v : d);
    }),
      s.push(_);
  }
  function u() {
    var g = At(r),
      m = g.on;
    m(lv, f), m(pv, p), m([Os, Cn], h), s.push(g), g.emit(uv, r.splides);
  }
  function h() {
    Ye(e.Elements.list, Ad, t.direction === yu ? "vertical" : "");
  }
  function f(g) {
    r.go(g.index);
  }
  function p(g, m) {
    vd(IR, Cd(m)) && (f(g), Zi(m));
  }
  return {
    setup: gt(e.Media.set, { slideFocus: xl(i) ? n : i }, !0),
    mount: a,
    destroy: o,
    remount: l,
  };
}
function OR(r, e, t) {
  var n = At(r),
    i = n.bind,
    s = 0;
  function a() {
    t.wheel && i(e.Elements.track, "wheel", o, pa);
  }
  function o(c) {
    if (c.cancelable) {
      var u = c.deltaY,
        h = u < 0,
        f = xf(c),
        p = t.wheelMinThreshold || 0,
        g = t.wheelSleep || 0;
      Mn(u) > p && f - s > g && (r.go(h ? "<" : ">"), (s = f)), l(h) && Zi(c);
    }
  }
  function l(c) {
    return (
      !t.releaseWheel || r.state.is(Ja) || e.Controller.getAdjacent(c) !== -1
    );
  }
  return { mount: a };
}
var UR = 90;
function FR(r, e, t) {
  var n = At(r),
    i = n.on,
    s = e.Elements.track,
    a = t.live && !t.isNavigation,
    o = La("span", tR),
    l = _u(UR, gt(u, !1));
  function c() {
    a &&
      (f(!e.Autoplay.isPaused()),
      Ye(s, w_, !0),
      (o.textContent = ""),
      i(hv, gt(f, !0)),
      i(fv, gt(f, !1)),
      i([bl, Qa], gt(u, !0)));
  }
  function u(p) {
    Ye(s, A_, p), p ? (El(s, o), l.start()) : (Ps(o), l.cancel());
  }
  function h() {
    Bi(s, [T_, w_, A_]), Ps(o);
  }
  function f(p) {
    a && Ye(s, T_, p ? "off" : "polite");
  }
  return { mount: c, disable: f, destroy: h };
}
var BR = Object.freeze({
    __proto__: null,
    Media: Y1,
    Direction: q1,
    Elements: oR,
    Slides: cR,
    Layout: uR,
    Clones: fR,
    Move: dR,
    Controller: pR,
    Arrows: gR,
    Autoplay: xR,
    Cover: yR,
    Scroll: AR,
    Drag: wR,
    Keyboard: CR,
    LazyLoad: LR,
    Pagination: DR,
    Sync: NR,
    Wheel: OR,
    Live: FR,
  }),
  kR = {
    prev: "Previous slide",
    next: "Next slide",
    first: "Go to first slide",
    last: "Go to last slide",
    slideX: "Go to slide %s",
    pageX: "Go to page %s",
    play: "Start autoplay",
    pause: "Pause autoplay",
    carousel: "carousel",
    slide: "slide",
    select: "Select a slide to show",
    slideLabel: "%s of %s",
  },
  zR = {
    type: "slide",
    role: "region",
    speed: 400,
    perPage: 1,
    cloneStatus: !0,
    arrows: !0,
    pagination: !0,
    paginationKeyboard: !0,
    interval: 5e3,
    pauseOnHover: !0,
    pauseOnFocus: !0,
    resetProgress: !0,
    easing: "cubic-bezier(0.25, 1, 0.5, 1)",
    drag: !0,
    direction: "ltr",
    trimSpace: !0,
    focusableNodes: "a, button, textarea, input, select, iframe",
    live: !0,
    classes: rR,
    i18n: kR,
    reducedMotion: { speed: 0, rewindSpeed: 0, autoplay: "pause" },
  };
function HR(r, e, t) {
  var n = e.Slides;
  function i() {
    At(r).on([Os, kt], s);
  }
  function s() {
    n.forEach(function (o) {
      o.style("transform", "translateX(-" + 100 * o.index + "%)");
    });
  }
  function a(o, l) {
    n.style("transition", "opacity " + t.speed + "ms " + t.easing), Q0(l);
  }
  return { mount: i, start: a, cancel: vf };
}
function VR(r, e, t) {
  var n = e.Move,
    i = e.Controller,
    s = e.Scroll,
    a = e.Elements.list,
    o = gt(mi, a, "transition"),
    l;
  function c() {
    At(r).bind(a, "transitionend", function (p) {
      p.target === a && l && (h(), l());
    });
  }
  function u(p, g) {
    var m = n.toPosition(p, !0),
      _ = n.getPosition(),
      d = f(p);
    Mn(m - _) >= 1 && d >= 1
      ? t.useScroll
        ? s.scroll(m, d, !1, g)
        : (o("transform " + d + "ms " + t.easing), n.translate(m, !0), (l = g))
      : (n.jump(p), g());
  }
  function h() {
    o(""), s.cancel();
  }
  function f(p) {
    var g = t.rewindSpeed;
    if (r.is(ja) && g) {
      var m = i.getIndex(!0),
        _ = i.getEnd();
      if ((m === 0 && p >= _) || (m >= _ && p === 0)) return g;
    }
    return t.speed;
  }
  return { mount: c, start: u, cancel: h };
}
var GR = (function () {
    function r(t, n) {
      (this.event = At()),
        (this.Components = {}),
        (this.state = W1(Ea)),
        (this.splides = []),
        (this._o = {}),
        (this._E = {});
      var i = Br(t) ? sv(document, t) : t;
      zo(i, i + " is invalid."),
        (this.root = i),
        (n = Rr(
          { label: _i(i, ri) || "", labelledby: _i(i, Td) || "" },
          zR,
          r.defaults,
          n || {}
        ));
      try {
        Rr(n, JSON.parse(_i(i, Ed)));
      } catch {
        zo(!1, "Invalid JSON");
      }
      this._o = Object.create(Rr({}, n));
    }
    var e = r.prototype;
    return (
      (e.mount = function (n, i) {
        var s = this,
          a = this.state,
          o = this.Components;
        zo(a.is([Ea, Kc]), "Already mounted!"),
          a.set(Ea),
          (this._C = o),
          (this._T = i || this._T || (this.is(Al) ? HR : VR)),
          (this._E = n || this._E);
        var l = ol({}, BR, this._E, { Transition: this._T });
        return (
          Es(l, function (c, u) {
            var h = c(s, o, s._o);
            (o[u] = h), h.setup && h.setup();
          }),
          Es(o, function (c) {
            c.mount && c.mount();
          }),
          this.emit(Os),
          Fi(this.root, nR),
          a.set(qa),
          this.emit(S_),
          this
        );
      }),
      (e.sync = function (n) {
        return (
          this.splides.push({ splide: n }),
          n.splides.push({ splide: this, isParent: !0 }),
          this.state.is(qa) &&
            (this._C.Sync.remount(), n.Components.Sync.remount()),
          this
        );
      }),
      (e.go = function (n) {
        return this._C.Controller.go(n), this;
      }),
      (e.on = function (n, i) {
        return this.event.on(n, i), this;
      }),
      (e.off = function (n) {
        return this.event.off(n), this;
      }),
      (e.emit = function (n) {
        var i;
        return (
          (i = this.event).emit.apply(i, [n].concat(Xr(arguments, 1))), this
        );
      }),
      (e.add = function (n, i) {
        return this._C.Slides.add(n, i), this;
      }),
      (e.remove = function (n) {
        return this._C.Slides.remove(n), this;
      }),
      (e.is = function (n) {
        return this._o.type === n;
      }),
      (e.refresh = function () {
        return this.emit(kt), this;
      }),
      (e.destroy = function (n) {
        n === void 0 && (n = !0);
        var i = this.event,
          s = this.state;
        return (
          s.is(Ea)
            ? At(this).on(S_, this.destroy.bind(this, n))
            : (Es(
                this._C,
                function (a) {
                  a.destroy && a.destroy(n);
                },
                !0
              ),
              i.emit(cv),
              i.destroy(),
              n && ur(this.splides),
              s.set(Kc)),
          this
        );
      }),
      w1(r, [
        {
          key: "options",
          get: function () {
            return this._o;
          },
          set: function (n) {
            this._C.Media.set(n, !0, !0);
          },
        },
        {
          key: "length",
          get: function () {
            return this._C.Slides.getLength(!0);
          },
        },
        {
          key: "index",
          get: function () {
            return this._C.Controller.getIndex();
          },
        },
      ]),
      r
    );
  })(),
  Pd = GR;
Pd.defaults = {};
Pd.STATES = C1;
function WR() {
  new Pd(".splide", {
    gap: "50px",
    padding: { left: "50px", right: "50px" },
    perPage: 3,
    breakpoints: { 575: { perPage: 2 }, 375: { perPage: 1 } },
    type: "loop",
    pagination: !1,
    focus: "center",
  }).mount();
}
Jw();
WR();
const { sizes: oa } = ml,
  Qc = { x: 0, y: 0 };
let bf = null,
  Cv = null;
XR().then((r) => {
  (Cv = r), (bf = r.cloud), YR(r);
});
async function XR() {
  const e = new Zw("./Galaxy2.glb", 48999);
  await e.init();
  const t = new Kw("./globe.glb", 48999);
  await t.init();
  const n = new jw("./brain.glb", 48999);
  await n.init();
  const i = new $w("./Robot.glb", 48999);
  await i.init();
  const s = [i, n, t, e],
    a = new A1(s);
  return (
    (a.cloud.position.x = zh() ? 150 : 300),
    (a.cloud.rotation.y = Math.PI / 2.5),
    _l.add(a.cloud),
    a
  );
}
function YR(r) {
  Hc.registerPlugin(He);
  const t = Hc.timeline({
    ease: "slow",
    scrollTrigger: {
      trigger: ".wrapper",
      start: "top top",
      end: "100% top",
      scrub: 4,
    },
  });
  t.to(r.cloud.position, { x: -150 }),
    t.to(r.cloud.rotation, { y: Math.PI * 2.5 }, "<"),
    t.to(r.cloud.position, { x: 0 }),
    t.to(r.material.uniforms.uDestruction, { value: 1 }),
    t.to(r.cloud.position, { x: -150, y: -150 }, "<"),
    t.to(r.cloud.position, { x: 0, y: 0 }),
    t.to(r.material.uniforms.uDestruction, { value: 0, duration: 0.5 }, "<"),
    t.to(r.material.uniforms.uMorph2, { value: 1 }, "<"),
    t.to(r.cloud.rotation, { y: Math.PI * 3.5 }),
    t.to(r.cloud.position, { x: () => (zh() ? -150 : -350) }, "<"),
    t.to(r.cloud.position, { x: () => (zh() ? 150 : 300) }),
    t.to(r.material.uniforms.uMorph3, { value: 1 }),
    t.to(r.cloud.position, { x: -150 }),
    t.to(r.cloud.rotation, { y: Math.PI * 4 }, "<"),
    t.to(r.material.uniforms.uDestruction, { value: 1 }),
    t.to(r.cloud.position, { x: -200 }, "<"),
    t.to(r.material.uniforms.uMorph4, { value: 1 }),
    t.to(r.material.uniforms.uDestruction, { value: 0 }, "<"),
    t.to(r.cloud.rotation, { z: Math.PI / 2 }),
    t.to(r.cloud.position, { x: 150 }, "<"),
    t.to(r.cloud.position, { x: Math.PI / 5 });
}
const L_ = 800,
  Pv = new Vn(new lu(L_ * 4, L_), new Sr({ color: "rgba(0, 0, 0, 0)" }));
_l.add(Pv);
const qR = new kT(ei, Oi.domElement);
Oi.render(_l, ei);
const Tf = new We(),
  D_ = new DT(),
  jR = new ST();
function Lv() {
  if ((jR.getElapsedTime(), qR.update(), D_.setFromCamera(Tf, ei), Cv)) {
    const r = D_.intersectObject(Pv)[0];
    bf.material.uniforms.uPoint.value = r.point;
  }
  bf && KR(), Oi.render(_l, ei), requestAnimationFrame(Lv);
}
Lv();
function KR() {
  (ei.rotation.y = Dc.lerp(ei.rotation.y, (Qc.x * Math.PI) / 20, 0.1)),
    (ei.rotation.x = Dc.lerp(ei.rotation.x, (Qc.y * Math.PI) / 20, 0.1));
}
window.addEventListener("resize", () => {
  (oa.width = window.innerWidth),
    (oa.height = window.innerHeight),
    OT(oa.width, oa.height),
    BT(oa.width, oa.height),
    Oi.render(_l, ei);
});
window.addEventListener("mousemove", (r) => {
  (Qc.x = 1 - 2 * (r.clientX / window.innerWidth)),
    (Qc.y = 1 - 2 * (r.clientY / window.innerHeight)),
    (Tf.x = (r.clientX / window.innerWidth) * 2 - 1),
    (Tf.y = -(r.clientY / window.innerHeight) * 2 + 1);
});

//  renderer
// alpha
// antialias
// WebGLRenderer(
// canvas
//  Oi = new Zi({ antialias: true, alpha: true });

//  color4
// #FFB332
// rgba
